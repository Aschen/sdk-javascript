{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kuzzle.js","webpack:///webpack/bootstrap acd8f2ec6a57e2c5517f","webpack:///./src/Kuzzle.js","webpack:///./src/security/SecurityDocument.js","webpack:///./src/Document.js","webpack:///./src/eventEmitter/index.js","webpack:///./src/networkWrapper/wrappers/websocket.js","webpack:///./src/security/User.js","webpack:///../~/uuid/v4.js","webpack:///./src/Collection.js","webpack:///./src/CollectionMapping.js","webpack:///./src/MemoryStorage.js","webpack:///./src/Room.js","webpack:///./src/SearchResult.js","webpack:///./src/SubscribeResult.js","webpack:///./src/networkWrapper/index.js","webpack:///./src/networkWrapper/wrappers/socketio.js","webpack:///./src/security/Profile.js","webpack:///./src/security/Role.js","webpack:///./src/security/Security.js","webpack:///../~/events/events.js","webpack:///../~/uuid/lib/bytesToUuid.js","webpack:///../~/uuid/lib/rng-browser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Kuzzle","host","options","cb","self","KuzzleEventEmitter","Error","Object","defineProperties","cleanHistoryTimer","value","writable","collections","connectCB","eventActions","queuing","requestHistory","state","subscriptions","pending","autoReconnect","enumerable","defaultIndex","undefined","reconnectionDelay","port","sslConnection","autoQueue","autoReplay","autoResubscribe","headers","volatile","offlineQueue","queueFilter","queueMaxSize","queueTTL","replayInterval","jwtToken","offlineQueueLoader","sdkVersion","keys","forEach","opt","hasOwnProperty","getOwnPropertyDescriptor","offlineMode","defineProperty","query","header","errorMessagePrefix","callback","Security","MemoryStorage","eventTimeout","writeable","connected","timeout","error","disconnected","reconnected","tokenExpired","loginAttempt","connect","setInterval","cleanHistory","bluebird","promisifyAll","suffix","filter","name","func","target","passes","whitelist","indexOf","cleanQueue","now","Date","lastDocumentIndex","index","ts","splice","droppedRequest","emitEvent","length","key","emitRequest","request","network","once","requestId","response","action","message","assign","status","send","dequeue","additionalQueue","uniqueQueue","dequeuingProcess","shift","setTimeout","Math","max","Array","isArray","concat","controller","renewAllSubscriptions","roomId","subscriptionId","subscription","renew","removeAllSubscriptions","unsubscribe","discardRequest","object","JSON","stringify","disableAllSubscriptions","subscribing","uuidv4","Collection","User","networkWrapper","prototype","create","constructor","emit","eventName","protectedEvent","protectedEvents","lastEmitted","apply","arguments","disconnect","onConnect","on","data","onConnectError","connectionError","internal","onDisconnect","onReconnect","reconnect","checkToken","err","res","valid","setJwtToken","token","success","result","jwt","unsetJwtToken","getJwtToken","login","strategy","body","expiresIn","queuable","createMyCredentials","credentials","_source","deleteMyCredentials","getMyCredentials","updateMyCredentials","validateMyCredentials","createIndex","logout","callbackRequired","whoAmI","security","_id","_meta","getMyRights","hits","updateSelf","content","queryArgs","addListener","event","listener","isValid","toString","getAllStatistics","getStatistics","timestamp","queryCB","startTime","collection","flushQueue","listCollections","args","slice","arg","type","listIndexes","indexes","clearInterval","close","getServerInfo","serverInfo","refreshIndex","getAutoRefresh","setAutoRefresh","autoRefresh","attr","refresh","from","size","scroll","scrollId","meta","addHeaders","push","replayQueue","setDefaultIndex","setHeaders","replace","startQueuing","stopQueuing","SecurityDocument","kuzzle","setContent","serialize","delete","buildQueryArgs","deleteActionName","update","updateActionName","Document","documentId","dataCollection","parse","version","_version","exists","newDocument","save","publish","subscribe","filters","ids","values","window","_events","_onceEvents","listeners","listenerType","prependListener","onceListeners","prependOnceListener","removeListener","removeAllListeners","notifyList","i","item","eventNames","listenerCount","off","WSNode","ssl","WebSocket","e","code","client","wasConnected","retrying","lasturl","stopRetryingToConnect","url","perMessageDeflate","onopen","onclose","closeEvent","reason","onClientNetworkError","onerror","onmessage","payload","room","readyState","OPEN","ws","KuzzleSecurityDocument","setProfiles","profileIds","setCredentials","addProfile","profileId","creationSerialize","saveRestricted","getProfileIds","getProfiles","fetchedProfiles","errored","fetchProfile","profile","v4","buf","offset","rnds","random","rng","ii","bytesToUuid","blacklist","KuzzleSearchResult","CollectionMapping","Room","SubscribeResult","count","createDocument","document","ifExist","doc","deleteDocument","deleteSpecifications","documentExists","fetchDocument","getMapping","kuzzleMapping","mCreateDocument","documents","map","mCreateOrReplaceDocument","mDeleteDocument","documentIds","mGetDocument","mReplaceDocument","mUpdateDocument","getSpecifications","publishMessage","replaceDocument","search","_scroll_id","total","aggregations","previous","scrollSpecifications","searchSpecifications","subscribeResult","done","bind","truncate","updateDocument","retryOnConflict","updateSpecifications","specifications","validateSpecifications","collectionMapping","mapping","properties","mappings","set","field","assignParameter","getter","assignGeoRadiusOptions","parsed","assignZrangeOptions","limit","mapGeoposResults","results","coords","latlon","parseFloat","mapGeoRadiusResults","point","coordinates","coord","distance","mapStringToArray","mapArrayStringToArrayInt","parseInt","mapZrangeResults","buffer","mapped","member","score","mapScanResults","cursor","getId","required","getIdField","getKeys","getMember","getxScan","opts","mapResults","getZrange","getZrangeBy","setId","setIdValue","setIdFieldValue","setEntries","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","geoadd","geodist","geohash","geopos","georadius","georadiusbymember","get","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","setex","setnx","sinter","sinterstore","sismember","smembers","smove","sort","spop","srandmember","srem","sscan","strlen","sunion","sunionstore","time","touch","ttl","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","command","pop","param","channel","lastRenewal","notifier","onDoneCB","queue","renewalDelay","scope","users","subscribeToSelf","notificationCallback","element","isReady","notificationCB","subscribeQuery","interval","SearchResult","fetchedDocument","fetchNext","getTotal","search_after","sortRule","getDocuments","getAggregations","getOptions","getFilters","getCollection","getFetchedDocument","cbs","onDone","io","SocketIO","socket","forceDisconnect","handlers","connectError","reconnection","forceNew","handler","socketio","Profile","policies","addPolicy","policy","roleId","setPolicies","getPolicies","Role","fetchRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","role","searchProfiles","profiles","createProfile","updateProfile","updatedContent","property","deleteProfile","scrollProfiles","newProfile","fetchUser","searchUsers","createUser","replaceUser","createRestrictedUser","updateUser","deleteUser","scrollUsers","user","newUser","isActionAllowed","rights","filteredRights","right","some","getUserRights","userId","createCredentials","kuid","deleteCredentials","getAllCredentialFields","getCredentialFields","getCredentials","hasCredentials","updateCredentials","validateCredentials","EventEmitter","_maxListeners","isFunction","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","er","len","context","newListener","warned","console","trace","g","fired","list","position","ret","evlistener","emitter","bth","byteToHex","substr","crypto","msCrypto","getRandomValues","rnds8","Uint8Array","r"],"mappings":";CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,OAAAD,IAEAD,EAAA,OAAAC,KACCK,KAAA,WACD,MCCgB,UAAUC,GCP1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDiBM,SAAUL,EAAQD,EAASM,GE9BjC,QAAAS,GAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAf,IAEA,MAAAA,eAAAW,IACA,UAAAA,GAAAC,EAAAC,EAAAC,EASA,IAPAE,EAAAT,KAAAP,MAEAc,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,OAGAD,GAAA,KAAAA,EACA,SAAAK,OAAA,wBAkQA,OA/PAC,QAAAC,iBAAAnB,MAEAoB,mBACAC,MAAA,KACAC,UAAA,GAEAC,aACAF,SACAC,UAAA,GAEAE,WACAH,MAAAP,GAEAW,cACAJ,OACA,YACA,eACA,eACA,cACA,eACA,eACA,mBACA,kBACA,aACA,aAEAC,UAAA,GAEAI,SACAL,OAAA,EACAC,UAAA,GAEAK,gBACAN,SACAC,UAAA,GAEAM,OACAP,MAAA,eACAC,UAAA,GAEAO,eAiBAR,OACAS,YAEAR,UAAA,GAGAS,eACAV,OAAAR,GAAA,iBAAAA,GAAAkB,eAAAlB,EAAAkB,cACAT,UAAA,EACAU,YAAA,GAEAC,cACAZ,MAAAR,GAAA,gBAAAA,GAAAoB,aAAApB,EAAAoB,aAAAC,OACAZ,UAAA,EACAU,YAAA,GAEAG,mBACAd,MAAAR,GAAA,gBAAAA,GAAAsB,kBAAAtB,EAAAsB,kBAAA,IACAb,UAAA,EACAU,YAAA,GAEApB,MACAS,MAAAT,EACAU,UAAA,EACAU,YAAA,GAEAI,MACAf,MAAAR,GAAA,gBAAAA,GAAAuB,KAAAvB,EAAAuB,KAAA,KACAJ,YAAA,EACAV,UAAA,GAEAe,eACAhB,SAAAR,GAAA,iBAAAA,GAAAwB,gBAAAxB,EAAAwB,cACAf,UAAA,EACAU,YAAA,GAEAM,WACAjB,OAAA,EACAW,YAAA,EACAV,UAAA,GAEAiB,YACAlB,OAAA,EACAW,YAAA,EACAV,UAAA,GAEAkB,iBACAnB,OAAA,EACAW,YAAA,EACAV,UAAA,GAEAmB,SACApB,SACAW,YAAA,EACAV,UAAA,GAEAoB,UACArB,SACAW,YAAA,EACAV,UAAA,GAYAqB,cACAtB,SACAW,YAAA,EACAV,UAAA,GAEAsB,aACAvB,MAAA,KACAW,YAAA,EACAV,UAAA,GAEAuB,cACAxB,MAAA,IACAW,YAAA,EACAV,UAAA,GAEAwB,UACAzB,MAAA,KACAW,YAAA,EACAV,UAAA,GAEAyB,gBACA1B,MAAA,GACAW,YAAA,EACAV,UAAA,GAEA0B,UACA3B,MAAAa,OACAF,YAAA,EACAV,UAAA,GAEA2B,oBACA5B,MAAAa,OACAF,YAAA,EACAV,UAAA,GAEA4B,YACA7B,MAAA,SACAC,UAAA,KAIAT,IACAK,OAAAiC,KAAAtC,GAAAuC,QAAA,SAAAC,GACAtC,EAAAuC,eAAAD,IAAAnC,OAAAqC,yBAAAxC,EAAAsC,GAAA/B,WACAP,EAAAsC,GAAAxC,EAAAwC,MAIA,SAAAxC,EAAA2C,aAAAxD,KAAA+B,gBACA/B,KAAAsC,UAAAtC,KAAAuC,WAAAvC,KAAAwC,iBAAA,IAKAtB,OAAAuC,eAAAzD,KAAA,WACAqB,MAAA,WACA,oBAAAN,EAAAa,MACA,SAAAX,OAAA,iGAMAC,OAAAuC,eAAAzD,KAAA,cACAqB,MAAA,SAAAqC,EAAAjB,GAOA,MANAvB,QAAAiC,KAAAV,GAAAW,QAAA,SAAAO,GACAD,EAAAC,KACAD,EAAAC,GAAAlB,EAAAkB,MAIAD,KAQAxC,OAAAuC,eAAAzD,KAAA,oBACAqB,MAAA,SAAAuC,EAAAC,GACA,IAAAA,GAAA,kBAAAA,GACA,SAAA5C,OAAA2C,EAAA,yDAQA1C,OAAAuC,eAAAzD,KAAA,YACAqB,MAAA,GAAAyC,GAAA9D,MACAgC,YAAA,IAGAd,OAAAuC,eAAAzD,KAAA,iBACAqB,MAAA,GAAA0C,GAAA/D,MACAgC,YAAA,IAGAd,OAAAC,iBAAAnB,MACAgE,cACA3C,MAAAR,GAAA,gBAAAA,GAAAmD,aAAAnD,EAAAmD,aAAA,IACAC,WAAA,KAIA/C,OAAAuC,eAAAzD,KAAA,mBACAqB,OACA6C,WAAkBC,QAAAnE,KAAAgE,cAClBI,OAAcD,QAAAnE,KAAAgE,cACdK,cAAqBF,QAAAnE,KAAAgE,cACrBM,aAAoBH,QAAAnE,KAAAgE,cACpBO,cAAqBJ,QAAAnE,KAAAgE,cACrBQ,cAAqBL,QAAAnE,KAAAgE,eAErBC,WAAA,IAGApD,KAAA4D,SAAA,SAAA5D,EAAA4D,QAGAzE,KAAA4B,MAAA,QAFA5B,KAAAyE,UAKAzE,KAAAoB,kBAAAsD,YAAA,WAAoDC,EAAA5D,EAAAY,iBAAqC,KAEzF3B,KAAA4E,SACA5E,KAAA4E,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,IAAA,mDACA,+DACA,+DACA,iDAGA,OAAAD,IAAAC,EAAAC,QAAAL,MAAA,KAVA,OAggBA,QAAAM,KACA,GACAvE,GAAAf,KACAuF,EAAAC,KAAAD,MACAE,GAAA,CAEA1E,GAAA+B,SAAA,IACA/B,EAAA4B,aAAAS,QAAA,SAAAM,EAAAgC,GACAhC,EAAAiC,GAAAJ,EAAAxE,EAAA+B,WACA2C,EAAAC,KAIAD,KAAA,GACA1E,EAAA4B,aACAiD,OAAA,EAAAH,EAAA,GACArC,QAAA,SAAAyC,GACA9E,EAAA+E,UAAA,kBAAAD,EAAAnC,UAKA3C,EAAA8B,aAAA,GAAA9B,EAAA4B,aAAAoD,OAAAhF,EAAA8B,cACA9B,EAAA4B,aACAiD,OAAA,EAAA7E,EAAA4B,aAAAoD,OAAAhF,EAAA8B,cACAO,QAAA,SAAAyC,GACA9E,EAAA+E,UAAA,kBAAAD,EAAAnC,SASA,QAAAiB,GAAAhD,GACA,GACA4D,GAAAC,KAAAD,KAEArE,QAAAiC,KAAAxB,GAAAyB,QAAA,SAAA4C,GACArE,EAAAqE,GAAAT,EAAA,WACA5D,GAAAqE,KAWA,QAAAC,GAAAC,EAAApF,GACA,GACAC,GAAAf,MAEAkC,SAAAnB,EAAAiC,UAAAlC,IACAC,EAAAoF,QAAAC,KAAAF,EAAAG,UAAA,SAAAC,GACA,GAAAlC,GAAA,IAEA,YAAA8B,EAAAK,QAAAD,EAAAlC,OAAA,kBAAAkC,EAAAlC,MAAAoC,UACAzF,EAAAiC,SAAAd,OACAnB,EAAA+E,UAAA,eAAAI,EAAApF,IAGAwF,EAAAlC,QACAA,EAAA,GAAAnD,OAAAqF,EAAAlC,MAAAoC,SACAtF,OAAAuF,OAAArC,EAAAkC,EAAAlC,OACAA,EAAAsC,OAAAJ,EAAAI,OACA3F,EAAA+E,UAAA,aAAA1B,EAAA8B,EAAApF,IAGAA,GACAA,EAAAsD,EAAAkC,KAKAtG,KAAAmG,QAAAQ,KAAAT,GAGAnF,EAAAY,eAAAuE,EAAAG,WAAAb,KAAAD,MAMA,QAAAqB,KACA,GAEAC,GADA9F,EAAAf,KAEA8G,KACAC,EAAA,WACAhG,EAAA4B,aAAAoD,OAAA,GACAE,EAAA1F,KAAAQ,IAAA4B,aAAA,GAAAe,MAAA3C,EAAA4B,aAAA,GAAA7B,IACAC,EAAA+E,UAAA,kBAAA/E,EAAA4B,aAAAqE,SAEAC,WAAA,WACAF,KACSG,KAAAC,IAAA,EAAApG,EAAAgC,kBAEThC,EAAAW,SAAA,EAIA,IAAAX,EAAAkC,mBAAA,CACA,qBAAAlC,GAAAkC,mBACA,SAAAhC,OAAA,iFAAAF,GAAAkC,mBAIA,IADA4D,EAAA9F,EAAAkC,sBACAmE,MAAAC,QAAAR,GAYA,SAAA5F,OAAA,0FAAA4F,GAXA9F,GAAA4B,aAAAkE,EACAS,OAAAvG,EAAA4B,cACAoC,OAAA,SAAAmB,GAEA,IAAAA,EAAAxC,OAAAxB,SAAAgE,EAAAxC,MAAA2C,YAAAH,EAAAxC,MAAA6C,SAAAL,EAAAxC,MAAA6D,WACA,SAAAtG,OAAA,gGAGA,QAAA6F,EAAAxD,eAAA4C,EAAAxC,MAAA2C,aAAAS,EAAAZ,EAAAxC,MAAA2C,YAAA,KAOAU,IAOA,QAAAS,KACA,GAAAzG,GAAAf,IAEAkB,QAAAiC,KAAApC,EAAAc,eAAAuB,QAAA,SAAAqE,GACAvG,OAAAiC,KAAApC,EAAAc,cAAA4F,IAAArE,QAAA,SAAAsE,GACA,GAAAC,GAAA5G,EAAAc,cAAA4F,GAAAC,EACAC,GAAAC,MAAAD,EAAA9D,cAQA,QAAAgE,KACA,GAAA9G,GAAAf,IAEAkB,QAAAiC,KAAApC,EAAAc,eAAAuB,QAAA,SAAAqE,GACAvG,OAAAiC,KAAApC,EAAAc,cAAA4F,IAAArE,QAAA,SAAAsE,GACA,GAAAC,GAAA5G,EAAAc,cAAA4F,GAAAC,EACAC,GAAAG,kBAskBA,QAAAC,GAAAC,EAAAlH,GACAA,GACAA,EAAA,GAAAG,OAAA,oFAAAgH,KAAAC,UAAAF,KAIA,QAAAG,KACA,GAAApH,GAAAf,IAEAkB,QAAAiC,KAAApC,EAAAc,eAAAuB,QAAA,SAAAqE,GACAvG,OAAAiC,KAAApC,EAAAc,cAAA4F,IAAArE,QAAA,SAAAsE,GACA,GAAAC,GAAA5G,EAAAc,cAAA4F,GAAAC,EACAC,GAAAS,aAAA,MArhDA,GACAC,GAAAnI,EAAA,GACAc,EAAAd,EAAA,GACAoI,EAAApI,EAAA,GACA4D,EAAA5D,EAAA,IACA6D,EAAA7D,EAAA,GACAqI,EAAArI,EAAA,GACAsI,EAAAtI,EAAA,GAiTAS,GAAA8H,UAAAvH,OAAAwH,OAAA1H,EAAAyH,WACA9H,EAAA8H,UAAAE,YAAAhI,EAMAA,EAAA8H,UAAAG,KAAA,SAAAC,GACA,GACAtD,GAAAC,KAAAD,MACAuD,EAAA9I,KAAA+I,gBAAAF,EAEA,IAAAC,EAAA,CACA,GAAAA,EAAAE,aAAAF,EAAAE,YAAAzD,EAAAuD,EAAA3E,QACA,QAEA2E,GAAAE,YAAAzD,EAEAvE,EAAAyH,UAAAG,KAAAK,MAAAjJ,KAAAkJ,YAEAvI,EAAA8H,UAAA3C,UAAAnF,EAAA8H,UAAAG,KAMAjI,EAAA8H,UAAAhE,QAAA,WACA,GAAA1D,GAAAf,IAQA,OANAe,GAAAoF,SACApF,EAAAoI,aAGApI,EAAAoF,QAAAqC,EAAAzH,EAAAH,KAAAG,EAAAqB,KAAArB,EAAAsB,gBAEA,yDAAAgD,QAAArF,KAAA4B,UAAA,GACAb,EAAAS,WACAT,EAAAS,UAAA,KAAAT,GAEAA,IAGAA,EAAAa,MAAA,aACAb,EAAAoF,QAAA1B,QAAA1D,EAAAgB,cAAAhB,EAAAoB,mBAEApB,EAAAoF,QAAAiD,UAAA,WACArI,EAAAa,MAAA,YACA4F,EAAAjH,KAAAQ,GACA6F,EAAArG,KAAAQ,GACAA,EAAA+E,UAAA,aAEA/E,EAAAS,WACAT,EAAAS,UAAA,KAAAT,KAIAA,EAAAoF,QAAAkD,GAAA,qBAAAC,GACAvI,EAAA+E,UAAA,YAAAwD,KAGAvI,EAAAoF,QAAAoD,eAAA,SAAAnF,GACA,GAAAoF,GAAA,GAAAvI,OAAA,gDAAAF,EAAAH,KAAA,IAAAG,EAAAqB,KAAA,IAEAoH,GAAAC,SAAArF,EACArD,EAAAa,MAAA,QACAb,EAAA+E,UAAA,eAAA0D,GAEArB,EAAA5H,KAAAQ,GAEAA,EAAAS,WACAT,EAAAS,UAAAgI,KAIAzI,EAAAoF,QAAAuD,aAAA,WACA3I,EAAAa,MAAA,UAEAb,EAAAgB,eACAhB,EAAAoI,aAGApI,EAAAuB,YACAvB,EAAAW,SAAA,GAGAX,EAAA+E,UAAA,kBAGA/E,EAAAoF,QAAAwD,YAAA,WACA,GAAAC,GAAA,WAEA7I,EAAAyB,iBACAgF,EAAAjH,KAAAQ,GAIAA,EAAAwB,aACA+C,EAAA/E,KAAAQ,GACA6F,EAAArG,KAAAQ,IAIAA,EAAA+E,UAAA,eAGA/E,GAAAa,MAAA,YAEAb,EAAAiC,SACAjC,EAAA8I,WAAA9I,EAAAiC,SAAA,SAAA8G,EAAAC,IAEAD,GAAAC,EAAAC,QACAjJ,EAAAiC,SAAAd,OACAnB,EAAA+E,UAAA,iBAGA8D,MAGAA,MAIA5J,OAQAW,EAAA8H,UAAAwB,YAAA,SAAAC,GACA,mBAAAA,GACAlK,KAAAgD,SAAAkH,MACG,oBAAAA,GAaH,MADAlK,MAAA8F,UAAA,gBAAoCqE,SAAA,EAAA/F,MAAA,2BAAA8F,IACpClK,IAZA,KAAAkK,EAAAE,SAAAF,EAAAE,OAAAC,KAAA,gBAAAH,GAAAE,OAAAC,IAQA,MALArK,MAAA8F,UAAA,gBACAqE,SAAA,EACA/F,MAAA,0DAAA6D,KAAAC,UAAAgC,KAGAlK,IAPAA,MAAAgD,SAAAkH,EAAAE,OAAAC,IAgBA,MAFA7C,GAAAjH,KAAAP,MACAA,KAAA8F,UAAA,gBAAkCqE,SAAA,IAClCnK,MAOAW,EAAA8H,UAAA6B,cAAA,WAKA,MAJAtK,MAAAgD,SAAAd,OAEA2F,EAAAtH,KAAAP,MAEAA,MAOAW,EAAA8H,UAAA8B,YAAA,WACA,MAAAvK,MAAAgD,UAYArC,EAAA8H,UAAA+B,MAAA,SAAAC,GACA,GACA1J,GAAAf,KACAkG,GACAwE,QACAD,YAEA3J,EAAA,IAEA,KAAA2J,GAAA,gBAAAA,GACA,SAAAxJ,OAAA,kCAIAiI,WAAA,KACA,gBAAAA,WAAA,GACAhD,EAAAwE,KAAAxB,UAAA,GACK,gBAAAA,WAAA,oBAAAA,WAAA,GACLhD,EAAAyE,UAAAzB,UAAA,GACK,kBAAAA,WAAA,KACLpI,EAAAoI,UAAA,KAGAA,UAAA,KACA,gBAAAA,WAAA,oBAAAA,WAAA,GACAhD,EAAAyE,UAAAzB,UAAA,GACK,kBAAAA,WAAA,KACLpI,EAAAoI,UAAA,KAGAA,UAAA,sBAAAA,WAAA,KACApI,EAAAoI,UAAA,IAGAlJ,KAAA0D,OAAc6D,WAAA,OAAAhB,OAAA,SAAoCL,GAAY0E,UAAA,GAAgB,SAAAxG,EAAAkC,GAC9ElC,GAQAtD,KAAAsD,GACArD,EAAA+E,UAAA,gBAAsCqE,SAAA,EAAA/F,QAAAoC,YARtCF,EAAA8D,OAAAC,KACAtJ,EAAAkJ,YAAA3D,EAAA8D,OAAAC,KAGAvJ,KAAA,KAAAwF,EAAA8D,YAkBAzJ,EAAA8H,UAAAoC,oBAAA,SAAAJ,EAAAK,EAAAjK,EAAAC,GAcA,MAbAA,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA0D,OAAc6D,WAAA,OAAAhB,OAAA,wBAAqDkE,WAAAC,KAAAI,GAAsCjK,EAAA,SAAAiJ,EAAAC,GACzGD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,OAAAW,WAMA/K,MAWAW,EAAA8H,UAAAuC,oBAAA,SAAAP,EAAA5J,EAAAC,GAcA,MAbAA,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA0D,OAAc6D,WAAA,OAAAhB,OAAA,wBAAqDkE,YAAmB5J,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GACtFD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,UAMApK,MAUAW,EAAA8H,UAAAwC,iBAAA,SAAAR,EAAA5J,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA0D,OAAc6D,WAAA,OAAAhB,OAAA,qBAAkDkE,YAAmB5J,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GACnFD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,WAgBAzJ,EAAA8H,UAAAyC,oBAAA,SAAAT,EAAAK,EAAAjK,EAAAC,GAcA,MAbAA,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA0D,OAAc6D,WAAA,OAAAhB,OAAA,wBAAqDkE,WAAAC,KAAAI,GAAsCjK,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GACzGD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,UAMApK,MAWAW,EAAA8H,UAAA0C,sBAAA,SAAAV,EAAAK,EAAAjK,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA0D,OAAc6D,WAAA,OAAAhB,OAAA,0BAAuDkE,WAAAC,KAAAI,GAAsCjK,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GAC3GD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,WAeAzJ,EAAA8H,UAAA2C,YAAA,SAAA1F,EAAA7E,EAAAC,GACA,IAAA4E,EAAA,CACA,IAAA1F,KAAAiC,aACA,SAAAhB,OAAA,qCAEAyE,GAAA1F,KAAAiC,aAYA,MATAnB,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA0D,OAAc6D,WAAA,QAAAhB,OAAA,SAAAb,YAAwD7E,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GACtEjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGApK,MASAW,EAAA8H,UAAA4C,OAAA,SAAAvK,GACA,GACAC,GAAAf,KACAkG,GACAK,OAAA,SACAgB,WAAA,OACAlB,UAAAgC,IACAqC,QASA,OANA1K,MAAA0D,OAAc6D,WAAA,OAAAhB,OAAA,UAAqCL,GAAY0E,UAAA,GAAgB,kBAAA9J,GAAA,cAAAsD,GAC/EtD,EAAAsD,EAAArD,KAGAA,EAAAuJ,gBAEAvJ,GAUAJ,EAAA8H,UAAAoB,WAAA,SAAAK,EAAApJ,GACA,GACAoF,IACAwE,MACAR,SAIAlK,MAAAsL,iBAAA,oBAAAxK,GAEAd,KAAA0D,OAAc6D,WAAA,OAAAhB,OAAA,cAAyCL,GAAY0E,UAAA,GAAgB,SAAAd,EAAAC,GACnFjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,WAUAzJ,EAAA8H,UAAA8C,OAAA,SAAAzK,GACA,GAAAC,GAAAf,IAEAe,GAAAuK,iBAAA,gBAAAxK,GAEAC,EAAA2C,OAAc6D,WAAA,OAAAhB,OAAA,wBAAqD,SAAAuD,EAAAC,GACnEjJ,EAAAgJ,IAAA5H,OAAA,GAAAqG,GAAAxH,EAAAyK,SAAAzB,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,WAUA/K,EAAA8H,UAAAkD,YAAA,SAAA9K,EAAAC,GACA,GAAAC,GAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAAuK,iBAAA,qBAAAxK,GAEAC,EAAA2C,OAAc6D,WAAA,OAAAhB,OAAA,kBAA6C1F,EAAA,SAAAiJ,EAAAC,GAC3DjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAwB,SAYAjL,EAAA8H,UAAAoD,WAAA,SAAAC,EAAAjL,EAAAC,GACA,GACAC,GAAAf,KACAsJ,KACAyC,GAAiBxE,WAAA,OAAAhB,OAAA,aAajB,OAXAzF,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAoB,KAAAoB,EAEA/K,EAAA2C,MAAAqI,EAAAzC,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGApK,MA4KAW,EAAA8H,UAAAuD,YAAA,SAAAC,EAAAC,GAGA,GAFAlM,KAAAmM,UAEAnM,KAAAyB,aAAA4D,QAAA4G,MAAA,EACA,SAAAhL,OAAA,IAAAgL,EAAA,yCAAAjM,KAAAyB,aAAA2K,WAGA,OAAApL,GAAAyH,UAAAuD,YAAAzL,KAAAP,KAAAiM,EAAAC,IAUAvL,EAAA8H,UAAA4D,iBAAA,SAAAxL,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAAsL,iBAAA,0BAAAxK,GAEAd,KAAA0D,OAAc6D,WAAA,SAAAhB,OAAA,kBAA+C1F,EAAA,SAAAiJ,EAAAC,GAC7DjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAwB,SAYAjL,EAAA8H,UAAA6D,cAAA,SAAAC,EAAA1L,EAAAC,GACA,GACA0L,GACA9B,CAEA5J,KACA,IAAAoI,UAAAnD,QACAjF,EAAAoI,UAAA,GACArI,EAAA,KACA0L,EAAA,OAEAzL,EAAAoI,UAAA,GACA,gBAAAA,WAAA,IACArI,EAAAqI,UAAA,GACAqD,EAAA,OAEAA,EAAArD,UAAA,GACArI,EAAA,QAKA2L,EAAA,SAAA1C,EAAAC,GACA,MAAAD,GACAhJ,EAAAgJ,OAGAhJ,GAAA,KAAAyL,EAAAxC,EAAAK,OAAAwB,MAAA7B,EAAAK,UAGApK,KAAAsL,iBAAA,uBAAAxK,GAEA4J,EAAA6B,GAAsB7B,MAAO+B,UAAAF,OAC7BvM,KAAA0D,OAAc6D,WAAA,SAAAhB,OAAAgG,EAAA,2BAAsE7B,EAAA7J,EAAA2L,IAWpF7L,EAAA8H,UAAAiE,WAAA,SAAAA,EAAAhH,GAGA,GAFA1F,KAAAmM,WAEAzG,EAAA,CACA,IAAA1F,KAAAiC,aACA,SAAAhB,OAAA,oEAGAyE,GAAA1F,KAAAiC,aAGA,mBAAAyD,IAAA,gBAAAgH,GACA,SAAAzL,OAAA,wDAWA,OARAjB,MAAAuB,YAAAmE,KACA1F,KAAAuB,YAAAmE,OAGA1F,KAAAuB,YAAAmE,GAAAgH,KACA1M,KAAAuB,YAAAmE,GAAAgH,GAAA,GAAApE,GAAAtI,KAAA0M,EAAAhH,IAGA1F,KAAAuB,YAAAmE,GAAAgH,IAQA/L,EAAA8H,UAAAkE,WAAA,WAEA,MADA3M,MAAA2C,gBACA3C,MAUAW,EAAA8H,UAAAmE,gBAAA,WACA,GACAlH,GACA7E,EACAC,EAEA4C,EADAmJ,EAAAzF,MAAAqB,UAAAqE,MAAAvM,KAAA2I,UAiBA,IAdA2D,EAAAzJ,QAAA,SAAA2J,GACA,aAAAA,IACA,aACArH,EAAAqH,CACA,MACA,cACAlM,EAAAkM,CACA,MACA,gBACAjM,EAAAiM,MAKArH,EAAA,CACA,IAAA1F,KAAAiC,aACA,SAAAhB,OAAA,yCAGAyE,GAAA1F,KAAAiC,aAGAjC,KAAAsL,iBAAA,yBAAAxK,GAEA4C,GAAWsJ,KAAAnM,KAAAmM,MAAA,OAEXhN,KAAA0D,OAAcgC,QAAA6B,WAAA,aAAAhB,OAAA,QAAuD7C,EAAA7C,EAAA,SAAAiJ,EAAAC,GACrEjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAA7I,gBAUAZ,EAAA8H,UAAAwE,YAAA,SAAApM,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAAsL,iBAAA,qBAAAxK,GAEAd,KAAA0D,OAAc6D,WAAA,QAAAhB,OAAA,WAAwC1F,EAAA,SAAAiJ,EAAAC,GACtDjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAA8C,YAOAvM,EAAA8H,UAAAU,WAAA,WACA,GAAAuD,EAEAS,eAAAnN,KAAAoB,mBACApB,KAAA4B,MAAA,eACA5B,KAAAmG,QAAAiH,QACApN,KAAAmG,QAAA,IAEA,KAAAuG,IAAA1M,MAAAuB,YACAvB,KAAAuB,YAAA+B,eAAAoJ,UACA1M,MAAAuB,YAAAmL,IAWA/L,EAAA8H,UAAA4E,cAAA,SAAAxM,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAAsL,iBAAA,uBAAAxK,GAEAd,KAAA0D,OAAc6D,WAAA,SAAAhB,OAAA,WAAyC1F,EAAA,SAAAiJ,EAAAC,GACvDjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAkD,eAYA3M,EAAA8H,UAAA8E,aAAA,WACA,GACA7H,GACA7E,EACAC,CAgBA,IAdAsG,MAAAqB,UAAAqE,MAAAvM,KAAA2I,WAAA9F,QAAA,SAAA2J,GACA,aAAAA,IACA,aACArH,EAAAqH,CACA,MACA,cACAlM,EAAAkM,CACA,MACA,gBACAjM,EAAAiM,MAKArH,EAAA,CACA,IAAA1F,KAAAiC,aACA,SAAAhB,OAAA,sCAEAyE,GAAA1F,KAAAiC,aAKA,MAFAjC,MAAA0D,OAAcgC,QAAA6B,WAAA,QAAAhB,OAAA,cAA0D1F,EAAAC,GAExEd,MAUAW,EAAA8H,UAAA+E,eAAA,WACA,GACA9H,GACA7E,EACAC,CAgBA,IAdAsG,MAAAqB,UAAAqE,MAAAvM,KAAA2I,WAAA9F,QAAA,SAAA2J,GACA,aAAAA,IACA,aACArH,EAAAqH,CACA,MACA,cACAlM,EAAAkM,CACA,MACA,gBACAjM,EAAAiM,MAKArH,EAAA,CACA,IAAA1F,KAAAiC,aACA,SAAAhB,OAAA,wCAEAyE,GAAA1F,KAAAiC,aAGAjC,KAAAsL,iBAAA,wBAAAxK,GACAd,KAAA0D,OAAcgC,QAAA6B,WAAA,QAAAhB,OAAA,qBAAiE1F,EAAAC,IAY/EH,EAAA8H,UAAAgF,eAAA,WACA,GACA/H,GACAgI,EACA7M,EACAC,CAmBA,IAjBAsG,MAAAqB,UAAAqE,MAAAvM,KAAA2I,WAAA9F,QAAA,SAAA2J,GACA,aAAAA,IACA,aACArH,EAAAqH,CACA,MACA,eACAW,EAAAX,CACA,MACA,cACAlM,EAAAkM,CACA,MACA,gBACAjM,EAAAiM,MAKArH,EAAA,CACA,IAAA1F,KAAAiC,aACA,SAAAhB,OAAA,wCAEAyE,GAAA1F,KAAAiC,aAGA,GAAAC,SAAAwL,EACA,SAAAzM,OAAA,uDAKA,OAFAjB,MAAA0D,OAAcgC,QAAA6B,WAAA,QAAAhB,OAAA,mBAAgEmE,MAAQgD,gBAA4B7M,EAAAC,GAElHd,MAQAW,EAAA8H,UAAAlD,IAAA,SAAA1E,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAAsL,iBAAA,aAAAxK,GAEAd,KAAA0D,OAAc6D,WAAA,SAAAhB,OAAA,UAAwC1F,EAAA,SAAAiJ,EAAAC,GACtDjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAA7E,QAiBA5E,EAAA8H,UAAA/E,MAAA,SAAAqI,EAAArI,EAAA7C,EAAAC,GACA,GACA6M,GACA3F,GACAzB,OAAAwF,EAAAxF,OACAgB,WAAAwE,EAAAxE,WACA7E,SAAA1C,KAAA0C,UAEA3B,EAAAf,IASA,IAPAA,KAAAmM,UAEArL,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAA,EAAA,CACA,GAAAA,EAAA+J,YAAA,eAAA7J,EAAAa,MACA,MAAAb,EAGAF,GAAA+M,UACA5F,EAAA4F,QAAA/M,EAAA+M,SAGA,mBAAA/M,GAAAgN,MAAA,OAAAhN,EAAAgN,OACA7F,EAAA6F,KAAAhN,EAAAgN,MAGAhN,EAAAiN,OACA9F,EAAA8F,KAAAjN,EAAAiN,MAGAjN,EAAAkN,SACA/F,EAAA+F,OAAAlN,EAAAkN,QAGAlN,EAAAmN,WACAhG,EAAAgG,SAAAnN,EAAAmN,UAGAnN,EAAA6B,UACAxB,OAAAiC,KAAAtC,EAAA6B,UAAAU,QAAA,SAAA6K,GACAjG,EAAAtF,SAAAuL,GAAApN,EAAA6B,SAAAuL,KAKA,IAAAvK,GAAA,gBAAAA,IAAA0D,MAAAC,QAAA3D,GACA,SAAAzC,OAAA,4BAAAyC,EAGAA,GAAAhB,UACAxB,OAAAiC,KAAAO,EAAAhB,UAAAU,QAAA,SAAA6K,GACAjG,EAAAtF,SAAAuL,GAAAvK,EAAAhB,SAAAuL,IAIA,KAAAN,IAAAjK,GACA,aAAAiK,GAAAjK,EAAAJ,eAAAqK,KACA3F,EAAA2F,GAAAjK,EAAAiK,GA+CA,OA3CA3F,GAAAjH,EAAAmN,WAAAlG,EAAAhI,KAAAyC,SAMAP,SAAAnB,EAAAiC,UAAA,SAAAgF,EAAAT,YAAA,eAAAS,EAAAzB,SACAyB,EAAAqC,IAAAtJ,EAAAiC,UAGA+I,EAAAW,aACA1E,EAAA0E,WAAAX,EAAAW,YAGAX,EAAArG,QACAsC,EAAAtC,MAAAqG,EAAArG,OAGAsC,EAAA3B,YACA2B,EAAA3B,UAAAgC,KAGAL,EAAAtF,SAAAQ,WAAAlD,KAAAkD,WAEA,cAAAnC,EAAAa,OAAAf,KAAA+J,YAAA,EACA,cAAA7J,EAAAa,MACAqE,EAAA1F,KAAAP,KAAAgI,EAAAlH,GAEAiH,EAAAC,EAAAlH,GAEGC,EAAAW,SAAAb,KAAA+J,YAAA,iCAAAvF,QAAAtE,EAAAa,UAAA,GACH0D,EAAA/E,KAAAP,KAAAgI,EAAAlH,IACAC,EAAA6B,aAAA7B,EAAA6B,YAAAoF,IACAjH,EAAA4B,aAAAwL,MAA8BxI,GAAAH,KAAAD,MAAA7B,MAAAsE,EAAAlH,OAC9BC,EAAA+E,UAAA,oBAA0CpC,MAAAsE,EAAAlH,QAE1CiH,EAAAC,EAAAlH,IAIAiH,EAAAC,EAAAlH,GAGAC,GAOAJ,EAAA8H,UAAA2F,YAAA,WAMA,MALA,YAAApO,KAAA4B,OAAA5B,KAAAuC,aACA+C,EAAA/E,KAAAP,MACA4G,EAAArG,KAAAP,OAGAA,MASAW,EAAA8H,UAAA4F,gBAAA,SAAA3I,GACA,mBAAAA,GACA,SAAAzE,OAAA,2BAAAyE,EAAA,gCAGA,QAAAA,EAAAK,OACA,SAAA9E,OAAA,iDAKA,OAFAjB,MAAAiC,aAAAyD,EAEA1F,MAYAW,EAAA8H,UAAA6F,WAAA,SAAAxC,EAAAyC,GACA,GAAAxN,GAAAf,IAEA,oBAAA8L,IAAA1E,MAAAC,QAAAyE,GACA,SAAA7K,OAAA,+CAAA6K,GAWA,OARAyC,GACAxN,EAAA0B,QAAAqJ,EAEA5K,OAAAiC,KAAA2I,GAAA1I,QAAA,SAAA4C,GACAjF,EAAA0B,QAAAuD,GAAA8F,EAAA9F,KAIAjF,GAMAJ,EAAA8H,UAAA+F,aAAA,WAIA,MAHA,YAAAxO,KAAA4B,OAAA5B,KAAAsC,YACAtC,KAAA0B,SAAA,GAEA1B,MAMAW,EAAA8H,UAAAgG,YAAA,WAKA,MAJA,YAAAzO,KAAA4B,OAAA5B,KAAAsC,YACAtC,KAAA0B,SAAA,GAGA1B,MAoBAH,EAAAD,QAAAe,GF8DM,SAAUd,EAAQD,GGxlDxB,QAAA8O,GAAA5K,EAAAzD,EAAAyL,EAAAmC,GAEA,IAAA5N,EACA,SAAAY,OAAA,sCAmCA,IA/BAC,OAAAC,iBAAAnB,MAEA2O,QACAtN,MAAAyC,EAAA6K,QAEA7K,UACAzC,MAAAyC,GAIAzD,IACAgB,MAAAhB,EACA2B,YAAA,GAEA8J,SACAzK,SACAC,UAAA,EACAU,YAAA,GAEAiM,MACA5M,MAAA4M,MACA3M,UAAA,EACAU,YAAA,KAIA8J,GACA9L,KAAA4O,WAAA9C,GAAA,GAIAhI,EAAA6K,OAAA/J,SACA,MAAAd,GAAA6K,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,IAAA,kBAEA,OAAAD,IAAAC,EAAAC,QAAAL,MAAA,KAaA0J,EAAAjG,UAAAmG,WAAA,SAAAtF,GAEA,MADAtJ,MAAA8L,QAAAxC,EACAtJ,MAQA0O,EAAAjG,UAAAoG,UAAA,WACA,GACAvF,KASA,OAPAtJ,MAAAK,KACAiJ,EAAAmC,IAAAzL,KAAAK,IAGAiJ,EAAAoB,KAAA1K,KAAA8L,QACAxC,EAAA2E,KAAAjO,KAAAiO,KAEA3E,GASAoF,EAAAjG,UAAAqG,OAAA,SAAAjO,EAAAC,GACA,GACAC,GAAAf,IAEAa,IAAAqB,SAAApB,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA1D,KAAA8D,SAAAiL,eAAA/O,KAAAgP,mBAA0EvD,IAAAzL,KAAAK,IAAaQ,EAAA,SAAAuD,EAAA2F,GACvF,MAAA3F,KACAtD,KAAAsD,QAGAtD,GACAA,EAAA,KAAAiJ,EAAAK,OAAAqB,SAaAiD,EAAAjG,UAAAwG,OAAA,SAAAnD,EAAAjL,EAAAC,GACA,GACAwI,MACAvI,EAAAf,IAEA,oBAAA8L,GACA,SAAA7K,OAAA,uCAuBA,OApBAJ,IAAAqB,SAAApB,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAmC,IAAA1K,EAAAV,GACAiJ,EAAAoB,KAAAoB,EAEA/K,EAAA4N,OAAAjL,MAAA1D,KAAA8D,SAAAiL,eAAA/O,KAAAkP,kBAAA5F,EAAAzI,EAAA,SAAAuD,EAAAkC,GACA,MAAAlC,KACAtD,KAAAsD,IAGArD,EAAA6N,WAAAtI,EAAA8D,OAAAW,cAEAjK,GACAA,EAAA,KAAAC,OAIAf,MAGAH,EAAAD,QAAA8O,GH+lDM,SAAU7O,EAAQD,GI3tDxB,QAAAuP,GAAAzC,EAAA0C,EAAAtD,EAAAmC,GAiEA,MAhEA/M,QAAAC,iBAAAnB,MAEA0M,YACArL,MAAAqL,aACA1K,YAAA,GAEAqN,gBACAhO,MAAAqL,EACA1K,YAAA,GAEA2M,QACAtN,MAAAqL,EAAAiC,OACA3M,YAAA,GAGA3B,IACAgB,MAAAa,OACAF,YAAA,EACAV,UAAA,GAEAwK,SACAzK,SACAC,UAAA,EACAU,YAAA,GAEAS,SACApB,MAAA4G,KAAAqH,MAAArH,KAAAC,UAAAwE,EAAAjK,UACAT,YAAA,EACAV,UAAA,GAEAiO,SACAlO,MAAAa,OACAF,YAAA,EACAV,UAAA,GAEA2M,MACA5M,MAAA4M,MACAjM,YAAA,EACAV,UAAA,MAKAwK,GAAAsD,GAAA,gBAAAA,KACAtD,EAAAsD,EACAA,EAAA,MAGAtD,IACAA,EAAA0D,WACAxP,KAAAuP,QAAAzD,EAAA0D,eACA1D,GAAA0D,UAEAxP,KAAA4O,WAAA9C,GAAA,IAGAsD,GACAlO,OAAAuC,eAAAzD,KAAA,MACAqB,MAAA+N,EACApN,YAAA,IAKAhC,KAAA2O,OAAA/J,SACA5E,KAAA2O,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,IAAA,0BAEA,OAAAD,IAAAC,EAAAC,QAAAL,MAAA,KAKAhF,KAQAmP,EAAA1G,UAAAoG,UAAA,WACA,GACAvF,KAcA,OAZAtJ,MAAAK,KACAiJ,EAAAmC,IAAAzL,KAAAK,IAGAL,KAAAuP,UACAjG,EAAAkG,SAAAxP,KAAAuP,SAGAjG,EAAAoB,KAAA1K,KAAA8L,QACAxC,EAAA2E,KAAAjO,KAAAiO,KACA3E,EAAAtJ,KAAA2O,OAAAT,WAAA5E,EAAAtJ,KAAAyC,UAUA0M,EAAA1G,UAAA2D,SAAA,WACA,MAAAnE,MAAAC,UAAAlI,KAAA6O,cAcAM,EAAA1G,UAAAqG,OAAA,SAAAjO,EAAAC,GACA,GAAAC,GAAAf,IAOA,IALAc,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,OAGAE,EAAAV,GACA,SAAAY,OAAA,kEAGAjB,MAAA2O,OAAAjL,MAAA1D,KAAAqP,eAAAN,eAAA,qBAAA/O,KAAA6O,YAAAhO,EAAAC,GAAA,SAAAgJ,GACAhJ,EAAAgJ,IAAA5H,OAAAnB,EAAAV,OAWA8O,EAAA1G,UAAAgH,OAAA,SAAA5O,EAAAC,GACA,GAAAC,GAAAf,IAOA,IALAc,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,OAGAE,EAAAV,GACA,SAAAY,OAAA,kFAGAjB,MAAA2O,OAAAjL,MAAA1D,KAAAqP,eAAAN,eAAA,qBAAA/O,KAAA6O,YAAAhO,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,WAWA+E,EAAA1G,UAAAmF,QAAA,SAAA/M,EAAAC,GACA,GAAAC,GAAAf,IAOA,IALAc,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,OAGAE,EAAAV,GACA,SAAAY,OAAA,0EAGAjB,MAAA2O,OAAArD,iBAAA,mBAAAxK,GAEAC,EAAA4N,OAAAjL,MAAA3C,EAAAsO,eAAAN,eAAA,mBAA4EtD,IAAA1K,EAAAV,IAAaQ,EAAA,SAAAuD,EAAA2F,GACzF,GAAA2F,EAEA,OAAAtL,GACAtD,EAAAsD,IAGAsL,EAAA,GAAAP,GAAApO,EAAAsO,eAAAtO,EAAAV,GAAA0J,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,OACAgE,EAAAH,QAAAxF,EAAAK,OAAAoF,aAEA1O,GAAA,KAAA4O,OAmBAP,EAAA1G,UAAAkH,KAAA,SAAA9O,EAAAC,GACA,GACAwI,GAAAtJ,KAAA6O,YACA9N,EAAAf,IAoBA,OAlBAa,IAAAqB,SAAApB,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA1D,KAAAqP,eAAAN,eAAA,8BAAAzF,EAAAzI,EAAA,SAAAuD,EAAA2F,GACA,MAAA3F,GACAtD,KAAAsD,IAGArD,EAAAV,GAAA0J,EAAAK,OAAAqB,IACA1K,EAAAwO,QAAAxF,EAAAK,OAAAoF,cAEA1O,GACAA,EAAA,KAAAC,OAIAA,GAaAoO,EAAA1G,UAAAmH,QAAA,SAAA/O,GACA,GAAAyI,GAAAtJ,KAAA6O,WAIA,OAFA7O,MAAA2O,OAAAjL,MAAA1D,KAAAqP,eAAAN,eAAA,sBAAAzF,EAAAzI,GAEAb,MAUAmP,EAAA1G,UAAAmG,WAAA,SAAAtF,EAAAiF,GACA,GAAAxN,GAAAf,IAWA,OATAuO,GACAvO,KAAA8L,QAAAxC,EAGApI,OAAAiC,KAAAmG,GAAAlG,QAAA,SAAA4C,GACAjF,EAAA+K,QAAA9F,GAAAsD,EAAAtD,KAIAhG,MAUAmP,EAAA1G,UAAAoH,UAAA,SAAAhP,EAAAC,GACA,GAAAgP,EASA,IAPAjP,IAAAC,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAArD,iBAAA,qBAAAxK,IAEAd,KAAAK,GACA,SAAAY,OAAA,gFAKA,OAFA6O,IAAaC,KAAOC,QAAAhQ,KAAAK,MAEpBL,KAAAqP,eAAAQ,UAAAC,EAAAjP,EAAAC,IAYAqO,EAAA1G,UAAA6F,WAAA,SAAAxC,EAAAyC,GAEA,MADAvO,MAAA2O,OAAAL,WAAA/N,KAAAP,KAAA8L,EAAAyC,GACAvO,MAIAH,EAAAD,QAAAuP,GJyvDM,SAAUtP,EAAQD,EAASM,GKjlEjC,QAAAc,KACA,mBAAAiP,UACAjQ,KAAAkQ,WACAlQ,KAAAmQ,gBAIA,mBAAAF,SACAjP,EAAAyH,UAAAvI,EAAA,IAAAuI,UACAzH,EAAAyH,UAAAE,YAAA3H,IAGAA,EAAAyH,UAAAY,GAAA,SAAAR,EAAAqD,GACA,GAEAkE,GADAC,QAAAnE,EAGA,IAAArD,GAAAqD,EAAA,CAIA,gBAAAmE,EACA,SAAApP,OAAA,qDAAAoP,EAYA,OATAD,GAAApQ,KAAAoQ,UAAAvH,GAEAuH,EAAA/K,QAAA6G,MAAA,GACAkE,EAAAjC,KAAAjC,GAIAlM,KAAA4I,KAAA,cAAAC,EAAAqD,GAEAlM,OAEAgB,EAAAyH,UAAAuD,YAAAhL,EAAAyH,UAAAY,GAEArI,EAAAyH,UAAA6H,gBAAA,SAAAzH,EAAAqD,GACA,GAAAkE,EAEA,IAAAvH,GAAAqD,EAaA,MATAkE,GAAApQ,KAAAoQ,UAAAvH,GAEAuH,EAAA/K,QAAA6G,MAAA,IACAlM,KAAAkQ,QAAArH,GAAA,GAAAzB,OAAA8E,GAAA5E,OAAA8I,IAIApQ,KAAA4I,KAAA,cAAAC,EAAAqD,GAEAlM,MAGAgB,EAAAyH,UAAArC,KAAA,SAAAyC,EAAAqD,GACA,GAAAqE,EAEA,IAAA1H,GAAAqD,EASA,MAJAlM,MAAAqJ,GAAAR,EAAAqD,GACAqE,EAAAvQ,KAAAmQ,YAAAtH,GAAA7I,KAAAmQ,YAAAtH,OACA0H,EAAArE,IAAA,EAEAlM,MAGAgB,EAAAyH,UAAA+H,oBAAA,SAAA3H,EAAAqD,GACA,GAAAqE,EAEA,IAAA1H,GAAAqD,EAOA,MAJAlM,MAAAsQ,gBAAAzH,EAAAqD,GACAqE,EAAAvQ,KAAAmQ,YAAAtH,GAAA7I,KAAAmQ,YAAAtH,OACA0H,EAAArE,IAAA,EAEAlM,MAGAgB,EAAAyH,UAAAgI,eAAA,SAAA5H,EAAAqD,GACA,GACAxG,GACA0K,EAAApQ,KAAAkQ,QAAArH,EAEA,IAAAuH,KAAArK,OAeA,MAXAL,GAAA0K,EAAA/K,QAAA6G,GACAxG,KAAA,GACA0K,EAAAxK,OAAAF,EAAA,GAEA,IAAA0K,EAAArK,cACA/F,MAAAkQ,QAAArH,GAIA7I,KAAA4I,KAAA,iBAAAC,EAAAqD,GAEAlM,MAGAgB,EAAAyH,UAAAiI,mBAAA,SAAA7H,GASA,MARAA,UACA7I,MAAAkQ,QAAArH,SACA7I,MAAAmQ,YAAAtH,KAEA7I,KAAAkQ,WACAlQ,KAAAmQ,gBAGAnQ,MAGAgB,EAAAyH,UAAAG,KAAA,SAAAC,GACA,GAEAuH,GACAvD,EACA0D,EACAI,EAJAC,EAAA,CAQA,IAFAR,EAAApQ,KAAAkQ,SAAAlQ,KAAAkQ,QAAArH,GAEAuH,KAAArK,OAAA,CAWA,IAPA8G,EAAAzF,MAAAqB,UAAAqE,MAAAvM,KAAA2I,UAAA,GAEAqH,EAAAvQ,KAAAmQ,aAAAnQ,KAAAmQ,YAAAtH,OAEA8H,EAAA,GAAAvJ,OAEA8E,SAAAkE,EAAAQ,GACA1E,UAEAyE,EAAAxC,KAAAjC,UAEAqE,EAAArE,WAEAlM,KAAAyQ,eAAA5H,EAAAqD,gBAEAqE,GAAArE,WAEA0E,IAEA1E,SAAAkE,EAAAQ,EAEA,KAAAC,OAAAF,GAEAzO,SAAAyO,EAAAE,OACAF,EAAAE,MAAA5H,MAAAjJ,KAAA6M,EAIA,OAAA7M,QAGAgB,EAAAyH,UAAAqI,WAAA,WACA,MAAA5P,QAAAiC,KAAAnD,KAAAkQ,UAGAlP,EAAAyH,UAAAsI,cAAA,SAAAlI,GACA,MAAA7I,MAAAkQ,QAAArH,IAAA7I,KAAAkQ,QAAArH,GAAA9C,QAAA,GAGA/E,EAAAyH,UAAA2H,UAAA,SAAAvH,GAIA,MAHA3G,UAAAlC,KAAAkQ,QAAArH,KACA7I,KAAAkQ,QAAArH,OAEA7I,KAAAkQ,QAAArH,KAKA7H,EAAAyH,UAAA3C,UAAA9E,EAAAyH,UAAAG,KACA5H,EAAAyH,UAAAuI,IAAAhQ,EAAAyH,UAAAgI,eAEA5Q,EAAAD,QAAAoB,GLwlEM,SAAUnB,EAAQD,EAASM,GM9wEjC,QAAA+Q,GAAArQ,EAAAwB,EAAA8O,GACA,GAAAnQ,GAAAf,IACAgB,GAAAT,KAAAP,MAEAA,KAAAmR,UAAA,mBAAAA,qBAAAjR,GAAA,cAAAkR,GAAA,GAAAnQ,OAAA,gCAAAmQ,GAAAC,KAAA,mBAAAD,MACApR,KAAAY,OACAZ,KAAAoC,OACApC,KAAAkR,MACAlR,KAAAsR,OAAA,KACAtR,KAAAuR,cAAA,EACAvR,KAAAwR,UAAA,EACAxR,KAAAyR,QAAA,KACAzR,KAAA0R,uBAAA,EAUA1R,KAAAyE,QAAA,SAAA1C,EAAAI,GACA,GACAwP,IAAA3R,KAAAkR,IAAA,kBAAAlR,KAAAY,KAAA,IAAAZ,KAAAoC,KACAvB,EAAA,mBAAAoP,QAAA/N,QAA6D0P,mBAAA,EAE7DD,KAAA3R,KAAAyR,UACA1Q,EAAAwQ,cAAA,EACAvR,KAAAyR,QAAAE,GAGA3R,KAAAsR,OAAA,GAAAtR,MAAAmR,UAAAQ,EAAA9Q,GAEAb,KAAAsR,OAAAO,OAAA,WACA9Q,EAAAwQ,aACAxQ,EAAA+E,UAAA,aAGA/E,EAAA+E,UAAA,WAEA/E,EAAAwQ,cAAA,EACAxQ,EAAA2Q,uBAAA,GAGA1R,KAAAsR,OAAAQ,QAAA,SAAAC,EAAAvL,GACA,GAAApC,GACAsC,EACAsL,EAAAxL,CAEA,iBAAAuL,GACArL,EAAAqL,GAGArL,EAAAqL,EAAAV,KAEAU,EAAAC,SACAA,EAAAD,EAAAC,SAIA,MAAAtL,EACA3F,EAAA+E,UAAA,eAGA1B,EAAA,GAAAnD,OAAA+Q,GACA5N,EAAAsC,SAEAuL,EAAAlR,EAAAgB,EAAAI,EAAAiC,KAIApE,KAAAsR,OAAAY,QAAA,SAAA9N,GACAA,YAAAnD,SACAmD,EAAA,GAAAnD,OAAAmD,IAGA6N,EAAAlR,EAAAgB,EAAAI,EAAAiC,IAGApE,KAAAsR,OAAAa,UAAA,SAAAC,GACA,GAAA9I,GAAArB,KAAAqH,MAAA8C,EAAA9I,MAAA8I,EAEA9I,GAAA+I,KACAtR,EAAA+E,UAAAwD,EAAA+I,KAAA/I,GAGAvI,EAAA+E,UAAA,YAAAwD,KAUAtJ,KAAAoJ,UAAA,SAAAvF,GACA7D,KAAAgM,YAAA,UAAAnI,IAOA7D,KAAAuJ,eAAA,SAAA1F,GACA7D,KAAAgM,YAAA,eAAAnI,IAOA7D,KAAA0J,aAAA,SAAA7F,GACA7D,KAAAgM,YAAA,aAAAnI,IAOA7D,KAAA2J,YAAA,SAAA9F,GACA7D,KAAAgM,YAAA,YAAAnI,IAQA7D,KAAA2G,KAAA,SAAAyL,GACApS,KAAAsR,QAAAtR,KAAAsR,OAAAgB,aAAAtS,KAAAsR,OAAAiB,MACAvS,KAAAsR,OAAA3K,KAAAsB,KAAAC,UAAAkK,KAOApS,KAAAoN,MAAA,WACApN,KAAA0Q,qBACA1Q,KAAAuR,cAAA,EACAvR,KAAAsR,OAAAlE,QACApN,KAAAsR,OAAA,KACAvQ,EAAA2Q,uBAAA,GAeA,QAAAO,GAAAO,EAAAzQ,EAAAI,EAAAiC,IACArC,GAAAyQ,EAAAhB,UAAAgB,EAAAd,wBACAc,EAAAhB,UAAA,EACAvK,WAAA,WACAuL,EAAAhB,UAAA,EACAgB,EAAA/N,QAAA1C,EAAAI,IACKA,IAGLqQ,EAAA1M,UAAA,eAAA1B,GA3KA,GACApD,GAAAd,EAAA,EAqJA+Q,GAAAxI,UAAAvH,OAAAwH,OAAA1H,EAAAyH,WACAwI,EAAAxI,UAAAE,YAAAsI,EAuBApR,EAAAD,QAAAqR,GNwxEM,SAAUpR,EAAQD,EAASM,GO77EjC,QAAAqI,GAAAzE,EAAAzD,EAAAyL,EAAAmC,GAoBA,GAnBAwE,EAAAlS,KAAAP,KAAA8D,EAAAzD,EAAAyL,EAAAmC,GAGA/M,OAAAC,iBAAAnB,MAEAgP,kBACA3N,MAAA,cAEA6N,kBACA7N,MAAA,cAEAyJ,aACAzJ,SACAC,UAAA,EACAU,YAAA,KAKA8B,EAAA6K,OAAA/J,SACA,MAAAd,GAAA6K,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,IAAA,2DAEA,OAAAD,IAAAC,EAAAC,QAAAL,MAAA,KAnCA,GACAyN,GAAAvS,EAAA,EAwCAqI,GAAAE,UAAAvH,OAAAwH,OAAA+J,EAAAhK,WACAE,aACAtH,MAAAkH,KAUAA,EAAAE,UAAAiK,YAAA,SAAAC,GACA,IAAAvL,MAAAC,QAAAsL,IAAA,gBAAAA,GAAA,GACA,SAAA1R,OAAA,qDAKA,OAFAjB,MAAA8L,QAAA6G,aAEA3S,MAMAuI,EAAAE,UAAAmK,eAAA,SAAA9H,GACA,mBAAAA,GACA,SAAA7J,OAAA,2CAKA,OAFAjB,MAAA8K,cAEA9K,MASAuI,EAAAE,UAAAoK,WAAA,SAAAC,GACA,mBAAAA,GACA,SAAA7R,OAAA,yCAWA,OARAjB,MAAA8L,QAAA6G,aACA3S,KAAA8L,QAAA6G,eAGA3S,KAAA8L,QAAA6G,WAAAtN,QAAAyN,MAAA,GACA9S,KAAA8L,QAAA6G,WAAAxE,KAAA2E,GAGA9S,MAUAuI,EAAAE,UAAAC,OAAA,SAAA7H,EAAAC,GACA,GACAwI,GAAAtJ,KAAA+S,oBACAhS,EAAAf,IAEA,KAAAA,KAAA8L,QAAA6G,WACA,SAAA1R,OAAA,wGAYA,OATAJ,IAAAqB,SAAApB,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,MAAA1D,KAAA8D,SAAAiL,eAAA,cAAAzF,EAAA,KAAAxI,GAAA,SAAAgJ,GACAhJ,EAAAgJ,IAAA5H,OAAAnB,KAGAf,MAWAuI,EAAAE,UAAA8F,QAAA,SAAA1N,EAAAC,GACA,GACAwI,GAAAtJ,KAAA6O,YACA9N,EAAAf,IAEA,KAAAA,KAAA8L,QAAA6G,WACA,SAAA1R,OAAA,wGAaA,OAVAJ,IAAAqB,SAAApB,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAIAb,KAAA2O,OAAAjL,MAAA1D,KAAA8D,SAAAiL,eAAA,eAAAzF,EAAA,KAAAxI,GAAA,SAAAgJ,GACAhJ,EAAAgJ,IAAA5H,OAAAnB,KAGAf,MAcAuI,EAAAE,UAAAuK,eAAA,SAAAnS,EAAAC,GACA,GACAwI,GAAAtJ,KAAA6O,YACA9N,EAAAf,IAWA,OATAa,IAAAqB,SAAApB,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA1D,KAAA8D,SAAAiL,eAAA,wBAAAzF,EAAAzI,EAAAC,GAAA,SAAAsD,GACAtD,EAAAsD,IAAAlC,OAAAnB,KAGAA,GAQAwH,EAAAE,UAAAoG,UAAA,WACA,OAAUpD,IAAAzL,KAAAK,GAAAqK,KAAA1K,KAAA8L,QAAAmC,KAAAjO,KAAAiO,OAQV1F,EAAAE,UAAAsK,kBAAA,WACA,OAAUtH,IAAAzL,KAAAK,GAAAqK,MAAqBoB,QAAA9L,KAAA8L,QAAAhB,YAAA9K,KAAA8K,YAAAmD,KAAAjO,KAAAiO,QAQ/B1F,EAAAE,UAAAwK,cAAA,WACA,MAAAjT,MAAA8L,QAAA6G,gBASApK,EAAAE,UAAAyK,YAAA,SAAArS,EAAAC,GACA,GACAC,GAAAf,KACAmT,KACAC,GAAA,CASA,OAPAvS,KAAAC,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA+C,SAAA6K,OAAArD,iBAAA,mBAAAxK,GAEAC,EAAA+K,QAAA6G,eAIA5R,GAAA+K,QAAA6G,WAAAvP,QAAA,SAAA0P,GACA/R,EAAA+C,SAAAuP,aAAAP,EAAAjS,EAAA,SAAAuD,EAAAkP,GACA,GAAAlP,EAAA,CACA,GAAAgP,EACA,MAIA,OADAA,IAAA,EACAtS,EAAAsD,GAGA+O,EAAAhF,KAAAmF,GAEAH,EAAApN,SAAAhF,EAAA+K,QAAA6G,WAAA5M,QACAjF,EAAA,KAAAqS,OAjBArS,EAAA,KAAAqS,IAuBAtT,EAAAD,QAAA2I,GP68EM,SAAU1I,EAAQD,EAASM,GQxsFjC,QAAAqT,GAAA1S,EAAA2S,EAAAC,GACA,GAAA7C,GAAA4C,GAAAC,GAAA,CAEA,sBACAD,EAAA,UAAA3S,EAAA,GAAAuG,OAAA,SACAvG,EAAA,MAEAA,OAEA,IAAA6S,GAAA7S,EAAA8S,SAAA9S,EAAA+S,SAOA,IAJAF,EAAA,MAAAA,EAAA,MACAA,EAAA,MAAAA,EAAA,OAGAF,EACA,OAAAK,GAAA,EAAoBA,EAAA,KAASA,EAC7BL,EAAA5C,EAAAiD,GAAAH,EAAAG,EAIA,OAAAL,IAAAM,EAAAJ,GAzBA,GAAAE,GAAA1T,EAAA,IACA4T,EAAA5T,EAAA,GA2BAL,GAAAD,QAAA2T,GRktFM,SAAU1T,EAAQD,EAASM,GSltFjC,QAAAoI,GAAAqG,EAAAjC,EAAAhH,GACA,IAAAA,IAAAgH,EACA,SAAAzL,OAAA,8EAoCA,OAjCAC,QAAAC,iBAAAnB,MAEA0M,YACArL,MAAAqL,EACA1K,YAAA,GAEA0D,OACArE,MAAAqE,EACA1D,YAAA,GAEA2M,QACAtN,MAAAsN,EACA3M,YAAA,GAGAS,SACApB,MAAA4G,KAAAqH,MAAArH,KAAAC,UAAAyG,EAAAlM,UACAT,YAAA,EACAV,UAAA,KAIAJ,OAAAuC,eAAAzD,KAAA,kBACAqB,MAAA,SAAAkG,EAAAhB,GACA,OACAgB,aACAhB,SACAmG,WAAA1M,KAAA0M,WACAhH,MAAA1F,KAAA0F,UAKA1F,KAAA2O,OAAA/J,SACA5E,KAAA2O,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAA4O,IAAA,0CAEA,OAAA5O,IAAA4O,EAAA1O,QAAAL,MAAA,KAKAhF,KA7EA,GACAgU,GAAA9T,EAAA,IACAiP,EAAAjP,EAAA,GACA+T,EAAA/T,EAAA,GACAgU,EAAAhU,EAAA,IACAiU,EAAAjU,EAAA,GAsFAoI,GAAAG,UAAA2L,MAAA,SAAAtE,EAAAjP,EAAAC,GACA,GACA4C,EAEA5C,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAArD,iBAAA,mBAAAxK,GAEA4C,EAAA1D,KAAA2O,OAAAT,YAAkCxD,KAAAoF,GAAc9P,KAAAyC,SAEhDzC,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,oBAAArL,EAAA7C,EAAA,SAAAiJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAgK,UAaA9L,EAAAG,UAAAC,OAAA,SAAA7H,EAAAC,GACA,GAAAwI,MACAvI,EAAAf,IAYA,OAVAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAtJ,KAAA2O,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SACAzC,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,uBAAAzF,EAAAzI,EAAA,SAAAiJ,GACAhJ,EAAAgJ,IAAA5H,OAAAnB,KAGAf,MAoBAsI,EAAAG,UAAA4L,eAAA,SAAAhU,EAAAiU,EAAAzT,EAAAC,GACA,GACAC,GAAAf,KACAsJ,KACA/C,EAAA,QAoBA,IAlBAlG,GAAA,gBAAAA,KACAS,EAAAD,EACAA,EAAAyT,EACAA,EAAAjU,EACAA,EAAA,MAGAS,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyT,YAAAnF,GACA7F,EAAAgL,EAAAzF,YAEAvF,EAAAoB,KAAA4J,EAGAzT,KAAA0T,QACA,eAAA1T,EAAA0T,QACAhO,EAAA,sBAEA,cAAA1F,EAAA0T,QACA,SAAAtT,OAAA,2CAAAJ,EAAA0T,QAsBA,OAlBAlU,KACAiJ,EAAAmC,IAAApL,GAGAiJ,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAvI,EAAA0B,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,WAAAxI,GAAA+C,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACA,GAAAyK,EAEA,OAAA1K,GACAhJ,EAAAgJ,IAGA0K,EAAA,GAAArF,GAAApO,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,OACA8I,EAAAjF,QAAAxF,EAAAK,OAAAoF,aACA1O,GAAA,KAAA0T,MAGAxU,MAmBAsI,EAAAG,UAAAgM,eAAA,SAAA1H,EAAAlM,EAAAC,GACA,GACAyF,GACA+C,IA0BA,OAxBA,gBAAAyD,IACAzD,EAAAmC,IAAAsB,EACAxG,EAAA,WAEA+C,EAAAoB,MAAiBhH,MAAAqJ,GACjBxG,EAAA,iBAGAzF,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAtJ,KAAA2O,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEAzC,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,WAAAxI,GAAA+C,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAD,EACAhJ,EAAAgJ,GAGAhJ,EAAA,gBAAAyF,GAAAwD,EAAAK,OAAAqB,KAAA1B,EAAAK,OAAA2F,OAIA/P,MAUAsI,EAAAG,UAAAiM,qBAAA,SAAA7T,EAAAC,GACA,GACAwI,IAAY5D,MAAA1F,KAAA0F,MAAAgH,WAAA1M,KAAA0M;EACZ3L,EAAAf,IAaA,OAXAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,qCAAAzF,EAAAzI,EAAA,SAAAiJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGArJ,GAUAuH,EAAAG,UAAAkM,eAAA,SAAAvF,EAAAvO,EAAAC,GACA,GACAwI,IAAYmC,IAAA2D,GACZrO,EAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,4BAAAxK,GAEAC,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,qBAAAzF,EAAAzI,EAAA,SAAAiJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,WAWA9B,EAAAG,UAAAmM,cAAA,SAAAxF,EAAAvO,EAAAC,GACA,GACAwI,IAAYmC,IAAA2D,GACZrO,EAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,mBAAAxK,GACAwI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,kBAAAzF,EAAAzI,EAAA,SAAAiJ,EAAAC,GACA,GAAAuK,EAEA,OAAAxK,GACAhJ,EAAAgJ,IAGAwK,EAAA,GAAAnF,GAAApO,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,OACA4I,EAAA/E,QAAAxF,EAAAK,OAAAoF,aACA1O,GAAA,KAAAwT,OAUAhM,EAAAG,UAAAoM,WAAA,SAAAhU,EAAAC,GACA,GAAAgU,EAEAhU,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAArD,iBAAA,wBAAAxK,GAEAgU,EAAA,GAAAb,GAAAjU,MACA8U,EAAAlH,QAAA/M,EAAAC,IAWAwH,EAAAG,UAAAsM,gBAAA,SAAAC,EAAAnU,EAAAC,GACA,GAAAwI,IACAoB,SAEA3J,EAAAf,IAOA,OALAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAuG,MAAAC,QAAA2N,IAIAjU,EAAA4N,OAAArD,iBAAA,qBAAAxK,GAEAwI,EAAAoB,KAAAsK,YAAAC,IAAA,SAAAT,GACA,MAAAA,aAAArF,GAAAqF,EAAA3F,YAAA2F,IAGAlL,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,sBAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGArJ,GAfAD,EAAA,GAAAG,OAAA,yGA0BAqH,EAAAG,UAAAyM,yBAAA,SAAAF,EAAAnU,EAAAC,GACA,GAAAwI,IACAoB,SAEA3J,EAAAf,IAOA,OALAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAuG,MAAAC,QAAA2N,IAIAjU,EAAA4N,OAAArD,iBAAA,8BAAAxK,GAEAwI,EAAAoB,KAAAsK,YAAAC,IAAA,SAAAT,GACA,MAAAA,aAAArF,GAAAqF,EAAA3F,YAAA2F,IAGAlL,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,+BAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGArJ,GAfAD,EAAA,GAAAG,OAAA,kHA0BAqH,EAAAG,UAAA0M,gBAAA,SAAAC,EAAAvU,EAAAC,GACA,GAAAwI,IACAoB,MACAqF,IAAAqF,IAGArU,EAAAf,IAOA,OALAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAuG,MAAAC,QAAA+N,IAIArU,EAAA4N,OAAArD,iBAAA,qBAAAxK,GAEAwI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,sBAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGArJ,GAXAD,EAAA,GAAAG,OAAA,qGAqBAqH,EAAAG,UAAA4M,aAAA,SAAAD,EAAAvU,EAAAC,GACA,GAAAwI,IACAoB,MACAqF,IAAAqF,IAGArU,EAAAf,IAOA,OALAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAuG,MAAAC,QAAA+N,IAIArU,EAAA4N,OAAArD,iBAAA,kBAAAxK,GAEAwI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,aAEA1B,GAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,mBAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,WARAtJ,EAAA,GAAAG,OAAA,kGAoBAqH,EAAAG,UAAA6M,iBAAA,SAAAN,EAAAnU,EAAAC,GACA,GAAAwI,IACAoB,SAEA3J,EAAAf,IAOA,OALAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAuG,MAAAC,QAAA2N,IAIAjU,EAAA4N,OAAArD,iBAAA,sBAAAxK,GAEAwI,EAAAoB,KAAAsK,YAAAC,IAAA,SAAAT,GACA,MAAAA,aAAArF,GAAAqF,EAAA3F,YAAA2F,IAGAlL,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,uBAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGArJ,GAfAD,EAAA,GAAAG,OAAA,0GA0BAqH,EAAAG,UAAA8M,gBAAA,SAAAP,EAAAnU,EAAAC,GACA,GAAAwI,IACAoB,SAEA3J,EAAAf,IAOA,OALAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAuG,MAAAC,QAAA2N,IAIAjU,EAAA4N,OAAArD,iBAAA,qBAAAxK,GAEAwI,EAAAoB,KAAAsK,YAAAC,IAAA,SAAAT,GACA,MAAAA,aAAArF,GAAAqF,EAAA3F,YAAA2F,IAGAlL,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,sBAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGArJ,GAfAD,EAAA,GAAAG,OAAA,yGAwBAqH,EAAAG,UAAA+M,kBAAA,SAAA3U,EAAAC,GACA,GACAwI,IAAY5D,MAAA1F,KAAA0F,MAAAgH,WAAA1M,KAAA0M,YACZ3L,EAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,+BAAAxK,GACAwI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,kCAAAzF,EAAAzI,EAAA,SAAAiJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,WAgBA9B,EAAAG,UAAAgN,eAAA,SAAAnB,EAAAzT,EAAAC,GACA,GAAAwI,KAWA,OATAgL,aAAAnF,GACA7F,EAAAgL,EAAAzF,YAEAvF,EAAAoB,KAAA4J,EAGAhL,EAAAtJ,KAAA2O,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SACAzC,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,sBAAAzF,EAAAzI,EAAAC,GAEAd,MAgBAsI,EAAAG,UAAAiN,gBAAA,SAAAtG,EAAAtD,EAAAjL,EAAAC,GACA,GACAC,GAAAf,KACAsJ,GACAmC,IAAA2D,EACA1E,KAAAoB,EAsBA,OAnBAhL,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,8BAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACA,GAAAuK,EAEA,OAAAxK,GACAhJ,EAAAgJ,IAGAwK,EAAA,GAAAnF,GAAApO,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,OACA4I,EAAA/E,QAAAxF,EAAAK,OAAAoF,aACA1O,GAAA,KAAAwT,MAGAtU,MAeAsI,EAAAG,UAAAkN,OAAA,SAAA7F,EAAAjP,EAAAC,GACA,GACA4C,GACA3C,EAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,MAGAE,EAAA4N,OAAArD,iBAAA,oBAAAxK,GAEA4C,EAAA3C,EAAA4N,OAAAT,YAAkCxD,KAAAoF,GAAc9P,KAAAyC,SAEhD1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,qBAAArL,EAAA7C,EAAA,SAAAuD,EAAAgG,GACA,GAAA4K,KAEA,OAAA5Q,GACAtD,EAAAsD,IAGAgG,SAAAwB,KAAAxI,QAAA,SAAAoR,GACA,GAAA9E,GAAA,GAAAP,GAAApO,EAAAyT,EAAA/I,IAAA+I,EAAAzJ,QAAAyJ,EAAA9I,MAEAgE,GAAAH,QAAAiF,EAAAhF,SAEAwF,EAAA7G,KAAAuB,KAGAtF,SAAAwL,aACA/U,EAAAmN,SAAA5D,SAAAwL,gBAGA9U,GAAA,QAAAkT,GACAjT,EACAqJ,SAAAyL,MACAb,EACA5K,SAAA0L,aAAA1L,SAAA0L,gBACAjV,EACAiP,EACAjP,EAAAkV,UAAA,WAgBAzN,EAAAG,UAAAsF,OAAA,SAAAC,EAAAnN,EAAAiP,EAAAhP,GACA,GACAoF,MACAnF,EAAAf,IAEA,KAAAgO,EACA,SAAA/M,OAAA,0CAmDA,OAhDAH,KACAA,EAAAgP,EACAA,EAAA,MAGAhP,GAAA,kBAAAD,KACAC,EAAAD,EACAA,MAGAb,KAAA2O,OAAArD,iBAAA,oBAAAxK,GAEAoF,EAAA8H,WAEAnN,KAAAkN,SACA7H,EAAA6H,OAAAlN,EAAAkN,QAGA/N,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,UAAyCL,EAAArF,EAAA,SAAAuD,EAAAgG,GAC9D,GAAA4K,KAEA,OAAA5Q,GACAtD,EAAAsD,IAGAgG,SAAAwB,KAAAxI,QAAA,SAAAoR,GACA,GAAA9E,GAAA,GAAAP,GAAApO,EAAAyT,EAAA/I,IAAA+I,EAAAzJ,QAAAyJ,EAAA9I,MAEAgE,GAAAH,QAAAiF,EAAAhF,SAEAwF,EAAA7G,KAAAuB,KAGAtF,SAAAwL,aACA/U,EAAAmN,SAAA5D,SAAAwL,gBAGA9U,GAAA,QAAAkT,GACAjT,EACAqJ,SAAAyL,MACAb,KAEAnU,EACAiP,EACAjP,EAAAkV,UAAA,UAIA/V,MAUAsI,EAAAG,UAAAuN,qBAAA,SAAAhI,EAAAnN,EAAAC,GACA,GACAwI,IAAY0E,WAEZ,KAAAA,EACA,SAAA/M,OAAA,wDAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,MAGAb,KAAA2O,OAAArD,iBAAA,kCAAAxK,GAEAD,KAAAkN,SACAzE,EAAAyE,OAAAlN,EAAAkN,QAGA/N,KAAA2O,OAAAjL,OACK6D,WAAA,aAAAhB,OAAA,wBACLvG,KAAA2O,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SACA5B,EACA,SAAAiJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,WAYA9B,EAAAG,UAAAwN,qBAAA,SAAAnG,EAAAjP,EAAAC,GACA,GACAwI,IAAYoB,MAAQhH,MAAAoM,IACpB/O,EAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,MAGAE,EAAA4N,OAAArD,iBAAA,kCAAAxK,GAEAwI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,OAAqB6D,WAAA,aAAAhB,OAAA,wBAA2D+C,EAAAzI,EAAA,SAAAiJ,EAAAC,GAChFjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,WAaA9B,EAAAG,UAAAoH,UAAA,SAAAC,EAAAjP,EAAAC,GACA,GACAuR,GACA6D,CAcA,OAZApV,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAArD,iBAAA,uBAAAxK,GAEAoV,EAAA,GAAA/B,GACA9B,EAAA,GAAA6B,GAAAlU,KAAAa,GAEAwR,EAAAzK,MAAAkI,EAAAhP,EAAAoV,EAAAC,KAAAC,KAAAF,IAEAA,GAWA5N,EAAAG,UAAA4N,SAAA,SAAAxV,EAAAC,GACA,GAAAwI,KAUA,OARAxI,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAtJ,KAAA2O,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SACAzC,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,yBAAAzF,EAAAzI,EAAAC,GAEAd,MAiBAsI,EAAAG,UAAA6N,eAAA,SAAAlH,EAAAtD,EAAAjL,EAAAC,GACA,GAAAwI,IACAmC,IAAA2D,EACA1E,KAAAoB,GAEA/K,EAAAf,IAqBA,OAnBAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAA,KAAA0V,kBACAjN,EAAAiN,gBAAA1V,EAAA0V,iBAGAjN,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,qBAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACA,MAAAD,GACAhJ,EAAAgJ,OAGA,IAAAqF,GAAApO,EAAAgJ,EAAAK,OAAAqB,KAAAmC,QAAA9M,KAGAC,GAWAuH,EAAAG,UAAA+N,qBAAA,SAAAC,EAAA5V,EAAAC,GACA,GACA4L,MACApD,GAAYoB,SACZ3J,EAAAf,IAgBA,OAdA0M,GAAA1M,KAAA0M,YAAA+J,EACAnN,EAAAoB,KAAA1K,KAAA0F,OAAAgH,EAEA5L,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,qCAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,UAGArJ,GAUAuH,EAAAG,UAAAiO,uBAAA,SAAAD,EAAA5V,EAAAC,GACA,GACA4L,MACApD,GAAYoB,SACZ3J,EAAAf,IAEA0M,GAAA1M,KAAA0M,YAAA+J,EACAnN,EAAAoB,KAAA1K,KAAA0F,OAAAgH,EAEA5L,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,oCAAAxK,GACAwI,EAAAvI,EAAA4N,OAAAT,WAAA5E,EAAAtJ,KAAAyC,SAEA1B,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,uCAAAzF,EAAAzI,EAAA,SAAAiJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAJ,UAYA1B,EAAAG,UAAA6L,SAAA,SAAAjU,EAAAyL,GACA,UAAAqD,GAAAnP,KAAAK,EAAAyL,IAUAxD,EAAAG,UAAA4J,KAAA,SAAAxR,GACA,UAAAqT,GAAAlU,KAAAa,IAUAyH,EAAAG,UAAAkO,kBAAA,SAAAC,GACA,UAAA3C,GAAAjU,KAAA4W,IAYAtO,EAAAG,UAAA6F,WAAA,SAAAxC,EAAAyC,GAEA,MADAvO,MAAA2O,OAAAL,WAAA/N,KAAAP,KAAA8L,EAAAyC,GACAvO,MAGAH,EAAAD,QAAA0I,GTqvFM,SAAUzI,EAAQD,GUxwHxB,QAAAqU,GAAAvH,EAAAkK,GAwBA,MAvBA1V,QAAAC,iBAAAnB,MAEA0M,YACArL,MAAAqL,EACA1K,YAAA,GAEA2M,QACAtN,MAAAqL,EAAAiC,OACA3M,YAAA,GAGAS,SACApB,MAAA4G,KAAAqH,MAAArH,KAAAC,UAAAwE,EAAAjK,UACAT,YAAA,EACAV,UAAA,GAEAsV,SACAvV,MAAAuV,MACA5U,YAAA,EACAV,UAAA,KAIAtB,KAAA2O,OAAA/J,SACA5E,KAAA2O,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAA4O,IAAA,mBAEA,OAAA5O,IAAA4O,EAAA1O,QAAAL,MAAA,KAKAhF,KASAiU,EAAAxL,UAAAQ,MAAA,SAAApI,EAAAC,GACA,GACAC,GAAAf,KACAsJ,EAAAtJ,KAAA2O,OAAAT,YAAmCxD,MAAOmM,WAAA7W,KAAA4W,UAA0B5W,KAAAyC,QAepE,OAbA3B,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA1D,KAAA0M,WAAAqC,eAAA,8BAAAzF,EAAAzI,EAAA,SAAAiJ,GACA,MAAAA,GACAhJ,KAAAgJ,OAGA/I,GAAA6M,QAAA/M,EAAAC,KAGAd,MAYAiU,EAAAxL,UAAAmF,QAAA,SAAA/M,EAAAC,GACA,GACAC,GAAAf,KACAsJ,EAAAtJ,KAAA2O,OAAAT,cAAoClO,KAAAyC,QAgCpC,OA9BA3B,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,MAAA1D,KAAA0M,WAAAqC,eAAA,2BAAAzF,EAAAzI,EAAA,SAAAiJ,EAAAC,GACA,MAAAD,KACAhJ,KAAAgJ,GAGAC,EAAAK,OAAArJ,EAAA2L,WAAAhH,OACAqE,EAAAK,OAAArJ,EAAA2L,WAAAhH,OAAAoR,SAAA/V,EAAA2L,wBACA3L,EAAA6V,QAAA7M,EAAAK,OAAArJ,EAAA2L,WAAAhH,OAAAoR,SAAA/V,EAAA2L,uBAAAmK,WAGA3U,SAAAnB,EAAA6V,UACA7V,EAAA6V,iBASA9V,GACAA,EAAA,KAAAC,KAPAD,KAAA,GAAAG,OAAA,mCAAAF,EAAA2L,wBAGA5L,KAAA,GAAAG,OAAA,8BAAAF,EAAA2L,WAAAhH,UAQA1F,MAaAiU,EAAAxL,UAAAsO,IAAA,SAAAC,EAAAJ,GAGA,MAFA5W,MAAA4W,QAAAI,GAAAJ,EAEA5W,MAYAiU,EAAAxL,UAAA6F,WAAA,SAAAxC,EAAAyC,GAEA,MADAvO,MAAA2O,OAAAL,WAAA/N,KAAAP,KAAA8L,EAAAyC,GACAvO,MAGAH,EAAAD,QAAAqU,GVoyHM,SAAUpU,EAAQD,GWvwHxB,QAAAmE,GAAA4K,GAiBA,MAhBAzN,QAAAC,iBAAAnB,MAEA2O,QACAtN,MAAAsN,EACA3M,YAAA,GAGAS,SACApB,MAAA4G,KAAAqH,MAAArH,KAAAC,UAAAyG,EAAAlM,UACAT,YAAA,EACAV,UAAA,KAIAtB,KAAAsO,WAAAK,EAAAL,WAAA8H,KAAApW,MAEAA,KAAA2O,OAAA/J,SACA5E,KAAA2O,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAA4O,IAAA,aAEA,OAAA5O,IAAA4O,EAAA1O,QAAAL,MAAA,KAKAhF,KA8FA,QAAAiX,GAAA3N,EAAA4N,EAAAlS,EAAA3D,GACA6V,GAAA,QAAAlS,EACAsE,EAAAtE,GAAA3D,EAGAiI,EAAAoB,KAAA1F,GAAA3D,EAaA,QAAA8V,GAAA7N,EAAAzI,GACA,GAAAuW,KAEAlW,QAAAiC,KAAAtC,GACAkE,OAAA,SAAA1B,GACA,MAAAxC,GAAAwC,KAAA,uCAAAgC,QAAAhC,MAAA,IAEAD,QAAA,SAAAC,GACA,cAAAA,GAAA,aAAAA,GACA+T,EAAAjJ,KAAA9K,SACAxC,GAAAwC,IAEA,UAAAA,GAAA,SAAAA,IACA,UAAAA,GACA+T,EAAAjJ,KAAA,SAGAiJ,EAAAjJ,KAAAtN,EAAAwC,WAGAxC,GAAAwC,KAGA+T,EAAArR,OAAA,IACAuD,EAAAzI,QAAAuW,GAYA,QAAAC,GAAA/N,EAAAzI,GACAyI,EAAAzI,SAAA,cAEAA,EAAAyW,QACAhO,EAAAgO,MAAAzW,EAAAyW,YACAzW,GAAAyW,OAUA,QAAAC,GAAAC,GACA,MAAAA,GAAAvC,IAAA,SAAAwC,GACA,MAAAA,GAAAxC,IAAA,SAAAyC,GACA,MAAAC,YAAAD,OAkBA,QAAAE,GAAAJ,GAEA,MAAApQ,OAAAC,QAAAmQ,EAAA,IAMAA,EAAAvC,IAAA,SAAA4C,GAEA,GAGAjH,GAHAlQ,GACAsE,KAAA6S,EAAA,GAIA,KAAAjH,EAAA,EAAeA,EAAAiH,EAAA9R,OAAkB6K,IAEjCxJ,MAAAC,QAAAwQ,EAAAjH,IACAlQ,EAAAoX,YAAAD,EAAAjH,GAAAqE,IAAA,SAAA8C,GACA,MAAAJ,YAAAI,KAKArX,EAAAsX,SAAAL,WAAAE,EAAAjH,GAIA,OAAAlQ,KAzBA8W,EAAAvC,IAAA,SAAA4C,GACA,OAAc7S,KAAA6S,KAmCd,QAAAI,GAAAT,GACA,MAAApQ,OAAAC,QAAAmQ,SASA,QAAAU,GAAAV,GACA,MAAAA,GAAAvC,IAAA,SAAA5T,GACA,MAAA8W,UAAA9W,KAuBA,QAAA+W,GAAAZ,GACA,GACAa,GAAA,KACAC,IAYA,OAVAd,GAAApU,QAAA,SAAA/B,GACA,OAAAgX,EACAA,EAAAhX,GAGAiX,EAAAnK,MAAmBoK,OAAAF,EAAAG,MAAAb,WAAAtW,KACnBgX,EAAA,QAIAC,EA2BA,QAAAG,GAAAjB,GACA,OACAkB,OAAAlB,EAAA,GACAxH,OAAAwH,EAAA,IA1gBA,GACAmB,IAAWzB,QAAA,EAAA0B,UAAA,QACXC,GAAgB3B,QAAA,EAAA0B,UAAA,gBAChBE,GAAa5B,QAAA,EAAA0B,UAAA,SACbG,GAAe7B,QAAA,EAAA0B,UAAA,iBACfI,GACA9B,QAAA,EACA0B,UAAA,gBACAK,MAAA,iBACAC,WAAAT,GAEAU,GACAjC,QAAA,EACA0B,UAAA,sBACAK,KAAA5B,EACA6B,WAAAd,GAEAgB,GACAlC,QAAA,EACA0B,UAAA,mBACAK,KAAA5B,EACA6B,WAAAd,GAEAiB,GAAWT,UAAA,QACXU,GAAgBV,UAAA,gBAChBW,GAAqBX,UAAA,wBACrBY,GAAgBZ,UAAA,YAIhBa,GACAC,OAAAJ,EACAK,UAAezC,QAAA,EAAA0B,UAAA,OAAAK,MAAA,gBACfW,OAAYhB,UAAA,2BACZiB,QAAa3C,QAAA,EAAA0B,UAAA,aAAAK,MAAA,gBACba,QAAa5C,QAAA,GACb6C,KAAAV,EACAW,OAAAV,EACAW,KAAUrB,UAAA,SACVnJ,OAAAqJ,EACAoB,QAAatB,UAAA,kBACbuB,UAAevB,UAAA,oBACfwB,WACAC,QAAazB,UAAA,iBACb0B,SACApD,QAAA,EACA0B,UAAA,2BACAK,MAAA,QACAC,WAAAvB,YAEA4C,SAAcrD,QAAA,EAAA0B,UAAA,kBACd4B,QAAatD,QAAA,EAAA0B,UAAA,iBAAAM,WAAA3B,GACbkD,WACAvD,QAAA,EACA0B,UAAA,qCACAK,KAAA9B,EACA+B,WAAAtB,GAEA8C,mBACAxD,QAAA,EACA0B,UAAA,kCACAK,KAAA9B,EACA+B,WAAAtB,GAEA+C,IAAAhC,EACAiC,QAAa1D,QAAA,EAAA0B,UAAA,iBACbiC,UAAe3D,QAAA,EAAA0B,UAAA,sBACfkC,OAAAxB,EACAyB,MAAWnC,UAAA,iBACXoC,QAAAnC,EACAoC,KAAApC,EACAqC,SAAchE,QAAA,EAAA0B,UAAA,QACduC,QAAA5B,EACA6B,cAAmBxC,UAAA,uBAAAM,WAAAvB,YACnB0D,MAAA1C,EACA2C,KAAA3C,EACA4C,OAAYrE,QAAA,EAAA0B,UAAA,iBACZ4C,OAAY5C,UAAA,kBACZ6C,MAAAzC,EACA0C,KAAAnC,EACAoC,OAAApC,EACAqC,QAAA/C,EACAgD,MAAAlD,EACAmD,KAAAzC,EACA0C,OAAAzC,EACA0C,aAAkBpD,UAAA,eAAAM,WAAAvB,YAClBxU,MAAW+T,QAAA,EAAA0B,UAAA,YACXqD,QAAa/E,QAAA,EAAA0B,UAAA,cACbsD,SAActD,UAAA,mCACduD,KAAAxD,EACAyD,KAAA/C,EACAgD,OAAYzD,UAAA,iBACZ0D,OAAAhD,EACAiD,QAAarF,QAAA,EAAA0B,UAAA,uBACb4D,MAAW5D,UAAA,wBACX6D,MAAW7D,UAAA,wBACX8D,OAAY9D,UAAA,uBACZ+D,KAAA7D,EACA8D,KAAApD,EACAqD,OAAArD,EACAxR,QAAakP,QAAA,EAAA0B,UAAA,qBACbkE,QAAAzD,EACA0D,SAAcnE,UAAA,uBACdoE,WAAgBpE,UAAA,oBAChBqE,OAAYrE,UAAA,mBACZsE,QAAApE,EACAqE,SAAcvE,UAAA,kBACdwE,MAAWlG,QAAA,GACXmG,QAAazE,UAAA,+BACb0E,KAAA3E,EACA4E,WAAgBrG,QAAA,GAChBsG,QAAa5E,UAAA,iBACb6E,UAAe7E,UAAA,iBACf8E,KAAArE,EACAsE,WAAgB/E,UAAA,yBAChBgF,OAAYhF,UAAA,iBACZiF,OAAAvE,EACAwE,MAAWlF,UAAA,kBACXmF,MAAW7G,QAAA,EAAA0B,UAAA,UAAAK,MAAA,iBAAAC,WAAAT,GACXuF,MAAArF,EACAsF,OAAY/G,QAAA,EAAA0B,UAAA,eACZsF,YAAiBtF,UAAA,6BACjB7B,KAAU6B,UAAA,eAAAK,MAAA,sBACVkF,OAAYvF,UAAA,0BACZwF,MAAA9E,EACA+E,OAAAvF,EACAwF,aAAkB1F,UAAA,uBAClB2F,UAAAxF,EACAyF,SAAA7F,EACA8F,OAAY7F,UAAA,+BACZ8F,MAAWxH,QAAA,EAAA0B,UAAA,OAAAK,MAAA,yCACX0F,MAAW/F,UAAA,OAAAK,MAAA,SAAAC,WAAAjB,GACX2G,aAAkB1H,QAAA,EAAA0B,UAAA,OAAAK,MAAA,SAAAC,WAAAjB,GAClB4G,MAAWjG,UAAA,kBACXkG,MAAA9F,EACA+F,OAAApG,EACAqG,OAAAlG,EACAmG,aAAkBrG,UAAA,uBAClBsG,MAAWhI,QAAA,EAAAgC,WAAAhB,GACXiH,OAAYvG,UAAA,SACZwG,IAAAzG,EACA3L,KAAA2L,EACA0G,MAAWzG,UAAA,kBAAAK,MAAA,wBACXqG,MAAA3G,EACA4G,QAAarI,QAAA,EAAA0B,UAAA,oBACb4G,SAAc5G,UAAA,yBACd6G,aAAkB7G,UAAA,cAAAK,MAAA,wBAClByG,WAAgBxI,QAAA,EAAA0B,UAAA,oBAChB+G,OAAAxG,EACAyG,aAAkB1I,QAAA,EAAA0B,UAAA,mBAAAK,MAAA,UAClB4G,gBAAqB3I,QAAA,EAAA0B,UAAA,mBAAAK,MAAA,UACrB6G,cAAA1G,EACA2G,MAAAhH,EACAiH,MAAWpH,UAAA,kBACXqH,gBAAqBrH,UAAA,oBACrBsH,iBAAsBtH,UAAA,uBACtBuH,kBAAuBvH,UAAA,oBACvBwH,UAAAjH,EACAkH,iBAAAjH,EACAkH,SAAAvH,EACAwH,MAAAvH,EACAwH,QAAatJ,QAAA,EAAA0B,UAAA,gBAAAM,WAAAvB,YACb8I,aAAkB7H,UAAA,cAAAK,MAAA,0BA6DlB,WACA/X,OAAAiC,KAAAsW,GAAArW,QAAA,SAAAsd,GACA3c,EAAA0E,UAAAiY,GAAA,WACA,GAGA5f,GAFA+L,EAAAzF,MAAAqB,UAAAqE,MAAAvM,KAAA2I,WACArI,EAAA,KAEA6C,GACA6D,WAAA,KACAhB,OAAAma,GAEApX,IAwBA,IAtBAuD,EAAA9G,QAAA,kBAAA8G,KAAA9G,OAAA,KACAjF,EAAA+L,EAAA8T,OAGAlH,EAAAiH,GAAAxJ,QAAAlX,KAAA2O,OAAArD,iBAAA,iBAAAoV,EAAA5f,GAEA2Y,EAAAiH,GAAAxJ,SACA5N,EAAAoB,SAGA+O,EAAAiH,GAAA9H,UACAa,EAAAiH,GAAA9H,SAAAxV,QAAA,SAAAwd,GACA,GAAAvf,GAAAwL,EAAA7F,OAEA,IAAA9E,SAAAb,EACA,SAAAJ,OAAA,iBAAAyf,EAAA,wBAAAE,EAAA,IAGA3J,GAAA3N,EAAAmQ,EAAAiH,GAAAxJ,OAAA0J,EAAAvf,KAIAwL,EAAA9G,OAAA,EACA,SAAA9E,OAAA,iBAAAyf,EAAA,iCAGA,QAAA7T,EAAA9G,QAAA,gBAAA8G,GAAA,IAAAzF,MAAAC,QAAAwF,EAAA,IACA,SAAA5L,OAAA,iBAAAyf,EAAA,oDAoCA,IAjCA7T,EAAA9G,SACAlF,EAAAK,OAAAuF,UAAkCoG,EAAA,IAElCzF,MAAAC,QAAAoS,EAAAiH,GAAAzH,OACAQ,EAAAiH,GAAAzH,KAAA7V,QAAA,SAAAC,GACA,OAAAxC,EAAAwC,IAAAnB,SAAArB,EAAAwC,KACA4T,EAAA3N,EAAAmQ,EAAAiH,GAAAxJ,OAAA7T,EAAAxC,EAAAwC,UACAxC,GAAAwC,OAUA,kBAAAoW,GAAAiH,GAAAzH,MACAQ,EAAAiH,GAAAzH,KAAA3P,EAAAzI,OAGAb,KAAA2O,OAAAjL,QAAA4F,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACA,MAAAD,GACAhJ,EAAAgJ,GAGA2P,EAAAiH,GAAAxH,WACApY,EAAA,KAAA2Y,EAAAiH,GAAAxH,WAAAnP,EAAAK,aAGAtJ,GAAA,KAAAiJ,EAAAK,WAGAqP,EAAAiH,GAAAxJ,OACA,MAAAlX,YAkOAH,EAAAD,QAAAmE,GX88HM,SAAUlE,EAAQD,EAASM,GYp8IjC,QAAAgU,GAAAxH,EAAA7L,GAqFA,MAnFAK,QAAAC,iBAAAnB,MAEA6D,UACAxC,MAAA,KACAC,UAAA,GAEAuf,SACAxf,MAAA,KACAC,UAAA,GAEAjB,IACAgB,MAAAgH,KAEAyY,aACAzf,MAAA,KACAC,UAAA,GAEAyf,UACA1f,MAAA,KACAC,UAAA,GAEA0f,UACA3f,MAAA,KACAC,UAAA,GAEA2f,OACA5f,SACAC,UAAA,GAGA4f,cACA7f,MAAA,KAEA8f,OACA9f,MAAAR,KAAAsgB,MAAAtgB,EAAAsgB,MAAA,OAEAvf,OACAP,MAAAR,KAAAe,MAAAf,EAAAe,MAAA,QAEAwG,aACA/G,OAAA,EACAC,UAAA,GAEA8f,OACA/f,MAAAR,KAAAugB,MAAAvgB,EAAAugB,MAAA,QAGA1U,YACArL,MAAAqL,EACA1K,YAAA,GAEA2M,QACAtN,MAAAqL,EAAAiC,OACA3M,YAAA,GAGA8N,SACAzO,MAAA,KACAW,YAAA,EACAV,UAAA,GAEAmB,SACApB,MAAA4G,KAAAqH,MAAArH,KAAAC,UAAAwE,EAAAjK,UACAT,YAAA,EACAV,UAAA,GAEAoB,UACArB,MAAAR,KAAA6B,SAAA7B,EAAA6B,YACAV,YAAA,EACAV,UAAA,GAEAmG,QACApG,MAAA,KACAW,YAAA,EACAV,UAAA,GAEA+f,iBACAhgB,OAAAR,GAAA,iBAAAA,GAAAwgB,iBAAAxgB,EAAAwgB,gBACArf,YAAA,EACAV,UAAA,KAIAtB,KAAA2O,OAAA/J,SACA5E,KAAA2O,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,IAAA,QAEA,OAAAD,IAAAC,EAAAC,QAAAL,MAAA,KAKAhF,KA+LA,QAAAshB,GAAAhY,GACA,uBAAAA,EAAA0D,MACAhN,KAAA2O,OAAA3L,SAAAd,OACAlC,KAAA2O,OAAA7I,UAAA,kBAGA,aAAAwD,EAAA0D,OACA1D,EAAAgL,SAAA,GAAAnF,GAAAnP,KAAA0M,WAAApD,EAAAc,OAAAqB,IAAAnC,EAAAc,OAAAW,QAAAzB,EAAAc,OAAAsB,aACApC,GAAAc,aAGApK,KAAA2O,OAAAhN,eAAA2H,EAAAjD,YACArG,KAAAqhB,iBACArhB,KAAA6D,SAAA,KAAAyF,SAEAtJ,MAAA2O,OAAAhN,eAAA2H,EAAAjD,YAEArG,KAAA6D,SAAA,KAAAyF,KAQA,QAAA1C,KAGA,IAFA,GAAA2a,GAEAvhB,KAAAihB,MAAAlb,OAAA,GACAwb,EAAAvhB,KAAAihB,MAAAja,QAEAhH,KAAAuhB,EAAAhb,QAAA0C,MAAAjJ,KAAAuhB,EAAA1U,MAIA,QAAA2U,KACA,oBAAAxhB,KAAA2O,OAAA/M,QAAA5B,KAAAoI,YA5VA,GACAC,GAAAnI,EAAA,GACAiP,EAAAjP,EAAA,EA+HAgU,GAAAzL,UAAA2L,MAAA,SAAAtT,GACA,GAAAwI,EAMA,IAJAtJ,KAAA2O,OAAArD,iBAAA,aAAAxK,GAEAwI,EAAAtJ,KAAA2O,OAAAT,YAAiCxD,MAAOjD,OAAAzH,KAAAyH,SAAqBzH,KAAAyC,UAE7D+e,EAAAjhB,KAAAP,MAEA,WADAA,MAAAihB,MAAA9S,MAAqB5H,OAAA,QAAAsG,MAAA/L,IAIrB,KAAAd,KAAAyH,OACA,SAAAxG,OAAA,6DAGAjB,MAAA2O,OAAAjL,MAAA1D,KAAA0M,WAAAqC,eAAA,oBAAAzF,EAAA,SAAAQ,EAAAC,GACAjJ,EAAAgJ,EAAAC,KAAAK,OAAAgK,UAWAF,EAAAzL,UAAAb,MAAA,SAAAkI,EAAA2R,EAAA3gB,GACA,GACAC,GAAAf,KACAuF,EAAAC,KAAAD,MACAmc,GACAP,MAAApgB,EAAAogB,MACAvf,MAAAb,EAAAa,MACAwf,MAAArgB,EAAAqgB,MAkBA,OAfA,kBAAAtR,KACAhP,EAAA2gB,EACAA,EAAA3R,EACAA,EAAA,MAGAhP,IACAA,EAAAC,EAAAigB,UAGAjgB,EAAA4N,OAAArD,iBAAA,aAAAmW,GAKA1gB,EAAA+f,aAAAvb,EAAAxE,EAAA+f,aAAA/f,EAAAmgB,aACApgB,KAAA,GAAAG,OAAA,0CAAAF,EAAAmgB,aAAA,YAGApR,IACA/O,EAAA+O,WAOA,cAAA/O,EAAA4N,OAAA/M,OACAb,EAAA8C,SAAA4d,EACA1gB,EAAAigB,SAAAlgB,OACAC,EAAA4N,OAAA9M,cAAAC,QAAAf,EAAAV,IAAAU,IAIAA,EAAAqH,gBACArH,GAAAkgB,MAAA9S,MAAqB5H,OAAA,QAAAsG,MAAAiD,EAAA2R,EAAA3gB,MAIrBC,EAAA+G,cACA/G,EAAA0G,OAAA,KACA1G,EAAAqH,aAAA,EACArH,EAAA8C,SAAA4d,EACA1gB,EAAAigB,SAAAlgB,EACAC,EAAA4N,OAAA9M,cAAAC,QAAAf,EAAAV,IAAAU,EAEA2gB,EAAAhX,KAAA3J,EAAA+O,QACA4R,EAAA3gB,EAAA4N,OAAAT,WAAAwT,EAAA3gB,EAAA0B,aAEA1B,GAAA4N,OAAAjL,MAAA3C,EAAA2L,WAAAqC,eAAA,wBAAA2S,GAA8Fhf,SAAA3B,EAAA2B,UAAwB,SAAA0B,EAAAkC,GAItH,aAHAvF,GAAA4N,OAAA9M,cAAAC,QAAAf,EAAAV,IACAU,EAAAqH,aAAA,EAEAhE,GACArD,EAAAkgB,SACAngB,KAAA,GAAAG,OAAA,qCAAAmD,EAAAoC,YAGAzF,EAAA+f,YAAAvb,EACAxE,EAAA0G,OAAAnB,EAAA8D,OAAA3C,OACA1G,EAAA8f,QAAAva,EAAA8D,OAAAyW,QAEA9f,EAAA4N,OAAA9M,cAAAd,EAAA0G,UACA1G,EAAA4N,OAAA9M,cAAAd,EAAA0G,YAGA1G,EAAA4N,OAAA9M,cAAAd,EAAA0G,QAAA1G,EAAAV,IAAAU,EAEAA,EAAAggB,SAAAO,EAAAlL,KAAArV,GACAA,EAAA4N,OAAAxI,QAAAkD,GAAAtI,EAAA8f,QAAA9f,EAAAggB,UAEAna,EAAArG,KAAAQ,QACAD,KAAA,KAAAC,UAaAmT,EAAAzL,UAAAX,YAAA,WACA,GAGA6Z,GAFA5gB,EAAAf,KACAqS,EAAAtR,EAAA0G,MAGA,OAAA+Z,GAAAjhB,KAAAP,OAKAqS,IACAtR,EAAA4N,OAAAxI,QAAA6K,IAAAjQ,EAAA8f,QAAA7gB,KAAA+gB,UAEA,IAAA7f,OAAAiC,KAAApC,EAAA4N,OAAA9M,cAAAwQ,IAAAtM,cACAhF,GAAA4N,OAAA9M,cAAAwQ,GAEA,IAAAnR,OAAAiC,KAAApC,EAAA4N,OAAA9M,cAAAC,SAAAiE,OACAhF,EAAA4N,OAAAjL,MAAA3C,EAAA2L,WAAAqC,eAAA,2BAAsFrE,MAAOjD,OAAA4K,KAE7FsP,EAAAjd,YAAA,WACA,IAAAxD,OAAAiC,KAAApC,EAAA4N,OAAA9M,cAAAC,SAAAiE,SACAhF,EAAA4N,OAAA9M,cAAAwQ,IACAtR,EAAA4N,OAAAjL,MAAA3C,EAAA2L,WAAAqC,eAAA,2BAA4FrE,MAAOjD,OAAA4K,KAEnGlF,cAAAwU,KAES,YAGT5gB,GAAA4N,OAAA9M,cAAAwQ,GAAAtR,EAAAV,IAGAU,EAAA0G,OAAA,MAGA1G,IA7BAA,EAAAkgB,MAAA9S,MAAqB5H,OAAA,cAAAsG,UACrB9L,IAwCAmT,EAAAzL,UAAA6F,WAAA,SAAAxC,EAAAyC,GAEA,MADAvO,MAAA2O,OAAAL,WAAA/N,KAAAP,KAAA8L,EAAAyC,GACAvO,MAiDAH,EAAAD,QAAAsU,GZo+IM,SAAUrU,EAAQD,GalzJxB,QAAAgiB,GAAAlV,EAAAmJ,EAAAb,EAAAc,EAAAjV,EAAAiP,EAAAiG,GAoCA,MAnCA7U,QAAAC,iBAAAnB,MAEA0M,YACArL,MAAAqL,EACA1K,YAAA,GAEA6T,OACAxU,MAAAwU,EACA7T,YAAA,GAEAgT,WACA3T,MAAA2T,EACAhT,YAAA,GAEA8T,cACAzU,MAAAyU,MACA9T,YAAA,GAEAnB,SACAQ,MAAAR,MACAmB,YAAA,GAEA8N,SACAzO,MAAAyO,MACA9N,YAAA,GAGA6f,iBACAxgB,MAAA0U,YAAA6L,GAAA5M,EAAAjP,OAAAgQ,EAAA8L,gBAAA7M,EAAAjP,OACA/D,YAAA,EACAV,UAAA,KAKAtB,KAAA0M,WAAAiC,OAAA/J,SACA5E,KAAA0M,WAAAiC,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,IAAA,YAEA,OAAAD,IAAAC,EAAAC,QAAAL,MAAA,KAKAhF,KAMA4hB,EAAAnZ,UAAAqZ,UAAA,SAAAhhB,GACA,GACAgP,GACAjP,EAAAK,OAAAuF,UAA8BzG,KAAAa,SAC9BE,EAAAf,IAKA,OAHAa,GAAAkV,SAAA/V,KAGAa,EAAAmN,SACAhO,KAAA6hB,iBAAA7hB,KAAA+hB,eACAjhB,GAAA,YAKA,mBAAAD,GAAAgN,YACAhN,GAAAgN,KAGAhN,EAAAiN,YACAjN,GAAAiN,SAGA9N,MAAA0M,WAAAqB,OAAAlN,EAAAmN,SAAAnN,EAAAb,KAAA8P,YAAwEhP,IAMxED,EAAAiN,MAAA9N,KAAA8P,QAAA4O,KACA1e,KAAA6hB,iBAAA7hB,KAAA+hB,eACAjhB,GAAA,YAIAD,EAAAgN,YACAhN,GAAAgN,KAGAiC,EAAA5O,OAAAuF,OAAAzG,KAAA8P,SAA2CkS,kBAE3ClS,EAAA4O,KAAAtb,QAAA,SAAA6e,GACAnS,EAAAkS,aAAA7T,KAAApN,EAAAiU,UAAAjU,EAAAiU,UAAAjP,OAAA,GAAA+F,QAAA5K,OAAAiC,KAAA8e,GAAA,WAGAjiB,MAAA0M,WAAAiJ,OAAA7F,EAAAjP,EAAAC,IAMAoB,SAAArB,EAAAgN,MAAA3L,SAAArB,EAAAiN,MACAgC,EAAA5O,OAAAuF,UAA8BzG,KAAA8P,SAG9BjP,EAAAgN,MAAAhN,EAAAiN,KAEAjN,EAAAgN,MAAA7N,KAAA+hB,eACAjhB,GAAA,eAKAd,MAAA0M,WAAAiJ,OAAA7F,EAAAjP,EAAAC,QAKAA,GAAA,GAAAG,OAAA,uFAMA2gB,EAAAnZ,UAAAyZ,aAAA,WACA,MAAAliB,MAAAgV,WAMA4M,EAAAnZ,UAAAsZ,SAAA,WACA,MAAA/hB,MAAA6V,OAMA+L,EAAAnZ,UAAA0Z,gBAAA,WACA,MAAAniB,MAAA8V,cAMA8L,EAAAnZ,UAAA2Z,WAAA,WACA,MAAApiB,MAAAa,SAMA+gB,EAAAnZ,UAAA4Z,WAAA,WACA,MAAAriB,MAAA8P,SAMA8R,EAAAnZ,UAAA6Z,cAAA,WACA,MAAAtiB,MAAA0M,YAMAkV,EAAAnZ,UAAA8Z,mBAAA,WACA,MAAAviB,MAAA6hB,iBAGAhiB,EAAAD,QAAAgiB,Gb00JM,SAAU/hB,EAAQD,GcrgKxB,QAAAuU,KACAnU,KAAAwiB,OACAxiB,KAAAoE,MAAA,KACApE,KAAAqS,KAAA,KAOA8B,EAAA1L,UAAAga,OAAA,SAAA3hB,GAQA,MAPAd,MAAAoE,OAAApE,KAAAqS,KACAvR,EAAAd,KAAAoE,MAAApE,KAAAqS,MAGArS,KAAAwiB,IAAArU,KAAArN,GAGAd,MASAmU,EAAA1L,UAAA0N,KAAA,SAAA/R,EAAAiO,GACArS,KAAAoE,QACApE,KAAAqS,OAEArS,KAAAwiB,IAAApf,QAAA,SAAAtC,GACAA,EAAAsD,EAAAiO,MAIAxS,EAAAD,QAAAuU,GdghKM,SAAUtU,EAAQD,EAASM,GehjKjC,QAAAiG,GAAAvF,EAAAwB,EAAAC,GAEA,sBAAA4N,QAAA,CAEA,sBAAAkB,WACA,WAAAjR,EAAA,IAAAU,EAAAwB,EAAAC,EAGA,IAAA4N,OAAAyS,GACA,WAAAxiB,EAAA,KAAAU,EAAAwB,EAAAC,EAGA,UAAApB,OAAA,mFAGA,WAAAf,EAAA,IAAAU,EAAAwB,EAAAC,GAGAxC,EAAAD,QAAAuG,Gf+jKM,SAAUtG,EAAQD,GgBzlKxB,QAAA+iB,GAAA/hB,EAAAwB,EAAA8O,GACAlR,KAAAY,OACAZ,KAAAoC,OACApC,KAAAkR,MACAlR,KAAA4iB,OAAA,KACA5iB,KAAAuR,cAAA,EACAvR,KAAA6iB,iBAAA,EACA7iB,KAAA8iB,UACAre,WACAmF,aACAmZ,gBACA5Z,eAEAnJ,KAAAwR,UAAA,EASAxR,KAAAyE,QAAA,SAAA1C,EAAAI,GACA,GAAApB,GAAAf,IAEAA,MAAA4iB,OAAA3S,OAAAyS,IAAA1iB,KAAAkR,IAAA,sBAAAlR,KAAAY,KAAA,IAAAZ,KAAAoC,MACA4gB,aAAAjhB,EACAI,oBACA8gB,UAAA,IAGAjjB,KAAA4iB,OAAAvZ,GAAA,qBACAtI,EAAAwQ,aACAxQ,EAAA+hB,SAAAlZ,UAAAxG,QAAA,SAAA8f,GACAA,MAIAniB,EAAA+hB,SAAAre,QAAArB,QAAA,SAAA8f,GACAA,MAIAniB,EAAAwQ,cAAA,IAGAvR,KAAA4iB,OAAAvZ,GAAA,yBAAAjF,GACA6N,EAAAlR,EAAAgB,EAAAI,EAAAiC,KAGApE,KAAA4iB,OAAAvZ,GAAA,wBACA,GAAAjF,EAEArD,GAAA8hB,gBACA9hB,EAAA+hB,SAAA3Z,WAAA/F,QAAA,SAAA8f,GACAA,OAIA9e,EAAA,GAAAnD,OAAA,iEACAmD,EAAAsC,OAAA,IAEAuL,EAAAlR,EAAAgB,EAAAI,EAAAiC,IAGArD,EAAA8hB,iBAAA,KASA7iB,KAAAoJ,UAAA,SAAAvF,GACA7D,KAAA8iB,SAAAre,QAAAY,QAAAxB,MAAA,GACA7D,KAAA8iB,SAAAre,QAAA0J,KAAAtK,IAQA7D,KAAAuJ,eAAA,SAAA1F,GACA7D,KAAA8iB,SAAAC,aAAA1d,QAAAxB,MAAA,GACA7D,KAAA8iB,SAAAC,aAAA5U,KAAAtK,IAQA7D,KAAA0J,aAAA,SAAA7F,GACA7D,KAAA8iB,SAAA3Z,WAAA9D,QAAAxB,MAAA,GACA7D,KAAA8iB,SAAA3Z,WAAAgF,KAAAtK,IAQA7D,KAAA2J,YAAA,SAAA9F,GACA7D,KAAA8iB,SAAAlZ,UAAAvE,QAAAxB,MAAA,GACA7D,KAAA8iB,SAAAlZ,UAAAuE,KAAAtK,IAWA7D,KAAAoG,KAAA,SAAAqB,EAAA5D,GACA7D,KAAA4iB,OAAAxc,KAAAqB,EAAA5D,IASA7D,KAAAqJ,GAAA,SAAA5B,EAAA5D,GACA7D,KAAA4iB,OAAAvZ,GAAA5B,EAAA5D,IASA7D,KAAAgR,IAAA,SAAAvJ,EAAA5D,GACA7D,KAAA4iB,OAAA5R,IAAAvJ,EAAA5D,IASA7D,KAAA2G,KAAA,SAAAyL,GACApS,KAAA4iB,OAAAha,KAAA,SAAAwJ,IAMApS,KAAAoN,MAAA,WACApN,KAAA6iB,iBAAA,EAEA7iB,KAAA4iB,OAAAxV,QACApN,KAAA4iB,OAAA,MAYA,QAAA3Q,GAAAkR,EAAAphB,EAAAI,EAAAiC,IACArC,GAAAohB,EAAA3R,UAAA2R,EAAAzR,wBACAyR,EAAA3R,UAAA,EACAvK,WAAA,WACAkc,EAAA3R,UAAA,EACA2R,EAAA1e,QAAA1C,EAAAI,IACKA,IAGLghB,EAAAL,SAAAC,aAAA3f,QAAA,SAAA8f,GACAA,EAAA9e,KAKAvE,EAAAD,QAAA+iB,GhBgmKM,SAAU9iB,EAAQD,EAASM,GiBvxKjC,QAAAkjB,GAAAtf,EAAAzD,EAAAyL,EAAAmC,GAgBA,GAdAS,EAAAnO,KAAAP,KAAA8D,EAAAzD,EAAAyL,EAAAmC,GAGA/M,OAAAC,iBAAAnB,MAEAgP,kBACA3N,MAAA,iBAEA6N,kBACA7N,MAAA,mBAKAyC,EAAA6K,OAAA/J,SACA,MAAAd,GAAA6K,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,IAAA,iBAEA,OAAAD,IAAAC,EAAAC,QAAAL,MAAA,KAxBA,GAAA0J,GAAAxO,EAAA,EA+BAkjB,GAAA3a,UAAAvH,OAAAwH,OAAAgG,EAAAjG,WACAE,aACAtH,MAAA+hB,KAWAA,EAAA3a,UAAAkH,KAAA,SAAA9O,EAAAC,GACA,GACAwI,GACAvI,EAAAf,IAEA,KAAAA,KAAA8L,QAAAuX,SACA,SAAApiB,OAAA,6FAcA,OAXAJ,IAAAqB,SAAApB,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAtJ,KAAA6O,YAEA9N,EAAA4N,OAAAjL,MAAA3C,EAAA+C,SAAAiL,eAAA,0BAAAzF,EAAAzI,EAAAC,GAAA,SAAAsD,GACAtD,EAAAsD,IAAAlC,OAAAnB,KAGAA,GAUAqiB,EAAA3a,UAAA6a,UAAA,SAAAC,GAEA,mBAAAA,IAAA,gBAAAA,GAAAC,OACA,SAAAviB,OAAA,uGASA,OANAjB,MAAA8L,QAAAuX,WACArjB,KAAA8L,QAAAuX,aAGArjB,KAAA8L,QAAAuX,SAAAlV,KAAAoV,GAEAvjB,MASAojB,EAAA3a,UAAAgb,YAAA,SAAAJ,GAEA,IAAAjc,MAAAC,QAAAgc,GACA,SAAApiB,OAAA,gHAWA,OARAoiB,GAAApO,IAAA,SAAAsO,GACA,mBAAAA,IAAA,gBAAAA,GAAAC,OACA,SAAAviB,OAAA,mHAIAjB,KAAA8L,QAAAuX,WAEArjB,MAQAojB,EAAA3a,UAAAoG,UAAA,WACA,GACAvF,KASA,OAPAtJ,MAAAK,KACAiJ,EAAAmC,IAAAzL,KAAAK,IAGAiJ,EAAAoB,KAAA1K,KAAA8L,QACAxC,EAAA2E,KAAAjO,KAAAiO,KAEA3E,GASA8Z,EAAA3a,UAAAib,YAAA,WACA,MAAA1jB,MAAA8L,QAAAuX,UAGAxjB,EAAAD,QAAAwjB,GjBgyKM,SAAUvjB,EAAQD,EAASM,GkB36KjC,QAAAyjB,GAAA7f,EAAAzD,EAAAyL,EAAAmC,GAgBA,GAdAS,EAAAnO,KAAAP,KAAA8D,EAAAzD,EAAAyL,EAAAmC,GAGA/M,OAAAC,iBAAAnB,MAEAgP,kBACA3N,MAAA,cAEA6N,kBACA7N,MAAA,gBAKAyC,EAAA6K,OAAA/J,SACA,MAAAd,GAAA6K,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,IAAA,OAEA,OAAAD,IAAAC,EAAAC,QAAAL,MAAA,KAxBA,GAAA0J,GAAAxO,EAAA,EA+BAyjB,GAAAlb,UAAAvH,OAAAwH,OAAAgG,EAAAjG,WACAE,aACAtH,MAAAsiB,KAeAA,EAAAlb,UAAAkH,KAAA,SAAA9O,EAAAC,GACA,GACAwI,GAAAtJ,KAAA6O,YACA9N,EAAAf,IAWA,OATAa,IAAAqB,SAAApB,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA1D,KAAA8D,SAAAiL,eAAA,uBAAAzF,EAAAzI,EAAAC,GAAA,SAAAsD,GACAtD,EAAAsD,IAAAlC,OAAAnB,KAGAf,MAGAH,EAAAD,QAAA+jB,GlBo7KM,SAAU9jB,EAAQD,EAASM,GmBz+KjC,QAAA4D,GAAA6K,GAeA,MAbAzN,QAAAuC,eAAAzD,KAAA,UACAqB,MAAAsN,IAGAzN,OAAAuC,eAAAzD,KAAA,kBACAqB,MAAA,SAAAkF,GACA,OACAgB,WAAA,WACAhB,aAKAvG,KAAA2O,OAAA/J,SACA5E,KAAA2O,OAAA/J,SAAAC,aAAA7E,MACA8E,OAAA,UACAC,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAA4O,IAAA,0CAEA,OAAA5O,IAAA4O,EAAA1O,QAAAL,MAAA,KAKAhF,KAtCA,GACA2jB,GAAAzjB,EAAA,IACAkjB,EAAAljB,EAAA,IACAqI,EAAArI,EAAA,EA8CA4D,GAAA2E,UAAAmb,UAAA,SAAAvjB,EAAAQ,EAAAC,GACA,GACAwI,GACAvI,EAAAf,IAEA,KAAAK,EACA,SAAAY,OAAA,mDAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,GAAUmC,IAAApL,GAEVU,EAAA4N,OAAArD,iBAAA,qBAAAxK,GAEAC,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,WAAAzF,EAAAzI,EAAA,SAAAiJ,EAAAxD,GACAxF,EAAAgJ,IAAA5H,OAAA,GAAAyhB,GAAA5iB,EAAAuF,EAAA8D,OAAAqB,IAAAnF,EAAA8D,OAAAW,QAAAzE,EAAA8D,OAAAsB,WAgBA5H,EAAA2E,UAAAob,YAAA,SAAA/T,EAAAjP,EAAAC,GACA,GACAC,GAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,uBAAAxK,GAEAC,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,gBAAyDrE,KAAAoF,GAAcjP,EAAA,SAAAuD,EAAAgG,GACvE,GAAA4K,EAEA,OAAA5Q,GACAtD,EAAAsD,IAGA4Q,EAAA5K,SAAAwB,KAAAqJ,IAAA,SAAAT,GACA,UAAAmP,GAAA5iB,EAAAyT,EAAA/I,IAAA+I,EAAAzJ,QAAAyJ,EAAA9I,aAGA5K,GAAA,MAAc+U,MAAAzL,SAAAyL,MAAAiO,MAAA9O,QAiBdlR,EAAA2E,UAAAsb,WAAA,SAAA1jB,EAAAyL,EAAAjL,EAAAC,GACA,GACAC,GAAAf,KACAsJ,KACA/C,EAAA,YAEA,KAAAlG,GAAA,gBAAAA,GACA,SAAAY,OAAA,8DAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAmC,IAAApL,EACAiJ,EAAAoB,KAAAoB,EAEAjL,IACA0F,EAAA1F,EAAAmjB,eAAA,oCAGAjjB,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAAxI,GAAA+C,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA,GAAAyhB,GAAA5iB,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,WAcA5H,EAAA2E,UAAAwb,WAAA,SAAA5jB,EAAAyL,EAAAjL,EAAAC,GACA,GACAC,GAAAf,KACAsJ,GAAYmC,IAAApL,EAAAqK,KAAAoB,GACZvF,EAAA,YAEA,KAAAlG,GAAA,gBAAAA,GACA,SAAAY,OAAA,8DAYA,OATAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAAxI,GAAA+C,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA,GAAAyhB,GAAA5iB,EAAAV,EAAAyL,EAAA/B,EAAAK,OAAAsB,UAGA1L,MAgBA8D,EAAA2E,UAAAyb,WAAA,SAAA7jB,EAAAQ,EAAAC,GACA,GAAAwI,IAAcmC,IAAApL,EAWd,OATAS,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,cAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAqB,OAGAzL,MAYA8D,EAAA2E,UAAA0b,KAAA,SAAA9jB,EAAAyL,EAAAmC,GACA,UAAA0V,GAAA3jB,KAAAK,EAAAyL,EAAAmC,IAYAnK,EAAA2E,UAAA4K,aAAA,SAAAhT,EAAAQ,EAAAC,GACA,GACAwI,GACAvI,EAAAf,IAOA,IALAc,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,OAGAR,GAAA,gBAAAA,GACA,SAAAY,OAAA,sDAIAqI,IAAUmC,IAAApL,GAEVU,EAAA4N,OAAArD,iBAAA,wBAAAxK,GAEAC,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,cAAAzF,EAAAzI,EAAA,SAAAuD,EAAAkC,GACAxF,EAAAsD,IAAAlC,OAAA,GAAAkhB,GAAAriB,EAAAuF,EAAA8D,OAAAqB,IAAAnF,EAAA8D,OAAAW,QAAAzE,EAAA8D,OAAAsB,WAgBA5H,EAAA2E,UAAA2b,eAAA,SAAAtU,EAAAjP,EAAAC,GACA,GACAC,GAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,0BAAAxK,GAEAC,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,mBAA4DrE,KAAAoF,GAAcjP,EAAA,SAAAuD,EAAAkC,GAC1E,GACA0O,GACAhH,CAEA,OAAA5J,GACAtD,EAAAsD,IAGA4Q,EAAA1O,EAAA8D,OAAAwB,KAAAqJ,IAAA,SAAAT,GACA,UAAA4O,GAAAriB,EAAAyT,EAAA/I,IAAA+I,EAAAzJ,QAAAyJ,EAAA9I,SAGApF,EAAA8D,OAAA4D,WACAA,EAAA1H,EAAA8D,OAAA4D,cAGAlN,GAAA,MAAc+U,MAAAvP,EAAA8D,OAAAyL,MAAAwO,SAAArP,EAAAhH,iBAiBdlK,EAAA2E,UAAA6b,cAAA,SAAAjkB,EAAAgjB,EAAAxiB,EAAAC,GACA,GACAC,GAAAf,KACAsJ,KACA/C,EAAA,eAEA,KAAAlG,GAAA,gBAAAA,GACA,SAAAY,OAAA,uEAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAmC,IAAApL,EAEAgjB,IACA/Z,EAAAoB,MAAiB2Y,aAGjBxiB,IACA0F,EAAA1F,EAAAmjB,eAAA,0CAGAjjB,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAAxI,GAAA+C,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA,GAAAkhB,GAAAriB,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,WAcA5H,EAAA2E,UAAA8b,cAAA,SAAAlkB,EAAAgjB,EAAAxiB,EAAAC,GACA,GACAC,GAAAf,KACAsJ,KACA/C,EAAA,eAEA,KAAAlG,GAAA,gBAAAA,GACA,SAAAY,OAAA,uEA4BA,OAzBAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAmC,IAAApL,EAEAgjB,IACA/Z,EAAAoB,MAAiB2Y,aAGjBtiB,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAAxI,GAAA+C,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACA,GAAAya,KAEA,OAAA1a,GACAhJ,EAAAgJ,IAGA5I,OAAAiC,KAAA4G,EAAAK,OAAAW,SAAA3H,QAAA,SAAAqhB,GACAD,EAAAC,GAAA1a,EAAAK,OAAAW,QAAA0Z,SAGA3jB,GAAA,QAAAsiB,GAAAriB,EAAAgJ,EAAAK,OAAAqB,IAAA+Y,EAAAza,EAAAK,OAAAsB,WAGA1L,MAgBA8D,EAAA2E,UAAAic,cAAA,SAAArkB,EAAAQ,EAAAC,GACA,GAAAwI,IAAcmC,IAAApL,EAWd,OATAS,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,iBAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAqB,OAGAzL,MAQA8D,EAAA2E,UAAAkc,eAAA,SAAA3W,EAAAnN,EAAAC,GACA,GACAoF,MACAnF,EAAAf,IAEA,KAAAgO,EACA,SAAA/M,OAAA,gDAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,MAGAb,KAAA2O,OAAArD,iBAAA,0BAAAxK,GAEAoF,EAAA8H,WAEAnN,KAAAkN,SACA7H,EAAA6H,OAAAlN,EAAAkN,QAGA/N,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,kBAAiDL,EAAArF,EAAA,SAAAuD,EAAAgG,GACtE,GAAAia,KAEA,OAAAjgB,GACAtD,EAAAsD,IAGAgG,SAAAwB,KAAAxI,QAAA,SAAAkQ,GACA,GAAAsR,GAAA,GAAAxB,GAAAriB,EAAAuS,EAAA7H,IAAA6H,EAAAvI,QAAAuI,EAAA5H,MAEAkZ,GAAArV,QAAA+D,EAAA9D;AAEA6U,EAAAlW,KAAAyW,SAGA9jB,GAAA,MACA+U,MAAAzL,SAAAyL,MACAwO,WACArW,iBAcAlK,EAAA2E,UAAA6K,QAAA,SAAAjT,EAAAyL,EAAAmC,GACA,UAAAmV,GAAApjB,KAAAK,EAAAyL,EAAAmC,IAUAnK,EAAA2E,UAAAoc,UAAA,SAAAxkB,EAAAQ,EAAAC,GACA,GACAwI,IAAYmC,IAAApL,GACZU,EAAAf,IAEA,KAAAK,GAAA,gBAAAA,GACA,SAAAY,OAAA,mDAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,qBAAAxK,GAEAC,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,WAAAzF,EAAAzI,EAAA,SAAAiJ,EAAAxD,GACAxF,EAAAgJ,IAAA5H,OAAA,GAAAqG,GAAAxH,EAAAuF,EAAA8D,OAAAqB,IAAAnF,EAAA8D,OAAAW,QAAAzE,EAAA8D,OAAAsB,WAeA5H,EAAA2E,UAAAqc,YAAA,SAAAhV,EAAAjP,EAAAC,GACA,GACAC,GAAAf,IAEAc,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,uBAAAxK,GAEAC,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,gBAAyDrE,KAAAoF,GAAcjP,EAAA,SAAAuD,EAAAkC,GACvE,GACA0O,GACAhH,EAAA,IAEA,OAAA5J,GACAtD,EAAAsD,IAGA4Q,EAAA1O,EAAA8D,OAAAwB,KAAAqJ,IAAA,SAAAT,GACA,UAAAjM,GAAAxH,EAAAyT,EAAA/I,IAAA+I,EAAAzJ,QAAAyJ,EAAA9I,SAGApF,EAAA8D,OAAA4D,WACAA,EAAA1H,EAAA8D,OAAA4D,cAGAlN,GAAA,MAAc+U,MAAAvP,EAAA8D,OAAAyL,MAAAuL,MAAApM,EAAAhH,iBAYdlK,EAAA2E,UAAAsc,WAAA,SAAA1kB,EAAAyL,EAAAjL,EAAAC,GACA,GACAC,GAAAf,KACAsJ,GAAYmC,IAAApL,EAAAqK,KAAAoB,EAEZhL,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA3C,EAAAgO,eAAA,cAAAzF,EAAA,KAAAxI,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA,GAAAqG,GAAAxH,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,WAYA5H,EAAA2E,UAAAuc,YAAA,SAAA3kB,EAAAyL,EAAAjL,EAAAC,GACA,GACAC,GAAAf,KACAsJ,GAAYmC,IAAApL,EAAAqK,KAAAoB,EAEZ,KAAAzL,GAAA,gBAAAA,GACA,SAAAY,OAAA,gEAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,eAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA,GAAAqG,GAAAxH,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,WAeA5H,EAAA2E,UAAAwc,qBAAA,SAAA5kB,EAAAyL,EAAAjL,EAAAC,GACA,GACAC,GAAAf,KACAsJ,GAAYmC,IAAApL,EAAAqK,KAAAoB,EAEZ,IAAAA,EAAA6G,WACA,SAAA1R,OAAA,2DAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAA,wBAAAzF,EAAA,KAAAxI,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA,GAAAqG,GAAAxH,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,aAcAjH,EAAA2E,UAAAyc,WAAA,SAAA7kB,EAAAyL,EAAAjL,EAAAC,GACA,GACAC,GAAAf,KACAsJ,KACA/C,EAAA,YAEA,KAAAlG,GAAA,gBAAAA,GACA,SAAAY,OAAA,gEAeA,OAZAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAyI,EAAAmC,IAAApL,EACAiJ,EAAAoB,KAAAoB,EAEA/K,EAAA4N,OAAAjL,MAAA1D,KAAA+O,eAAAxI,GAAA+C,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA,GAAAqG,GAAAxH,EAAAgJ,EAAAK,OAAAqB,IAAA1B,EAAAK,OAAAW,QAAAhB,EAAAK,OAAAsB,UAGA1L,MAgBA8D,EAAA2E,UAAA0c,WAAA,SAAA9kB,EAAAQ,EAAAC,GACA,GAAAwI,IAAcmC,IAAApL,EAWd,OATAS,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,cAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAqB,OAGAzL,MAQA8D,EAAA2E,UAAA2c,YAAA,SAAApX,EAAAnN,EAAAC,GACA,GACAoF,MACAnF,EAAAf,IAEA,KAAAgO,EACA,SAAA/M,OAAA,6CAsCA,OAnCAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,MAGAb,KAAA2O,OAAArD,iBAAA,uBAAAxK,GAEAoF,EAAA8H,WAEAnN,KAAAkN,SACA7H,EAAA6H,OAAAlN,EAAAkN,QAGA/N,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,eAA8CL,EAAArF,EAAA,SAAAuD,EAAAgG,GACnE,GAAAgX,KAEA,OAAAhd,GACAtD,EAAAsD,IAGAgG,SAAAwB,KAAAxI,QAAA,SAAAiiB,GACA,GAAAC,GAAA,GAAA/c,GAAAxH,EAAAskB,EAAA5Z,IAAA4Z,EAAAta,QAAAsa,EAAA3Z,MAEA4Z,GAAA/V,QAAA8V,EAAA7V,SAEA4R,EAAAjT,KAAAmX,SAGAxkB,GAAA,MACA+U,MAAAzL,SAAAyL,MACAuL,QACApT,gBAIAhO,MAYA8D,EAAA2E,UAAA4c,KAAA,SAAAhlB,EAAAyL,EAAAmC,GACA,UAAA1F,GAAAvI,KAAAK,EAAAyL,EAAAmC,IAmBAnK,EAAA2E,UAAA8c,gBAAA,SAAAC,EAAAje,EAAAhB,EAAAb,EAAAgH,GACA,GAAA+Y,EAEA,KAAAD,GAAA,gBAAAA,GACA,SAAAvkB,OAAA,6DAEA,KAAAsG,GAAA,gBAAAA,GACA,SAAAtG,OAAA,iEAEA,KAAAsF,GAAA,gBAAAA,GACA,SAAAtF,OAAA,6DAmBA,OAfAwkB,GAAAD,EACAzgB,OAAA,SAAA2gB,GACA,MAAAA,GAAAne,gBAAA,MAAAme,EAAAne,aAEAxC,OAAA,SAAA2gB,GACA,MAAAA,GAAAnf,YAAA,MAAAmf,EAAAnf,SAEAxB,OAAA,SAAA2gB,GACA,MAAAA,GAAAhgB,WAAA,MAAAggB,EAAAhgB,QAEAX,OAAA,SAAA2gB,GACA,MAAAA,GAAAhZ,gBAAA,MAAAgZ,EAAAhZ,aAIA+Y,EAAAE,KAAA,SAAA9U,GAA2C,kBAAAA,EAAAxP,QAC3C,UAGAokB,EAAAE,KAAA,SAAA9U,GAA2C,sBAAAA,EAAAxP,QAC3C,cAGA,UAWAyC,EAAA2E,UAAAmd,cAAA,SAAAC,EAAAhlB,EAAAC,GACA,GACAwI,IAAYmC,IAAAoa,GACZ9kB,EAAAf,IAEA,KAAA6lB,GAAA,gBAAAA,GACA,SAAA5kB,OAAA,2DAGAH,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAE,EAAA4N,OAAArD,iBAAA,uBAAAxK,GAEAd,KAAA2O,OAAAjL,MAAA1D,KAAA+O,eAAA,iBAAAzF,EAAAzI,EAAAC,GAAA,SAAAgJ,EAAAC,GACAjJ,EAAAgJ,IAAA5H,OAAA6H,EAAAK,OAAAwB,SAcA9H,EAAA2E,UAAAqd,kBAAA,SAAArb,EAAAsb,EAAAjb,EAAAjK,EAAAC,GAcA,MAbAA,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,sBAAuDkF,IAAAsa,EAAAtb,WAAAC,KAAAI,GAAiDjK,EAAA,SAAAiJ,EAAAC,GAC7HD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,OAAAW,WAMA/K,MAYA8D,EAAA2E,UAAAud,kBAAA,SAAAvb,EAAAsb,EAAAllB,EAAAC,GAcA,MAbAA,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,sBAAuDkE,WAAAgB,IAAAsa,GAA8BllB,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GAC1GD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,UAMApK,MASA8D,EAAA2E,UAAAwd,uBAAA,SAAAplB,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,6BAA6D1F,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GAClFD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,WAcAtG,EAAA2E,UAAAyd,oBAAA,SAAAzb,EAAA5J,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,wBAAyDkE,YAAmB5J,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GACjGD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,WAeAtG,EAAA2E,UAAA0d,eAAA,SAAA1b,EAAAsb,EAAAllB,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,mBAAoDkE,WAAAgB,IAAAsa,GAA8BllB,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GACvGD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,WAeAtG,EAAA2E,UAAA2d,eAAA,SAAA3b,EAAAsb,EAAAllB,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,mBAAoDkE,WAAAgB,IAAAsa,GAA8BllB,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GACvGD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,WAiBAtG,EAAA2E,UAAA4d,kBAAA,SAAA5b,EAAAsb,EAAAjb,EAAAjK,EAAAC,GAcA,MAbAA,IAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,sBAAuDkE,WAAAgB,IAAAsa,EAAArb,KAAAI,GAAiDjK,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GAC7HD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,UAMApK,MAYA8D,EAAA2E,UAAA6d,oBAAA,SAAA7b,EAAAsb,EAAAjb,EAAAjK,EAAAC,GACAA,GAAA,kBAAAD,KACAC,EAAAD,EACAA,EAAA,MAGAb,KAAA2O,OAAAjL,OAAqB6D,WAAA,WAAAhB,OAAA,wBAAyDkE,WAAAgB,IAAAsa,EAAArb,KAAAI,GAAiDjK,EAAA,kBAAAC,GAAA,cAAAgJ,EAAAC,GAC/HD,EAGAhJ,KAAAgJ,GAFAhJ,KAAA,KAAAiJ,EAAAK,WAOAvK,EAAAD,QAAAkE,GnB4/KM,SAAUjE,EAAQD,GoBt/MxB,QAAA2mB,KACAvmB,KAAAkQ,QAAAlQ,KAAAkQ,YACAlQ,KAAAwmB,cAAAxmB,KAAAwmB,eAAAtkB,OAwQA,QAAAukB,GAAA1Z,GACA,wBAAAA,GAGA,QAAA2Z,GAAA3Z,GACA,sBAAAA,GAGA,QAAA4Z,GAAA5Z,GACA,sBAAAA,IAAA,OAAAA,EAGA,QAAA6Z,GAAA7Z,GACA,gBAAAA,EAnRAlN,EAAAD,QAAA2mB,EAGAA,iBAEAA,EAAA9d,UAAAyH,QAAAhO,OACAqkB,EAAA9d,UAAA+d,cAAAtkB,OAIAqkB,EAAAM,oBAAA,GAIAN,EAAA9d,UAAAqe,gBAAA,SAAAC,GACA,IAAAL,EAAAK,MAAA,GAAAC,MAAAD,GACA,KAAAE,WAAA,8BAEA,OADAjnB,MAAAwmB,cAAAO,EACA/mB,MAGAumB,EAAA9d,UAAAG,KAAA,SAAAoE,GACA,GAAAka,GAAAhE,EAAAiE,EAAAta,EAAA+D,EAAAR,CAMA,IAJApQ,KAAAkQ,UACAlQ,KAAAkQ,YAGA,UAAAlD,KACAhN,KAAAkQ,QAAA9L,OACAuiB,EAAA3mB,KAAAkQ,QAAA9L,SAAApE,KAAAkQ,QAAA9L,MAAA2B,QAAA,CAEA,GADAmhB,EAAAhe,UAAA,GACAge,YAAAjmB,OACA,KAAAimB,EAGA,IAAApd,GAAA,GAAA7I,OAAA,yCAAAimB,EAAA,IAEA,MADApd,GAAAsd,QAAAF,EACApd,EAOA,GAFAoZ,EAAAljB,KAAAkQ,QAAAlD,GAEA4Z,EAAA1D,GACA,QAEA,IAAAuD,EAAAvD,GACA,OAAAha,UAAAnD,QAEA,OACAmd,EAAA3iB,KAAAP,KACA,MACA,QACAkjB,EAAA3iB,KAAAP,KAAAkJ,UAAA,GACA,MACA,QACAga,EAAA3iB,KAAAP,KAAAkJ,UAAA,GAAAA,UAAA,GACA,MAEA,SACA2D,EAAAzF,MAAAqB,UAAAqE,MAAAvM,KAAA2I,UAAA,GACAga,EAAAja,MAAAjJ,KAAA6M,OAEG,IAAA8Z,EAAAzD,GAIH,IAHArW,EAAAzF,MAAAqB,UAAAqE,MAAAvM,KAAA2I,UAAA,GACAkH,EAAA8S,EAAApW,QACAqa,EAAA/W,EAAArK,OACA6K,EAAA,EAAeA,EAAAuW,EAASvW,IACxBR,EAAAQ,GAAA3H,MAAAjJ,KAAA6M,EAGA,WAGA0Z,EAAA9d,UAAAuD,YAAA,SAAAgB,EAAAd,GACA,GAAA1L,EAEA,KAAAimB,EAAAva,GACA,KAAA+a,WAAA,8BA2CA,OAzCAjnB,MAAAkQ,UACAlQ,KAAAkQ,YAIAlQ,KAAAkQ,QAAAmX,aACArnB,KAAA4I,KAAA,cAAAoE,EACAyZ,EAAAva,YACAA,cAEAlM,KAAAkQ,QAAAlD,GAGA2Z,EAAA3mB,KAAAkQ,QAAAlD,IAEAhN,KAAAkQ,QAAAlD,GAAAmB,KAAAjC,GAGAlM,KAAAkQ,QAAAlD,IAAAhN,KAAAkQ,QAAAlD,GAAAd,GANAlM,KAAAkQ,QAAAlD,GAAAd,EASAya,EAAA3mB,KAAAkQ,QAAAlD,MAAAhN,KAAAkQ,QAAAlD,GAAAsa,SAIA9mB,EAHAomB,EAAA5mB,KAAAwmB,eAGAD,EAAAM,oBAFA7mB,KAAAwmB,cAKAhmB,KAAA,GAAAR,KAAAkQ,QAAAlD,GAAAjH,OAAAvF,IACAR,KAAAkQ,QAAAlD,GAAAsa,QAAA,EACAC,QAAAnjB,MAAA,mIAGApE,KAAAkQ,QAAAlD,GAAAjH,QACA,kBAAAwhB,SAAAC,OAEAD,QAAAC,UAKAxnB,MAGAumB,EAAA9d,UAAAY,GAAAkd,EAAA9d,UAAAuD,YAEAua,EAAA9d,UAAArC,KAAA,SAAA4G,EAAAd,GAMA,QAAAub,KACAznB,KAAAyQ,eAAAzD,EAAAya,GAEAC,IACAA,GAAA,EACAxb,EAAAjD,MAAAjJ,KAAAkJ,YAVA,IAAAud,EAAAva,GACA,KAAA+a,WAAA,8BAEA,IAAAS,IAAA,CAcA,OAHAD,GAAAvb,WACAlM,KAAAqJ,GAAA2D,EAAAya,GAEAznB,MAIAumB,EAAA9d,UAAAgI,eAAA,SAAAzD,EAAAd,GACA,GAAAyb,GAAAC,EAAA7hB,EAAA6K,CAEA,KAAA6V,EAAAva,GACA,KAAA+a,WAAA,8BAEA,KAAAjnB,KAAAkQ,UAAAlQ,KAAAkQ,QAAAlD,GACA,MAAAhN,KAMA,IAJA2nB,EAAA3nB,KAAAkQ,QAAAlD,GACAjH,EAAA4hB,EAAA5hB,OACA6hB,GAAA,EAEAD,IAAAzb,GACAua,EAAAkB,EAAAzb,WAAAyb,EAAAzb,mBACAlM,MAAAkQ,QAAAlD,GACAhN,KAAAkQ,QAAAO,gBACAzQ,KAAA4I,KAAA,iBAAAoE,EAAAd,OAEG,IAAAya,EAAAgB,GAAA,CACH,IAAA/W,EAAA7K,EAAoB6K,KAAA,GACpB,GAAA+W,EAAA/W,KAAA1E,GACAyb,EAAA/W,GAAA1E,UAAAyb,EAAA/W,GAAA1E,aAAA,CACA0b,EAAAhX,CACA,OAIA,GAAAgX,EAAA,EACA,MAAA5nB,KAEA,KAAA2nB,EAAA5hB,QACA4hB,EAAA5hB,OAAA,QACA/F,MAAAkQ,QAAAlD,IAEA2a,EAAA/hB,OAAAgiB,EAAA,GAGA5nB,KAAAkQ,QAAAO,gBACAzQ,KAAA4I,KAAA,iBAAAoE,EAAAd,GAGA,MAAAlM,OAGAumB,EAAA9d,UAAAiI,mBAAA,SAAA1D,GACA,GAAAhH,GAAAoK,CAEA,KAAApQ,KAAAkQ,QACA,MAAAlQ,KAGA,KAAAA,KAAAkQ,QAAAO,eAKA,MAJA,KAAAvH,UAAAnD,OACA/F,KAAAkQ,WACAlQ,KAAAkQ,QAAAlD,UACAhN,MAAAkQ,QAAAlD,GACAhN,IAIA,QAAAkJ,UAAAnD,OAAA,CACA,IAAAC,IAAAhG,MAAAkQ,QACA,mBAAAlK,GACAhG,KAAA0Q,mBAAA1K,EAIA,OAFAhG,MAAA0Q,mBAAA,kBACA1Q,KAAAkQ,WACAlQ,KAKA,GAFAoQ,EAAApQ,KAAAkQ,QAAAlD,GAEAyZ,EAAArW,GACApQ,KAAAyQ,eAAAzD,EAAAoD,OACG,IAAAA,EAEH,KAAAA,EAAArK,QACA/F,KAAAyQ,eAAAzD,EAAAoD,IAAArK,OAAA,GAIA,cAFA/F,MAAAkQ,QAAAlD,GAEAhN,MAGAumB,EAAA9d,UAAA2H,UAAA,SAAApD,GACA,GAAA6a,EAOA,OAHAA,GAHA7nB,KAAAkQ,SAAAlQ,KAAAkQ,QAAAlD,GAEAyZ,EAAAzmB,KAAAkQ,QAAAlD,KACAhN,KAAAkQ,QAAAlD,IAEAhN,KAAAkQ,QAAAlD,GAAAF,YAIAyZ,EAAA9d,UAAAsI,cAAA,SAAA/D,GACA,GAAAhN,KAAAkQ,QAAA,CACA,GAAA4X,GAAA9nB,KAAAkQ,QAAAlD,EAEA,IAAAyZ,EAAAqB,GACA,QACA,IAAAA,EACA,MAAAA,GAAA/hB,OAEA,UAGAwgB,EAAAxV,cAAA,SAAAgX,EAAA/a,GACA,MAAA+a,GAAAhX,cAAA/D,KpBmiNM,SAAUnN,EAAQD,GqBtzNxB,QAAAkU,GAAAN,EAAAC,GACA,GAAA7C,GAAA6C,GAAA,EACAuU,EAAAC,CACA,OAAAD,GAAAxU,EAAA5C,MAAAoX,EAAAxU,EAAA5C,MACAoX,EAAAxU,EAAA5C,MAAAoX,EAAAxU,EAAA5C,MAAA,IACAoX,EAAAxU,EAAA5C,MAAAoX,EAAAxU,EAAA5C,MAAA,IACAoX,EAAAxU,EAAA5C,MAAAoX,EAAAxU,EAAA5C,MAAA,IACAoX,EAAAxU,EAAA5C,MAAAoX,EAAAxU,EAAA5C,MAAA,IACAoX,EAAAxU,EAAA5C,MAAAoX,EAAAxU,EAAA5C,MACAoX,EAAAxU,EAAA5C,MAAAoX,EAAAxU,EAAA5C,MACAoX,EAAAxU,EAAA5C,MAAAoX,EAAAxU,EAAA5C,MAdA,OADAqX,MACArX,EAAA,EAAeA,EAAA,MAASA,EACxBqX,EAAArX,MAAA,KAAAxE,SAAA,IAAA8b,OAAA,EAgBAroB,GAAAD,QAAAkU,GrBs0NM,SAAUjU,EAAQD,EAASM,GsBx1NjC,GAAA0T,GAEAuU,EAAA,OAAAA,QAAA,OAAAC,QACA,IAAAD,KAAAE,gBAAA,CAEA,GAAAC,GAAA,GAAAC,YAAA,GACA3U,GAAA,WAEA,MADAuU,GAAAE,gBAAAC,GACAA,GAIA,IAAA1U,EAAA,CAKA,GAAAF,GAAA,GAAAtM,OAAA,GACAwM,GAAA,WACA,OAAA4U,GAAA5X,EAAA,EAAsBA,EAAA,GAAQA,IAC9B,OAAAA,KAAA4X,EAAA,WAAAthB,KAAAyM,UACAD,EAAA9C,GAAA4X,MAAA,EAAA5X,IAAA,MAGA,OAAA8C,IAIA7T,EAAAD,QAAAgU","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! Kuzzle javascript SDK version 5.0.10 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  uuidv4 = __webpack_require__(6),\n\t  KuzzleEventEmitter = __webpack_require__(3),\n\t  Collection = __webpack_require__(7),\n\t  Security = __webpack_require__(17),\n\t  MemoryStorage = __webpack_require__(9),\n\t  User = __webpack_require__(5),\n\t  networkWrapper = __webpack_require__(13);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle object constructor.\n\t *\n\t * @constructor\n\t * @param host - Server name or IP Address to the Kuzzle instance\n\t * @param [options] - Connection options\n\t * @param {responseCallback} [cb] - Handles connection response\n\t */\n\tfunction Kuzzle (host, options, cb) {\n\t  var self = this;\n\t\n\t  if (!(this instanceof Kuzzle)) {\n\t    return new Kuzzle(host, options, cb);\n\t  }\n\t  KuzzleEventEmitter.call(this);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!host || host === '') {\n\t    throw new Error('host argument missing');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // 'private' properties\n\t    cleanHistoryTimer: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    collections: {\n\t      value: {},\n\t      writable: true\n\t    },\n\t    connectCB: {\n\t      value: cb\n\t    },\n\t    eventActions: {\n\t      value: [\n\t        'connected',\n\t        'networkError',\n\t        'disconnected',\n\t        'reconnected',\n\t        'tokenExpired',\n\t        'loginAttempt',\n\t        'offlineQueuePush',\n\t        'offlineQueuePop',\n\t        'queryError',\n\t        'discarded'\n\t      ],\n\t      writable: false\n\t    },\n\t    queuing: {\n\t      value: false,\n\t      writable: true\n\t    },\n\t    requestHistory: {\n\t      value: {},\n\t      writable: true\n\t    },\n\t    state: {\n\t      value: 'initializing',\n\t      writable: true\n\t    },\n\t    subscriptions: {\n\t      /*\n\t       Contains the centralized subscription list in the following format:\n\t          pending: {\n\t            subscriptionUid_1: kuzzleRoomInstance_1,\n\t            subscriptionUid_2: kuzzleRoomInstance_2,\n\t            subscriptionUid_...: kuzzleRoomInstance_...\n\t          },\n\t          'roomId': {\n\t            subscriptionUid_1: kuzzleRoomInstance_1,\n\t            subscriptionUid_2: kuzzleRoomInstance_2,\n\t            subscriptionUid_...: kuzzleRoomInstance_...\n\t          }\n\t\n\t       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n\t       This structure also allows renewing subscriptions after a connection loss\n\t       */\n\t      value: {\n\t        pending: {}\n\t      },\n\t      writable: true\n\t    },\n\t    // configuration properties\n\t    autoReconnect: {\n\t      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    defaultIndex: {\n\t      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    reconnectionDelay: {\n\t      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    host: {\n\t      value: host,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    port: {\n\t      value: (options && typeof options.port === 'number') ? options.port : 7512,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    sslConnection: {\n\t      value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    autoQueue: {\n\t      value: false,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    autoReplay: {\n\t      value: false,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    autoResubscribe: {\n\t      value: true,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    headers: {\n\t      value: {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    volatile: {\n\t      value: {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    /*\n\t      Offline queue use the following format:\n\t            [\n\t              {\n\t                ts: <query timestamp>,\n\t                query: 'query',\n\t                cb: callbackFunction\n\t              }\n\t            ]\n\t     */\n\t    offlineQueue: {\n\t      value: [],\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueFilter: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueMaxSize: {\n\t      value: 500,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueTTL: {\n\t      value: 120000,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    replayInterval: {\n\t      value: 10,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    jwtToken: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    offlineQueueLoader: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    sdkVersion: {\n\t      value: ( false) ? require('../package.json').version : (\"5.0.10\"),\n\t      writable: false\n\t    }\n\t  });\n\t\n\t  if (options) {\n\t    Object.keys(options).forEach(function (opt) {\n\t      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n\t        self[opt] = options[opt];\n\t      }\n\t    });\n\t\n\t    if (options.offlineMode === 'auto' && this.autoReconnect) {\n\t      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n\t    }\n\t  }\n\t\n\t  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n\t  Object.defineProperty(this, 'isValid', {\n\t    value: function () {\n\t      if (self.state === 'disconnected') {\n\t        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n\t      }\n\t    }\n\t  });\n\t\n\t  // Helper function copying headers to the query data\n\t  Object.defineProperty(this, 'addHeaders', {\n\t    value: function (query, headers) {\n\t      Object.keys(headers).forEach(function (header) {\n\t        if (!query[header]) {\n\t          query[header] = headers[header];\n\t        }\n\t      });\n\t\n\t      return query;\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n\t   * and is called by these methods\n\t   */\n\t  Object.defineProperty(this, 'callbackRequired', {\n\t    value: function (errorMessagePrefix, callback) {\n\t      if (!callback || typeof callback !== 'function') {\n\t        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Create an attribute security that embed all methods to manage Role, Profile and User\n\t   */\n\t  Object.defineProperty(this, 'security', {\n\t    value: new Security(this),\n\t    enumerable: true\n\t  });\n\t\n\t  Object.defineProperty(this, 'memoryStorage', {\n\t    value: new MemoryStorage(this),\n\t    enumerable: true\n\t  });\n\t\n\t  Object.defineProperties(this, {\n\t    eventTimeout: {\n\t      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200,\n\t      writeable: false\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'protectedEvents', {\n\t    value: {\n\t      connected: {timeout: this.eventTimeout},\n\t      error: {timeout: this.eventTimeout},\n\t      disconnected: {timeout: this.eventTimeout},\n\t      reconnected: {timeout: this.eventTimeout},\n\t      tokenExpired: {timeout: this.eventTimeout},\n\t      loginAttempt: {timeout: this.eventTimeout}\n\t    },\n\t    writeable: false\n\t  });\n\t\n\t  if (!options || !options.connect || options.connect === 'auto') {\n\t    this.connect();\n\t  } else {\n\t    this.state = 'ready';\n\t  }\n\t\n\t  this.cleanHistoryTimer = setInterval(function () { cleanHistory(self.requestHistory); }, 1000);\n\t\n\t  if (this.bluebird) {\n\t    return this.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n\t          'listCollections', 'createIndex', 'listIndexes', 'login', 'logout',\n\t          'now', 'query', 'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n\t          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n\t        ];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\tKuzzle.prototype = Object.create(KuzzleEventEmitter.prototype);\n\tKuzzle.prototype.constructor = Kuzzle;\n\t\n\t/**\n\t* Emit an event to all registered listeners\n\t* An event cannot be emitted multiple times before a timeout has been reached.\n\t*/\n\tKuzzle.prototype.emit = function(eventName) {\n\t  var\n\t    now = Date.now(),\n\t    protectedEvent = this.protectedEvents[eventName];\n\t\n\t  if (protectedEvent) {\n\t    if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n\t      return false;\n\t    }\n\t    protectedEvent.lastEmitted = now;\n\t  }\n\t  KuzzleEventEmitter.prototype.emit.apply(this, arguments);\n\t};\n\tKuzzle.prototype.emitEvent = Kuzzle.prototype.emit;\n\t\n\t/**\n\t * Connects to a Kuzzle instance using the provided host name.\n\t * @returns {Object} this\n\t */\n\tKuzzle.prototype.connect = function () {\n\t  var self = this;\n\t\n\t  if (self.network) {\n\t    self.disconnect();\n\t  }\n\t\n\t  self.network = networkWrapper(self.host, self.port, self.sslConnection);\n\t\n\t  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n\t    if (self.connectCB) {\n\t      self.connectCB(null, self);\n\t    }\n\t    return self;\n\t  }\n\t\n\t  self.state = 'connecting';\n\t  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\t\n\t  self.network.onConnect(function () {\n\t    self.state = 'connected';\n\t    renewAllSubscriptions.call(self);\n\t    dequeue.call(self);\n\t    self.emitEvent('connected');\n\t\n\t    if (self.connectCB) {\n\t      self.connectCB(null, self);\n\t    }\n\t  });\n\t\n\t  self.network.on('discarded', function (data) {\n\t    self.emitEvent('discarded', data);\n\t  });\n\t\n\t  self.network.onConnectError(function (error) {\n\t    var connectionError = new Error('Unable to connect to kuzzle proxy server at \"' + self.host + ':' + self.port + '\"');\n\t\n\t    connectionError.internal = error;\n\t    self.state = 'error';\n\t    self.emitEvent('networkError', connectionError);\n\t\n\t    disableAllSubscriptions.call(self);\n\t\n\t    if (self.connectCB) {\n\t      self.connectCB(connectionError);\n\t    }\n\t  });\n\t\n\t  self.network.onDisconnect(function () {\n\t    self.state = 'offline';\n\t\n\t    if (!self.autoReconnect) {\n\t      self.disconnect();\n\t    }\n\t\n\t    if (self.autoQueue) {\n\t      self.queuing = true;\n\t    }\n\t\n\t    self.emitEvent('disconnected');\n\t  });\n\t\n\t  self.network.onReconnect(function () {\n\t    var reconnect = function () {\n\t      // renew subscriptions\n\t      if (self.autoResubscribe) {\n\t        renewAllSubscriptions.call(self);\n\t      }\n\t\n\t      // replay queued requests\n\t      if (self.autoReplay) {\n\t        cleanQueue.call(self);\n\t        dequeue.call(self);\n\t      }\n\t\n\t      // alert listeners\n\t      self.emitEvent('reconnected');\n\t    };\n\t\n\t    self.state = 'connected';\n\t\n\t    if (self.jwtToken) {\n\t      self.checkToken(self.jwtToken, function (err, res) {\n\t        // shouldn't obtain an error but let's invalidate the token anyway\n\t        if (err || !res.valid) {\n\t          self.jwtToken = undefined;\n\t          self.emitEvent('tokenExpired');\n\t        }\n\t\n\t        reconnect();\n\t      });\n\t    } else {\n\t      reconnect();\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set the jwtToken used to query kuzzle\n\t * @param token\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.setJwtToken = function(token) {\n\t  if (typeof token === 'string') {\n\t    this.jwtToken = token;\n\t  } else if (typeof token === 'object') {\n\t    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n\t      this.jwtToken = token.result.jwt;\n\t    } else {\n\t      this.emitEvent('loginAttempt', {\n\t        success: false,\n\t        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n\t      });\n\t\n\t      return this;\n\t    }\n\t  } else {\n\t    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n\t    return this;\n\t  }\n\t\n\t  renewAllSubscriptions.call(this);\n\t  this.emitEvent('loginAttempt', {success: true});\n\t  return this;\n\t};\n\t\n\t/**\n\t * Unset the jwtToken used to query kuzzle\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.unsetJwtToken = function() {\n\t  this.jwtToken = undefined;\n\t\n\t  removeAllSubscriptions.call(this);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Get the jwtToken used by kuzzle\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.getJwtToken = function() {\n\t  return this.jwtToken;\n\t};\n\t\n\t/**\n\t * Send login request to kuzzle with credentials\n\t * If login success, store the jwtToken into kuzzle object\n\t *\n\t * @param strategy\n\t * @param credentials\n\t * @param expiresIn\n\t * @param cb\n\t */\n\tKuzzle.prototype.login = function (strategy) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      body: {},\n\t      strategy: strategy\n\t    },\n\t    cb = null;\n\t\n\t  if (!strategy || typeof strategy !== 'string') {\n\t    throw new Error('Kuzzle.login: strategy required');\n\t  }\n\t\n\t  // Handle arguments (credentials, expiresIn, cb)\n\t  if (arguments[1]) {\n\t    if (typeof arguments[1] === 'object') {\n\t      request.body = arguments[1];\n\t    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n\t      request.expiresIn = arguments[1];\n\t    } else if (typeof arguments[1] === 'function') {\n\t      cb = arguments[1];\n\t    }\n\t  }\n\t  if (arguments[2]) {\n\t    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n\t      request.expiresIn = arguments[2];\n\t    } else if (typeof arguments[2] === 'function') {\n\t      cb = arguments[2];\n\t    }\n\t  }\n\t  if (arguments[3] && typeof arguments[3] === 'function') {\n\t    cb = arguments[3];\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'login'}, request, {queuable: false}, function(error, response) {\n\t    if (!error) {\n\t      if (response.result.jwt) {\n\t        self.setJwtToken(response.result.jwt);\n\t      }\n\t\n\t      cb && cb(null, response.result);\n\t    }\n\t    else {\n\t      cb && cb(error);\n\t      self.emitEvent('loginAttempt', {success: false, error: error.message});\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Create credentials of the specified <strategy> for the current user.\n\t *\n\t * @param credentials\n\t * @param strategy\n\t * @param options\n\t * @param cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.createMyCredentials = function (strategy, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'createMyCredentials'}, {strategy: strategy, body: credentials}, options, function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result._source);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete credentials of the specified <strategy> for the current user.\n\t *\n\t * @param strategy\n\t * @param options\n\t * @param cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.deleteMyCredentials = function (strategy, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'deleteMyCredentials'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Get credential information of the specified <strategy> for the current user.\n\t *\n\t * @param strategy\n\t * @param options\n\t * @param cb\n\t */\n\tKuzzle.prototype.getMyCredentials = function (strategy, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'getMyCredentials'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Update credentials of the specified <strategy> for the current user.\n\t *\n\t * @param strategy\n\t * @param credentals\n\t * @param options\n\t * @param cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.updateMyCredentials = function (strategy, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'updateMyCredentials'}, {strategy: strategy, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Validate credentials of the specified <strategy> for the current user.\n\t *\n\t * @param strategy\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t */\n\tKuzzle.prototype.validateMyCredentials = function (strategy, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'validateMyCredentials'}, {strategy: strategy, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Create a kuzzle index\n\t *\n\t * @param {string} index\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.createIndex = function (index, options, cb) {\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.createIndex: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.query({controller: 'index', action: 'create', index: index}, {}, options, typeof cb !== 'function' ? null : function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Send logout request to kuzzle with jwtToken.\n\t *\n\t * @param cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.logout = function (cb) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      action: 'logout',\n\t      controller: 'auth',\n\t      requestId: uuidv4(),\n\t      body: {}\n\t    };\n\t\n\t  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, typeof cb !== 'function' ? null : function(error) {\n\t    cb(error, self);\n\t  });\n\t\n\t  self.unsetJwtToken();\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Checks whether a given jwt token still represents a valid session in Kuzzle.\n\t *\n\t * @param  {string}   token     The jwt token to check\n\t * @param  {function} cb  The callback to be called when the response is\n\t *                              available. The signature is `function(error, response)`.\n\t */\n\tKuzzle.prototype.checkToken = function (token, cb) {\n\t  var\n\t    request = {\n\t      body: {\n\t        token: token\n\t      }\n\t    };\n\t\n\t  this.callbackRequired('Kuzzle.checkToken', cb);\n\t\n\t  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Fetches the current user.\n\t *\n\t * @param  {function} cb  The callback to be called when the response is\n\t *                              available. The signature is `function(error, response)`.\n\t */\n\tKuzzle.prototype.whoAmI = function (cb) {\n\t  var self = this;\n\t\n\t  self.callbackRequired('Kuzzle.whoAmI', cb);\n\t\n\t  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, res) {\n\t    cb(err, err ? undefined : new User(self.security, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Gets the rights array of the currently logged user.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param  {function} cb The callback containing the normalized array of rights.\n\t */\n\tKuzzle.prototype.getMyRights = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.callbackRequired('Kuzzle.getMyRights', cb);\n\t\n\t  self.query({controller: 'auth', action:'getMyRights'}, {}, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Update current user in Kuzzle.\n\t *\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Kuzzle} this object\n\t */\n\tKuzzle.prototype.updateSelf = function (content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data.body = content;\n\t\n\t  self.query(queryArgs, data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n\t */\n\tfunction cleanQueue () {\n\t  var\n\t    self = this,\n\t    now = Date.now(),\n\t    lastDocumentIndex = -1;\n\t\n\t  if (self.queueTTL > 0) {\n\t    self.offlineQueue.forEach(function (query, index) {\n\t      if (query.ts < now - self.queueTTL) {\n\t        lastDocumentIndex = index;\n\t      }\n\t    });\n\t\n\t    if (lastDocumentIndex !== -1) {\n\t      self.offlineQueue\n\t        .splice(0, lastDocumentIndex + 1)\n\t        .forEach(function (droppedRequest) {\n\t          self.emitEvent('offlineQueuePop', droppedRequest.query);\n\t        });\n\t    }\n\t  }\n\t\n\t  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n\t    self.offlineQueue\n\t      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n\t      .forEach(function (droppedRequest) {\n\t        self.emitEvent('offlineQueuePop', droppedRequest.query);\n\t      });\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Clean history from requests made more than 10s ago\n\t */\n\tfunction cleanHistory (requestHistory) {\n\t  var\n\t    now = Date.now();\n\t\n\t  Object.keys(requestHistory).forEach(function (key) {\n\t    if (requestHistory[key] < now - 10000) {\n\t      delete requestHistory[key];\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Emit a request to Kuzzle\n\t *\n\t * @param {object} request\n\t * @param {responseCallback} [cb]\n\t */\n\tfunction emitRequest (request, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (self.jwtToken !== undefined || cb) {\n\t    self.network.once(request.requestId, function (response) {\n\t      var error = null;\n\t\n\t      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n\t        self.jwtToken = undefined;\n\t        self.emitEvent('tokenExpired', request, cb);\n\t      }\n\t\n\t      if (response.error) {\n\t        error = new Error(response.error.message);\n\t        Object.assign(error, response.error);\n\t        error.status = response.status;\n\t        self.emitEvent('queryError', error, request, cb);\n\t      }\n\t\n\t      if (cb) {\n\t        cb(error, response);\n\t      }\n\t    });\n\t  }\n\t\n\t  this.network.send(request);\n\t\n\t  // Track requests made to allow Room.subscribeToSelf to work\n\t  self.requestHistory[request.requestId] = Date.now();\n\t}\n\t\n\t/**\n\t * Play all queued requests, in order.\n\t */\n\tfunction dequeue () {\n\t  var\n\t    self = this,\n\t    additionalQueue,\n\t    uniqueQueue = {},\n\t    dequeuingProcess = function () {\n\t      if (self.offlineQueue.length > 0) {\n\t        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n\t        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\t\n\t        setTimeout(function () {\n\t          dequeuingProcess();\n\t        }, Math.max(0, self.replayInterval));\n\t      } else {\n\t        self.queuing = false;\n\t      }\n\t    };\n\t\n\t  if (self.offlineQueueLoader) {\n\t    if (typeof self.offlineQueueLoader !== 'function') {\n\t      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n\t    }\n\t\n\t    additionalQueue = self.offlineQueueLoader();\n\t    if (Array.isArray(additionalQueue)) {\n\t      self.offlineQueue = additionalQueue\n\t        .concat(self.offlineQueue)\n\t        .filter(function (request) {\n\t          // throws if the query object does not contain required attributes\n\t          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n\t            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n\t          }\n\t\n\t          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n\t        });\n\t    } else {\n\t      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n\t    }\n\t  }\n\t\n\t  dequeuingProcess();\n\t}\n\t\n\t/**\n\t * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n\t * successful login attempt\n\t */\n\tfunction renewAllSubscriptions() {\n\t  var self = this;\n\t\n\t  Object.keys(self.subscriptions).forEach(function (roomId) {\n\t    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n\t      var subscription = self.subscriptions[roomId][subscriptionId];\n\t      subscription.renew(subscription.callback);\n\t    });\n\t  });\n\t}\n\t\n\t/**\n\t * Remove all registered subscriptions. Triggered either by a logout query or by un-setting the token\n\t */\n\tfunction removeAllSubscriptions() {\n\t  var self = this;\n\t\n\t  Object.keys(self.subscriptions).forEach(function (roomId) {\n\t    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n\t      var subscription = self.subscriptions[roomId][subscriptionId];\n\t      subscription.unsubscribe();\n\t    });\n\t  });\n\t}\n\t\n\t/**\n\t * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n\t * insertion.\n\t *\n\t * @param {string} event - name of the global event to subscribe to\n\t * @param {function} listener - callback to invoke each time an event is fired\n\t */\n\tKuzzle.prototype.addListener = function(event, listener) {\n\t  this.isValid();\n\t\n\t  if (this.eventActions.indexOf(event) === -1) {\n\t    throw new Error('[' + event + '] is not a known event. Known events: ' + this.eventActions.toString());\n\t  }\n\t\n\t  return KuzzleEventEmitter.prototype.addListener.call(this, event, listener);\n\t};\n\t\n\t/**\n\t * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t * This method returns all available statistics from Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getAllStatistics = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\t\n\t  this.query({controller:'server', action: 'getAllStats'}, {}, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n\t *\n\t * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n\t  var\n\t    queryCB,\n\t    body;\n\t\n\t  if (!cb) {\n\t    if (arguments.length === 1) {\n\t      cb = arguments[0];\n\t      options = null;\n\t      timestamp = null;\n\t    } else {\n\t      cb = arguments[1];\n\t      if (typeof arguments[0] === 'object') {\n\t        options = arguments[0];\n\t        timestamp = null;\n\t      } else {\n\t        timestamp = arguments[0];\n\t        options = null;\n\t      }\n\t    }\n\t  }\n\t\n\t  queryCB = function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, timestamp ? res.result.hits : [res.result]);\n\t  };\n\t\n\t  this.callbackRequired('Kuzzle.getStatistics', cb);\n\t\n\t  body = timestamp ? {body: {startTime: timestamp}} : {};\n\t  this.query({controller: 'server', action: timestamp ? 'getStats' : 'getLastStats'}, body, options, queryCB);\n\t};\n\t\n\t/**\n\t * Create a new instance of a Collection object.\n\t * If no index is specified, takes the default index.\n\t *\n\t * @param {string} collection - The name of the data collection you want to manipulate\n\t * @param {string} [index] - The name of the data index containing the data collection\n\t * @returns {Collection} A Collection instance\n\t */\n\tKuzzle.prototype.collection = function(collection, index) {\n\t  this.isValid();\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Unable to create a new data collection object: no index specified');\n\t    }\n\t\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (typeof index !== 'string' || typeof collection !== 'string') {\n\t    throw new Error('Invalid index or collection argument: string expected');\n\t  }\n\t\n\t  if (!this.collections[index]) {\n\t    this.collections[index] = {};\n\t  }\n\t\n\t  if (!this.collections[index][collection]) {\n\t    this.collections[index][collection] = new Collection(this, collection, index);\n\t  }\n\t\n\t  return this.collections[index][collection];\n\t};\n\t\n\t/**\n\t * Empties the offline queue without replaying it.\n\t *\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.flushQueue = function () {\n\t  this.offlineQueue = [];\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns the list of known persisted data collections.\n\t *\n\t * @param {string} [index] - Index containing collections to be listed\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.listCollections = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb,\n\t    args = Array.prototype.slice.call(arguments),\n\t    query;\n\t\n\t  args.forEach(function(arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.listCollections: index required');\n\t    }\n\t\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.listCollections', cb);\n\t\n\t  query = {type: options && options.type || 'all'};\n\t\n\t  this.query({index: index, controller: 'collection', action: 'list'}, query, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.collections);\n\t  });\n\t};\n\t\n\t/**\n\t * Returns the list of existing indexes in Kuzzle\n\t *\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.listIndexes = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.listIndexes', cb);\n\t\n\t  this.query({controller: 'index', action: 'list'}, {}, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.indexes);\n\t  });\n\t};\n\t\n\t/**\n\t * Disconnects from Kuzzle and invalidate this instance.\n\t */\n\tKuzzle.prototype.disconnect = function () {\n\t  var collection;\n\t\n\t  clearInterval(this.cleanHistoryTimer);\n\t  this.state = 'disconnected';\n\t  this.network.close();\n\t  this.network = null;\n\t\n\t  for (collection in this.collections) {\n\t    if (this.collections.hasOwnProperty(collection)) {\n\t      delete this.collections[collection];\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Returns the server informations\n\t *\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getServerInfo = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\t\n\t  this.query({controller: 'server', action: 'info'}, {}, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.serverInfo);\n\t  });\n\t};\n\t\n\t/**\n\t * Forces an index refresh\n\t *\n\t * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n\t * @param {object} options - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.refreshIndex = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function(arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.refreshIndex: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.query({ index: index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns de current autoRefresh status for the given index\n\t *\n\t * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n\t * @param {object} options - Optinal arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getAutoRefresh = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function (arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.getAutoRefresh: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n\t  this.query({ index: index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n\t};\n\t\n\t/**\n\t * (Un)Sets the autoRefresh flag on the given index\n\t *\n\t * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n\t * @param {boolean} autoRefresh - The autoRefresh value to set\n\t * @param {object} options - Optional arguments\n\t * @param {responseCallback} cb - Handles the query result\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.setAutoRefresh = function () {\n\t  var\n\t    index,\n\t    autoRefresh,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function (arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'boolean':\n\t        autoRefresh = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.setAutoRefresh: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (autoRefresh === undefined) {\n\t    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n\t  }\n\t\n\t  this.query({ index: index, controller: 'index', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return the current Kuzzle's UTC Epoch time, in milliseconds\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.now = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.now', cb);\n\t\n\t  this.query({controller: 'server', action: 'now'}, {}, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.now);\n\t  });\n\t};\n\t\n\t/**\n\t * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n\t * Base method used to send read queries to Kuzzle\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} queryArgs - Query configuration\n\t * @param {object} query - The query data\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n\t  var\n\t    attr,\n\t    object = {\n\t      action: queryArgs.action,\n\t      controller: queryArgs.controller,\n\t      volatile: this.volatile\n\t    },\n\t    self = this;\n\t\n\t  this.isValid();\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options) {\n\t    if (options.queuable === false && self.state === 'offline') {\n\t      return self;\n\t    }\n\t\n\t    if (options.refresh) {\n\t      object.refresh = options.refresh;\n\t    }\n\t\n\t    if (typeof options.from !== 'undefined' && options.from !== null) {\n\t      object.from = options.from;\n\t    }\n\t\n\t    if (options.size) {\n\t      object.size = options.size;\n\t    }\n\t\n\t    if (options.scroll) {\n\t      object.scroll = options.scroll;\n\t    }\n\t\n\t    if (options.scrollId) {\n\t      object.scrollId = options.scrollId;\n\t    }\n\t\n\t    if (options.volatile) {\n\t      Object.keys(options.volatile).forEach(function (meta) {\n\t        object.volatile[meta] = options.volatile[meta];\n\t      });\n\t    }\n\t  }\n\t\n\t  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n\t    throw new Error('Invalid query parameter: ' + query);\n\t  }\n\t\n\t  if (query.volatile) {\n\t    Object.keys(query.volatile).forEach(function (meta) {\n\t      object.volatile[meta] = query.volatile[meta];\n\t    });\n\t  }\n\t\n\t  for (attr in query) {\n\t    if (attr !== 'volatile' && query.hasOwnProperty(attr)) {\n\t      object[attr] = query[attr];\n\t    }\n\t  }\n\t\n\t  object = self.addHeaders(object, this.headers);\n\t\n\t  /*\n\t   * Do not add the token for the checkToken route, to avoid getting a token error when\n\t   * a developer simply wish to verify his token\n\t   */\n\t  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n\t    object.jwt = self.jwtToken;\n\t  }\n\t\n\t  if (queryArgs.collection) {\n\t    object.collection = queryArgs.collection;\n\t  }\n\t\n\t  if (queryArgs.index) {\n\t    object.index = queryArgs.index;\n\t  }\n\t\n\t  if (!object.requestId) {\n\t    object.requestId = uuidv4();\n\t  }\n\t\n\t  object.volatile.sdkVersion = this.sdkVersion;\n\t\n\t  if (self.state === 'connected' || (options && options.queuable === false)) {\n\t    if (self.state === 'connected') {\n\t      emitRequest.call(this, object, cb);\n\t    } else {\n\t      discardRequest(object, cb);\n\t    }\n\t  } else if (self.queuing || (options && options.queuable === true) || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n\t    cleanQueue.call(this, object, cb);\n\t    if (!self.queueFilter || self.queueFilter(object)) {\n\t      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n\t      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n\t    } else {\n\t      discardRequest(object, cb);\n\t    }\n\t  }\n\t  else {\n\t    discardRequest(object, cb);\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Replays the requests queued during offline mode.\n\t * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n\t */\n\tKuzzle.prototype.replayQueue = function () {\n\t  if (this.state !== 'offline' && !this.autoReplay) {\n\t    cleanQueue.call(this);\n\t    dequeue.call(this);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the default Kuzzle index\n\t *\n\t * @param index\n\t * @returns this\n\t */\n\tKuzzle.prototype.setDefaultIndex = function (index) {\n\t  if (typeof index !== 'string') {\n\t    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n\t  }\n\t\n\t  if (index.length === 0) {\n\t    throw new Error('Cannot set an empty index as the default index');\n\t  }\n\t\n\t  this.defaultIndex = index;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzle.prototype.setHeaders = function (content, replace) {\n\t  var self = this;\n\t\n\t  if (typeof content !== 'object' || Array.isArray(content)) {\n\t    throw new Error('Expected a content object, received a ' + typeof content);\n\t  }\n\t\n\t  if (replace) {\n\t    self.headers = content;\n\t  } else {\n\t    Object.keys(content).forEach(function (key) {\n\t      self.headers[key] = content[key];\n\t    });\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t */\n\tKuzzle.prototype.startQueuing = function () {\n\t  if (this.state === 'offline' && !this.autoQueue) {\n\t    this.queuing = true;\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t */\n\tKuzzle.prototype.stopQueuing = function () {\n\t  if (this.state === 'offline' && !this.autoQueue) {\n\t    this.queuing = false;\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tfunction discardRequest(object, cb) {\n\t  if (cb) {\n\t    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n\t  }\n\t}\n\t\n\tfunction disableAllSubscriptions() {\n\t  var self = this;\n\t\n\t  Object.keys(self.subscriptions).forEach(function (roomId) {\n\t    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n\t      var subscription = self.subscriptions[roomId][subscriptionId];\n\t      subscription.subscribing = false;\n\t    });\n\t  });\n\t}\n\t\n\tmodule.exports = Kuzzle;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\tfunction SecurityDocument(Security, id, content, meta) {\n\t\n\t  if (!id) {\n\t    throw new Error('A security document must have an id');\n\t  }\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    kuzzle: {\n\t      value: Security.kuzzle\n\t    },\n\t    Security: {\n\t      value: Security\n\t    },\n\t    // read-only properties\n\t    // writable properties\n\t    id: {\n\t      value: id,\n\t      enumerable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    meta: {\n\t      value: meta || {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (content) {\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'update'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function won’t be applied until the save method is called.\n\t *\n\t * @param {Object} data - New securityDocument content\n\t * @return {SecurityDocument} this\n\t */\n\tSecurityDocument.prototype.setContent = function (data) {\n\t  this.content = data;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a pojo\n\t *\n\t * @return {object} pojo representing this securityDocument\n\t */\n\tSecurityDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Delete the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tSecurityDocument.prototype.delete = function (options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, res.result._id);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Update the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} content - Content to add to KuzzleSecurityDocument\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {SecurityDocument} this\n\t */\n\tSecurityDocument.prototype.update = function (content, options, cb) {\n\t  var\n\t    data = {},\n\t    self = this;\n\t\n\t  if (typeof content !== 'object') {\n\t    throw new Error('Parameter \"content\" must be a object');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = self.id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    self.setContent(response.result._source);\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = SecurityDocument;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle handles documents either as realtime messages or as stored documents.\n\t * Document is the object representation of one of these documents.\n\t *\n\t * Notes:\n\t *   - this constructor may be called either with a documentId, a content, neither or both.\n\t *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n\t *\n\t *\n\t * @param {Collection} collection - an instanciated Collection object\n\t * @param {string} [documentId] - ID of an existing document\n\t * @param {object} [content] - Initializes this document with the provided content\n\t * @param {object} [meta] - Initializes this document with the provided meta\n\t * @constructor\n\t */\n\tfunction Document(collection, documentId, content, meta) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection.collection,\n\t      enumerable: true\n\t    },\n\t    dataCollection: {\n\t      value: collection,\n\t      enumerable: false\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: false\n\t    },\n\t    // writable properties\n\t    id: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(collection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    version: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    meta: {\n\t      value: meta || {},\n\t      enumerable: true,\n\t      writable: false\n\t    }\n\t  });\n\t\n\t  // handling provided arguments\n\t  if (!content && documentId && typeof documentId === 'object') {\n\t    content = documentId;\n\t    documentId = null;\n\t  }\n\t\n\t  if (content) {\n\t    if (content._version) {\n\t      this.version = content._version;\n\t      delete content._version;\n\t    }\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  if (documentId) {\n\t    Object.defineProperty(this, 'id', {\n\t      value: documentId,\n\t      enumerable: true\n\t    });\n\t  }\n\t\n\t  // promisifying\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'refresh', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this document\n\t */\n\tDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  if (this.version) {\n\t    data._version = this.version;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Overrides the toString() method in order to return a serialized version of the document\n\t *\n\t * @return {string} serialized version of this object\n\t */\n\tDocument.prototype.toString = function () {\n\t  return JSON.stringify(this.serialize());\n\t};\n\t\n\t/**\n\t * Deletes this document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.delete = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.delete: cannot delete a document without a document ID');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n\t    cb(err, err ? undefined : self.id);\n\t  });\n\t};\n\t\n\t/**\n\t * Checks if this document exists in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.exists = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Replaces the current content with the last version of this document stored in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.refresh = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Document.refresh', cb);\n\t\n\t  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n\t    var newDocument;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n\t    newDocument.version = res.result._version;\n\t\n\t    cb(null, newDocument);\n\t  });\n\t};\n\t\n\t/**\n\t * Saves this document into Kuzzle.\n\t *\n\t * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n\t * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n\t    if (error) {\n\t      return cb && cb(error);\n\t    }\n\t\n\t    self.id = res.result._id;\n\t    self.version = res.result._version;\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Sends the content of this document as a realtime message.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @returns {*} this\n\t */\n\tDocument.prototype.publish = function (options) {\n\t  var data = this.serialize();\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function won’t be applied until the save method is called.\n\t *\n\t * @param {object} data - New content\n\t * @param {boolean} replace - if true: replace this document content with the provided data\n\t */\n\tDocument.prototype.setContent = function (data, replace) {\n\t  var self = this;\n\t\n\t  if (replace) {\n\t    this.content = data;\n\t  }\n\t  else {\n\t    Object.keys(data).forEach(function (key) {\n\t      self.content[key] = data[key];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Listens to events concerning this document. Has no effect if the document does not have an ID\n\t * (i.e. if the document has not yet been created as a persisted document).\n\t *\n\t * @param {object} [options] - subscription options\n\t * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n\t */\n\tDocument.prototype.subscribe = function (options, cb) {\n\t  var filters;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\t\n\t  if (!this.id) {\n\t    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n\t  }\n\t\n\t  filters = { ids: { values: [this.id] } };\n\t\n\t  return this.dataCollection.subscribe(filters, options, cb);\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tDocument.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\t\n\tmodule.exports = Document;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tfunction KuzzleEventEmitter() {\n\t  if (typeof window !== 'undefined') {\n\t    this._events = {};\n\t    this._onceEvents = {};\n\t  }\n\t}\n\t\n\tif (typeof window === 'undefined') {\n\t  KuzzleEventEmitter.prototype = __webpack_require__(18).prototype;\n\t  KuzzleEventEmitter.prototype.constructor = KuzzleEventEmitter;\n\t} else {\n\t\n\t  KuzzleEventEmitter.prototype.on = function(eventName, listener) {\n\t    var\n\t      listenerType = typeof listener,\n\t      listeners;\n\t\n\t    if (!eventName || !listener) {\n\t      return;\n\t    }\n\t\n\t    if (listenerType !== 'function') {\n\t      throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n\t    }\n\t\n\t    listeners = this.listeners(eventName);\n\t    // only add once\n\t    if (listeners.indexOf(listener) === -1) {\n\t      listeners.push(listener);\n\t    }\n\t\n\t    // Handles `newListener` event (see https://nodejs.org/api/events.html#events_event_newlistener)\n\t    this.emit('newListener', eventName, listener);\n\t\n\t    return this;\n\t  };\n\t  KuzzleEventEmitter.prototype.addListener = KuzzleEventEmitter.prototype.on;\n\t\n\t  KuzzleEventEmitter.prototype.prependListener = function(eventName, listener) {\n\t    var listeners;\n\t\n\t    if (!eventName || !listener) {\n\t      return;\n\t    }\n\t\n\t    listeners = this.listeners(eventName);\n\t    // only add once\n\t    if (listeners.indexOf(listener) === -1) {\n\t      this._events[eventName] = new Array(listener).concat(listeners);\n\t    }\n\t\n\t    // Handles `newListener` event (see https://nodejs.org/api/events.html#events_event_newlistener)\n\t    this.emit('newListener', eventName, listener);\n\t\n\t    return this;\n\t  };\n\t\n\t  KuzzleEventEmitter.prototype.once = function(eventName, listener) {\n\t    var onceListeners;\n\t\n\t    if (!eventName || !listener) {\n\t      return;\n\t    }\n\t\n\t\n\t    this.on(eventName, listener);\n\t    onceListeners = this._onceEvents[eventName] = this._onceEvents[eventName] || {};\n\t    onceListeners[listener] = true;\n\t\n\t    return this;\n\t  };\n\t\n\t  KuzzleEventEmitter.prototype.prependOnceListener = function(eventName, listener) {\n\t    var onceListeners;\n\t\n\t    if (!eventName || !listener) {\n\t      return;\n\t    }\n\t    this.prependListener(eventName, listener);\n\t    onceListeners = this._onceEvents[eventName] = this._onceEvents[eventName] || {};\n\t    onceListeners[listener] = true;\n\t\n\t    return this;\n\t  };\n\t\n\t  KuzzleEventEmitter.prototype.removeListener = function(eventName, listener) {\n\t    var\n\t      index,\n\t      listeners = this._events[eventName];\n\t\n\t    if (!listeners || !listeners.length) {\n\t      return;\n\t    }\n\t\n\t    index = listeners.indexOf(listener);\n\t    if (index !== -1) {\n\t      listeners.splice(index, 1);\n\t    }\n\t    if (listeners.length === 0) {\n\t      delete this._events[eventName];\n\t    }\n\t\n\t    // Handles `removeListener` event (see https://nodejs.org/api/events.html#events_event_removeListener)\n\t    this.emit('removeListener', eventName, listener);\n\t\n\t    return this;\n\t  };\n\t\n\t  KuzzleEventEmitter.prototype.removeAllListeners = function(eventName) {\n\t    if (eventName) {\n\t      delete this._events[eventName];\n\t      delete this._onceEvents[eventName];\n\t    } else {\n\t      this._events = [];\n\t      this._onceEvents = [];\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  KuzzleEventEmitter.prototype.emit = function(eventName) {\n\t    var\n\t      i = 0,\n\t      listeners,\n\t      args,\n\t      onceListeners,\n\t      notifyList;\n\t\n\t    listeners = this._events && this._events[eventName];\n\t\n\t    if (!listeners || !listeners.length) {\n\t      return;\n\t    }\n\t\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    // once stuff\n\t    onceListeners = this._onceEvents && this._onceEvents[eventName] || {};\n\t\n\t    notifyList = new Array();\n\t\n\t    listener = listeners[i];\n\t    while (listener) {\n\t      // trigger listener\n\t      notifyList.push(listener);\n\t      // get next listener\n\t      if (onceListeners[listener]) {\n\t        // remove listener\n\t        this.removeListener(eventName,listener);\n\t        // unset once flag\n\t        delete onceListeners[listener];\n\t      } else {\n\t        i++;\n\t      }\n\t      listener = listeners[i];\n\t    }\n\t    for (item in notifyList) {\n\t      // trigger listener\n\t      if (notifyList[item] !== undefined) {\n\t        notifyList[item].apply(this, args);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  KuzzleEventEmitter.prototype.eventNames = function () {\n\t    return Object.keys(this._events);\n\t  };\n\t\n\t  KuzzleEventEmitter.prototype.listenerCount = function (eventName) {\n\t    return this._events[eventName] && this._events[eventName].length || 0;\n\t  };\n\t\n\t  KuzzleEventEmitter.prototype.listeners = function (eventName) {\n\t    if (this._events[eventName] === undefined) {\n\t      this._events[eventName] = [];\n\t    }\n\t    return this._events[eventName];\n\t  };\n\t\n\t}\n\t// Aliases:\n\tKuzzleEventEmitter.prototype.emitEvent = KuzzleEventEmitter.prototype.emit;\n\tKuzzleEventEmitter.prototype.off = KuzzleEventEmitter.prototype.removeListener;\n\t\n\tmodule.exports = KuzzleEventEmitter;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleEventEmitter = __webpack_require__(3);\n\t\n\tfunction WSNode(host, port, ssl) {\n\t  var self = this;\n\t  KuzzleEventEmitter.call(this);\n\t\n\t  this.WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"ws\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t  this.host = host;\n\t  this.port = port;\n\t  this.ssl = ssl;\n\t  this.client = null;\n\t  this.wasConnected = false;\n\t  this.retrying = false;\n\t  this.lasturl = null;\n\t  this.stopRetryingToConnect = false;\n\t\n\t  /**\n\t   * Creates a new socket from the provided arguments\n\t   *\n\t   * @constructor\n\t   * @param {boolean} autoReconnect\n\t   * @param {int} reconnectionDelay\n\t   * @returns {Object} Socket\n\t   */\n\t  this.connect = function (autoReconnect, reconnectionDelay) {\n\t    var\n\t      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n\t      options = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\t\n\t    if (url !== this.lasturl) {\n\t      self.wasConnected = false;\n\t      this.lasturl = url;\n\t    }\n\t\n\t    this.client = new this.WebSocket(url, options);\n\t\n\t    this.client.onopen = function () {\n\t      if (self.wasConnected) {\n\t        self.emitEvent('reconnect');\n\t      }\n\t      else {\n\t        self.emitEvent('connect');\n\t      }\n\t      self.wasConnected = true;\n\t      self.stopRetryingToConnect = false;\n\t    };\n\t\n\t    this.client.onclose = function (closeEvent, message) {\n\t      var error;\n\t      var status;\n\t      var reason = message;\n\t\n\t      if (typeof closeEvent === 'number') {\n\t        status = closeEvent;\n\t      }\n\t      else {\n\t        status = closeEvent.code;\n\t\n\t        if (closeEvent.reason) {\n\t          reason = closeEvent.reason;\n\t        }\n\t      }\n\t\n\t      if (status === 1000) {\n\t        self.emitEvent('disconnect');\n\t      }\n\t      else {\n\t        error = new Error(reason);\n\t        error.status = status;\n\t\n\t        onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n\t      }\n\t    };\n\t\n\t    this.client.onerror = function (error) {\n\t      if (!(error instanceof Error)) {\n\t        error = new Error(error);\n\t      }\n\t\n\t      onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n\t    };\n\t\n\t    this.client.onmessage = function (payload) {\n\t      var data = JSON.parse(payload.data || payload);\n\t\n\t      if (data.room) {\n\t        self.emitEvent(data.room, data);\n\t      }\n\t      else {\n\t        self.emitEvent('discarded', data);\n\t      }\n\t    };\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whence a connection is established\n\t   *\n\t   * @param {function} callback\n\t   */\n\t  this.onConnect = function (callback) {\n\t    this.addListener('connect', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection error is received\n\t   * @param {function} callback\n\t   */\n\t  this.onConnectError = function (callback) {\n\t    this.addListener('networkError', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a disconnection occurred\n\t   * @param {function} callback\n\t   */\n\t  this.onDisconnect = function (callback) {\n\t    this.addListener('disconnect', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection has been reestablished\n\t   * @param {function} callback\n\t   */\n\t  this.onReconnect = function (callback) {\n\t    this.addListener('reconnect', callback);\n\t  };\n\t\n\t  /**\n\t   * Sends a payload to the connected server\n\t   *\n\t   * @param {Object} payload\n\t   */\n\t  this.send = function (payload) {\n\t    if (this.client && this.client.readyState === this.client.OPEN) {\n\t      this.client.send(JSON.stringify(payload));\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Closes the connection\n\t   */\n\t  this.close = function () {\n\t    this.removeAllListeners();\n\t    this.wasConnected = false;\n\t    this.client.close();\n\t    this.client = null;\n\t    self.stopRetryingToConnect = true;\n\t  };\n\t}\n\tWSNode.prototype = Object.create(KuzzleEventEmitter.prototype);\n\tWSNode.prototype.constructor = WSNode;\n\t\n\t\n\t/**\n\t * Called when the connection closes with an error state\n\t *\n\t * @param {WSNode} \n\t * @param {boolean} autoReconnect\n\t * @param {number} reconnectionDelay\n\t * @param {Error} error\n\t */\n\tfunction onClientNetworkError(ws, autoReconnect, reconnectionDelay, error) {\n\t  if (autoReconnect && !ws.retrying && !ws.stopRetryingToConnect) {\n\t    ws.retrying = true;\n\t    setTimeout(function () {\n\t      ws.retrying = false;\n\t      ws.connect(autoReconnect, reconnectionDelay);\n\t    }, reconnectionDelay);\n\t  }\n\t\n\t  ws.emitEvent('networkError', error);\n\t}\n\t\n\tmodule.exports = WSNode;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\t/**\n\t * @param {Security} Security\n\t * @param {string} id\n\t * @param {Object} content\n\t * @constructor\n\t */\n\tfunction User(Security, id, content, meta) {\n\t  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteUser'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateUser'\n\t    },\n\t    credentials: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: User\n\t  }\n\t});\n\t\n\t/**\n\t * Set profiles in content\n\t * @param {array} profileIds - an array of profiles ids string\n\t *\n\t * @returns {User} this\n\t */\n\tUser.prototype.setProfiles = function (profileIds) {\n\t  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n\t    throw new Error('Parameter \"profileIds\" must be an array of strings');\n\t  }\n\t\n\t  this.content.profileIds = profileIds;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {object} credentials\n\t */\n\tUser.prototype.setCredentials = function (credentials) {\n\t  if (typeof credentials !== 'object') {\n\t    throw new Error('Parameter \"credentials\" must be a object');\n\t  }\n\t\n\t  this.credentials = credentials;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a profile\n\t * @param {string} profileId - a profile ids string\n\t *\n\t * @returns {User} this\n\t */\n\tUser.prototype.addProfile = function (profileId) {\n\t  if (typeof profileId !== 'string') {\n\t    throw new Error('Parameter \"profileId\" must be a string');\n\t  }\n\t\n\t  if (!this.content.profileIds) {\n\t    this.content.profileIds = [];\n\t  }\n\t\n\t  if (this.content.profileIds.indexOf(profileId) === -1) {\n\t    this.content.profileIds.push(profileId);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Creates this user into Kuzzle\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.create = function (options, cb) {\n\t  var\n\t    data = this.creationSerialize(),\n\t    self = this;\n\t\n\t  if (!this.content.profileIds) {\n\t    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Replaces the latest version of this user in Kuzzle by the current content of this object.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.replace = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (!this.content.profileIds) {\n\t    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t\n\t  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Saves this user as restricted into Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.saveRestricted = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tUser.prototype.serialize = function () {\n\t  return {_id: this.id, body: this.content, meta: this.meta};\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tUser.prototype.creationSerialize = function () {\n\t  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n\t};\n\t\n\t/**\n\t * Return the associated profiles IDs\n\t *\n\t * @return {array.<string>} the associated profiles IDs\n\t */\n\tUser.prototype.getProfileIds = function () {\n\t  return this.content.profileIds || [];\n\t};\n\t\n\t/**\n\t * Return the associated Profile objects\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tUser.prototype.getProfiles = function (options, cb) {\n\t  var \n\t    self = this,\n\t    fetchedProfiles = [],\n\t    errored = false;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\t\n\t  if (!self.content.profileIds) {\n\t    return cb(null, fetchedProfiles);\n\t  }\n\t\n\t  self.content.profileIds.forEach(function (profileId) {\n\t    self.Security.fetchProfile(profileId, options, function (error, profile) {\n\t      if (error) {\n\t        if (errored) {\n\t          return;\n\t        }\n\t\n\t        errored = true; // prevents multiple callback resolutions\n\t        return cb(error);\n\t      }\n\t\n\t      fetchedProfiles.push(profile);\n\t\n\t      if (fetchedProfiles.length === self.content.profileIds.length) {\n\t        cb(null, fetchedProfiles);\n\t      }\n\t    });\n\t  });\n\t};\n\t\n\tmodule.exports = User;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(20);\n\tvar bytesToUuid = __webpack_require__(19);\n\t\n\tfunction v4(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || bytesToUuid(rnds);\n\t}\n\t\n\tmodule.exports = v4;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSearchResult = __webpack_require__(11),\n\t  Document = __webpack_require__(2),\n\t  CollectionMapping = __webpack_require__(8),\n\t  Room = __webpack_require__(10),\n\t  SubscribeResult = __webpack_require__(12);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n\t * or like a room for pub/sub messages.\n\t *\n\t * @property {string} collection\n\t * @property {string} index\n\t * @property {Kuzzle} kuzzle\n\t * @property {Array.<string>} collection\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @param {string} collection - name of the data collection to handle\n\t * @param {string} index - Index containing the data collection\n\t * @constructor\n\t */\n\tfunction Collection(kuzzle, collection, index) {\n\t  if (!index || !collection) {\n\t    throw new Error('The Collection object constructor needs an index and a collection arguments');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    index: {\n\t      value: index,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (controller, action) {\n\t      return {\n\t        controller: controller,\n\t        action: action,\n\t        collection: this.collection,\n\t        index: this.index\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of documents matching the provided set of filters.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created won’t be returned by this function\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.count = function (filters, options, cb) {\n\t  var\n\t    query;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.count', cb);\n\t\n\t  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new empty data collection, with no associated mapping.\n\t * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n\t * want to create and prepare data collections before storing documents in it.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.create = function (options, cb) {\n\t  var data = {},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n\t *        If the same document already exists:\n\t *          - resolves with an error if set to \"error\".\n\t *          - replaces the existing document if set to \"replace\"\n\t *\n\t * @param {string} [id] - (optional) document identifier\n\t * @param {object} document - either an instance of a Document object, or a document\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tCollection.prototype.createDocument = function (id, document, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'create';\n\t\n\t  if (id && typeof id !== 'string') {\n\t    cb = options;\n\t    options = document;\n\t    document = id;\n\t    id = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (document instanceof Document) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  if (options && options.ifExist) {\n\t    if (options.ifExist === 'replace') {\n\t      action = 'createOrReplace';\n\t    }\n\t    else if (options.ifExist !== 'error') {\n\t      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n\t    }\n\t  }\n\t\n\t  if (id) {\n\t    data._id = id;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, self.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    var doc;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    doc.version = res.result._version;\n\t    cb(null, doc);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete persistent documents.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created won’t be returned by this function\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Collection} this\n\t */\n\tCollection.prototype.deleteDocument = function (arg, options, cb) {\n\t  var\n\t    action,\n\t    data = {};\n\t\n\t  if (typeof arg === 'string') {\n\t    data._id = arg;\n\t    action = 'delete';\n\t  } else {\n\t    data.body = {query: arg};\n\t    action = 'deleteByQuery';\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      cb(err);\n\t    }\n\t    else {\n\t      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Deletes the current specifications of this collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @return {object} this\n\t */\n\tCollection.prototype.deleteSpecifications = function (options, cb) {\n\t  var\n\t    data = { index: this.index, collection: this.collection },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Returns a boolean indicating whether or not a document with provided ID exists.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} options [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.documentExists = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve a single stored document using its unique document ID.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.fetchDocument = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.fetch', cb);\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiates a CollectionMapping object containing the current mapping of this collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t */\n\tCollection.prototype.getMapping = function (options, cb) {\n\t  var kuzzleMapping;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\t\n\t  kuzzleMapping = new CollectionMapping(this);\n\t  kuzzleMapping.refresh(options, cb);\n\t};\n\t\n\t/**\n\t * Create the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to create\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mCreateDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {},\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Create or replace the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to create or replace\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {},\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Delete specific documents according to given IDs\n\t *\n\t * @param {Array.<string>} documentIds - IDs of the documents to delete\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n\t  var data = {\n\t      body: {\n\t        ids: documentIds\n\t      }\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documentIds)) {\n\t    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Get specific documents according to given IDs\n\t *\n\t * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t */\n\tCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n\t  var data = {\n\t      body: {\n\t        ids: documentIds\n\t      }\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documentIds)) {\n\t    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Replace the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to replace\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {}\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Update the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to update\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {}\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Retrieves the current specifications of this collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.getSpecifications = function (options, cb) {\n\t  var\n\t    data = { index: this.index, collection: this.collection },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Publish a realtime message\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} document - either a Document instance or a JSON object\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.publishMessage = function (document, options, cb) {\n\t  var data = {};\n\t\n\t  if (document instanceof Document) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replace an existing document with a new one.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to replace\n\t * @param {object} content - JSON object representing the new document version\n\t * @param {object} [options] - additional arguments\n\t * @param {responseCallback} [cb] - Returns an instantiated Document object\n\t * @return {object} this\n\t */\n\tCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Executes an advanced search on the data collection.\n\t *\n\t * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created won’t be returned by this function.\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\t\n\tCollection.prototype.search = function (filters, options, cb) {\n\t  var\n\t    query,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.search', cb);\n\t\n\t  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    if (result.result._scroll_id) {\n\t      options.scrollId = result.result._scroll_id;\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(\n\t      self,\n\t      result.result.total,\n\t      documents,\n\t      result.result.aggregations ? result.result.aggregations : {},\n\t      options,\n\t      filters,\n\t      options.previous || null\n\t    ));\n\t  });\n\t};\n\t\n\t/**\n\t * A \"scroll\" option can be passed to search queries, creating persistent\n\t * paginated results.\n\t * This method can be used to manually get the next page of a search result,\n\t * instead of using KuzzleSearchResult.next()\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {object} [filters]\n\t * @param {responseCallback} cb\n\t */\n\tCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Collection.scroll: scrollId is required');\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    if (result.result._scroll_id) {\n\t      options.scrollId = result.result._scroll_id;\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(\n\t      self,\n\t      result.result.total,\n\t      documents,\n\t      {},\n\t      options,\n\t      filters,\n\t      options.previous || null\n\t    ));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieves next result of a search with scroll query.\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n\t  var\n\t    data = { scrollId: scrollId };\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Collection.scrollSpecifications: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\t\n\t  if (options && options.scroll) {\n\t    data.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query(\n\t    { controller: 'collection', action: 'scrollSpecifications'},\n\t    this.kuzzle.addHeaders(data, this.headers),\n\t    options,\n\t    function (err, res) {\n\t      cb (err, err ? undefined : res.result);\n\t    }\n\t  );\n\t};\n\t\n\t/**\n\t * Searches specifications across indexes/collections according to the provided filters\n\t *\n\t * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.searchSpecifications = function (filters, options, cb) {\n\t  var\n\t    data = { body: { query: filters } },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Subscribes to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @param {responseCallback} cb - called for each new notification\n\t * @returns {*} KuzzleSubscribeResult object\n\t */\n\tCollection.prototype.subscribe = function (filters, options, cb) {\n\t  var\n\t    room,\n\t    subscribeResult;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.subscribe', cb);\n\t\n\t  subscribeResult = new SubscribeResult();\n\t  room = new Room(this, options);\n\t\n\t  room.renew(filters, cb, subscribeResult.done.bind(subscribeResult));\n\t\n\t  return subscribeResult;\n\t};\n\t\n\t/**\n\t * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n\t * This method is a lot faster than removing all documents using a query.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.truncate = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Update parts of a document\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to update\n\t * @param {object} content - JSON object containing changes to perform on the document\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Returns an instantiated Document object\n\t * @return {object} this\n\t */\n\tCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n\t  var data = {\n\t      _id: documentId,\n\t      body: content\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options && options.retryOnConflict) {\n\t    data.retryOnConflict = options.retryOnConflict;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    (new Document(self, res.result._id)).refresh(cb);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Updates the current specifications of this collection\n\t *\n\t * @param {object} specifications - Specifications content\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @return {object} this\n\t */\n\tCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n\t  var\n\t    collection = {},\n\t    data = { body: {} },\n\t    self = this;\n\t\n\t  collection[this.collection] = specifications;\n\t  data.body[this.index] = collection;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Validates the provided specifications\n\t *\n\t * @param {object} specifications - Specifications content\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n\t  var\n\t    collection = {},\n\t    data = { body: {} },\n\t    self = this;\n\t\n\t  collection[this.collection] = specifications;\n\t  data.body[this.index] = collection;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.valid);\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - document id\n\t * @param {object} content - document content\n\t * @constructor\n\t */\n\tCollection.prototype.document = function (id, content) {\n\t  return new Document(this, id, content);\n\t};\n\t\n\t/**\n\t * Instantiate a new Room object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [options] - subscription configuration\n\t * @constructor\n\t */\n\tCollection.prototype.room = function (options) {\n\t  return new Room(this, options);\n\t};\n\t\n\t/**\n\t * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n\t * @constructor\n\t */\n\tCollection.prototype.collectionMapping = function (mapping) {\n\t  return new CollectionMapping(this, mapping);\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tCollection.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\tmodule.exports = Collection;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n\t *  It means that, by default, you won’t be able to exploit the full capabilities of our persistent data storage layer\n\t *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n\t *  the amount of data you stored in a collection and the complexity of your database.\n\t *\n\t *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n\t *\n\t * @param {object} collection - Instance of the inherited Collection object\n\t * @param {object} [mapping] - mappings\n\t * @constructor\n\t */\n\tfunction CollectionMapping(collection, mapping) {\n\t  Object.defineProperties(this, {\n\t    //read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(collection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    mapping: {\n\t      value: mapping || {},\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['set', 'setHeaders'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Applies the new mapping to the data collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tCollectionMapping.prototype.apply = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n\t    if (err) {\n\t      return cb && cb(err);\n\t    }\n\t\n\t    self.refresh(options, cb);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with the mapping stored in Kuzzle\n\t *\n\t * Calling this function will discard any uncommited changes. You can commit changes by calling the “apply” function\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tCollectionMapping.prototype.refresh = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = this.kuzzle.addHeaders({}, this.headers);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n\t    if (err) {\n\t      return cb ? cb(err) : false;\n\t    }\n\t\n\t    if (res.result[self.collection.index]) {\n\t      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n\t        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\t\n\t        // Mappings can be empty. The mapping property should never be \"undefined\"\n\t        if (self.mapping === undefined) {\n\t          self.mapping = {};\n\t        }\n\t      } else {\n\t        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n\t      }\n\t    } else {\n\t      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Adds or updates a field mapping.\n\t *\n\t * Changes made by this function won’t be applied until you call the apply method\n\t *\n\t * @param {string} field - Name of the field from which the mapping is to be added or updated\n\t * @param {object} mapping - corresponding field mapping\n\t * @returns {CollectionMapping}\n\t */\n\tCollectionMapping.prototype.set = function (field, mapping) {\n\t  this.mapping[field] = mapping;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tCollectionMapping.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\tmodule.exports = CollectionMapping;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t// Parameter mutualization\n\tvar\n\t  getId = {getter: true, required: ['_id']},\n\t  getIdField = {getter: true, required: ['_id', 'field']},\n\t  getKeys = {getter: true, required: ['keys']},\n\t  getMember = {getter: true, required: ['_id', 'member']},\n\t  getxScan = {\n\t    getter: true, \n\t    required: ['_id', 'cursor'], \n\t    opts: ['match', 'count'],\n\t    mapResults: mapScanResults\n\t  },\n\t  getZrange = {\n\t    getter: true,\n\t    required: ['_id', 'start', 'stop'],\n\t    opts: assignZrangeOptions,\n\t    mapResults: mapZrangeResults\n\t  },\n\t  getZrangeBy = {\n\t    getter: true,\n\t    required: ['_id', 'min', 'max'],\n\t    opts: assignZrangeOptions,\n\t    mapResults: mapZrangeResults\n\t  },\n\t  setId = {required: ['_id']},\n\t  setIdValue = {required: ['_id', 'value']},\n\t  setIdFieldValue = {required: ['_id', 'field', 'value']},\n\t  setEntries = {required: ['entries']};\n\t\n\t// Redis commands\n\tvar\n\t  commands = {\n\t    append: setIdValue,\n\t    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n\t    bitop: {required: ['_id', 'operation', 'keys']},\n\t    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n\t    dbsize: {getter: true},\n\t    decr: setId,\n\t    decrby: setIdValue,\n\t    del: {required: ['keys']},\n\t    exists: getKeys,\n\t    expire: {required: ['_id', 'seconds']},\n\t    expireat: {required: ['_id', 'timestamp']},\n\t    flushdb: {},\n\t    geoadd: {required: ['_id', 'points']},\n\t    geodist: {\n\t      getter: true,\n\t      required: ['_id', 'member1', 'member2'],\n\t      opts: ['unit'],\n\t      mapResults: parseFloat\n\t    },\n\t    geohash: {getter: true, required: ['_id', 'members']},\n\t    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n\t    georadius: {\n\t      getter: true,\n\t      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n\t      opts: assignGeoRadiusOptions,\n\t      mapResults: mapGeoRadiusResults\n\t    },\n\t    georadiusbymember: {\n\t      getter: true,\n\t      required: ['_id', 'member', 'distance', 'unit'],\n\t      opts: assignGeoRadiusOptions,\n\t      mapResults: mapGeoRadiusResults\n\t    },\n\t    get: getId,\n\t    getbit: {getter: true, required: ['_id', 'offset']},\n\t    getrange: {getter: true, required: ['_id', 'start', 'end']},\n\t    getset: setIdValue,\n\t    hdel: {required: ['_id', 'fields']},\n\t    hexists: getIdField,\n\t    hget: getIdField,\n\t    hgetall: {getter: true, required: ['_id']},\n\t    hincrby: setIdFieldValue,\n\t    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n\t    hkeys: getId,\n\t    hlen: getId,\n\t    hmget: {getter: true, required: ['_id', 'fields']},\n\t    hmset: {required: ['_id', 'entries']},\n\t    hscan: getxScan,\n\t    hset: setIdFieldValue,\n\t    hsetnx: setIdFieldValue,\n\t    hstrlen: getIdField,\n\t    hvals: getId,\n\t    incr: setId,\n\t    incrby: setIdValue,\n\t    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n\t    keys: {getter: true, required: ['pattern']},\n\t    lindex: {getter: true, required: ['_id', 'idx']},\n\t    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n\t    llen: getId,\n\t    lpop: setId,\n\t    lpush: {required: ['_id', 'values']},\n\t    lpushx: setIdValue,\n\t    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n\t    lrem: {required: ['_id', 'count', 'value']},\n\t    lset: {required: ['_id', 'index', 'value']},\n\t    ltrim: {required: ['_id', 'start', 'stop']},\n\t    mget: getKeys,\n\t    mset: setEntries,\n\t    msetnx: setEntries,\n\t    object: {getter: true, required: ['_id', 'subcommand']},\n\t    persist: setId,\n\t    pexpire: {required: ['_id', 'milliseconds']},\n\t    pexpireat: {required: ['_id', 'timestamp']},\n\t    pfadd: {required: ['_id', 'elements']},\n\t    pfcount: getKeys,\n\t    pfmerge: {required: ['_id', 'sources']},\n\t    ping: {getter: true},\n\t    psetex: {required: ['_id', 'value', 'milliseconds']},\n\t    pttl: getId,\n\t    randomkey: {getter: true},\n\t    rename: {required: ['_id', 'newkey']},\n\t    renamenx: {required: ['_id', 'newkey']},\n\t    rpop: setId,\n\t    rpoplpush: {required: ['source', 'destination']},\n\t    rpush: {required: ['_id', 'values']},\n\t    rpushx: setIdValue,\n\t    sadd: {required: ['_id', 'members']},\n\t    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n\t    scard: getId,\n\t    sdiff: {getter: true, required: ['_id', 'keys']},\n\t    sdiffstore: {required: ['_id', 'keys', 'destination']},\n\t    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx']},\n\t    setex: {required: ['_id', 'value', 'seconds']},\n\t    setnx: setIdValue,\n\t    sinter: getKeys,\n\t    sinterstore: {required: ['destination', 'keys']},\n\t    sismember: getMember,\n\t    smembers: getId,\n\t    smove: {required: ['_id', 'destination', 'member']},\n\t    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n\t    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n\t    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n\t    srem: {required: ['_id', 'members']},\n\t    sscan: getxScan,\n\t    strlen: getId,\n\t    sunion: getKeys,\n\t    sunionstore: {required: ['destination', 'keys']},\n\t    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n\t    touch: {required: ['keys']},\n\t    ttl: getId,\n\t    type: getId,\n\t    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n\t    zcard: getId,\n\t    zcount: {getter: true, required: ['_id', 'min', 'max']},\n\t    zincrby: {required: ['_id', 'member', 'value']},\n\t    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n\t    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n\t    zrange: getZrange,\n\t    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n\t    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n\t    zrangebyscore: getZrangeBy,\n\t    zrank: getMember,\n\t    zrem: {required: ['_id', 'members']},\n\t    zremrangebylex: {required: ['_id', 'min', 'max']},\n\t    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n\t    zremrangebyscore: {required: ['_id', 'min', 'max']},\n\t    zrevrange: getZrange,\n\t    zrevrangebyscore: getZrangeBy,\n\t    zrevrank: getMember,\n\t    zscan: getxScan,\n\t    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n\t    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n\t  };\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t * Kuzzle's memory storage is a separate data store from the database layer.\n\t * It is internaly based on Redis. You can access most of Redis functions (all\n\t * lowercased), except functions falling in the following categories:\n\t *\n\t *  - blocking functions\n\t *  - cluster commands\n\t *  - configuration commands\n\t *  - cursor functions\n\t *  - database administration commands\n\t *  - debugging functions\n\t *  - script based functions\n\t *  - transaction functions\n\t *\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @constructor\n\t */\n\tfunction MemoryStorage(kuzzle) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  this.setHeaders = kuzzle.setHeaders.bind(this);\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['setHeaders'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t// Dynamically builds this class' prototypes using the \"commands\" global variable\n\t(function () {\n\t  Object.keys(commands).forEach(function (command) {\n\t    MemoryStorage.prototype[command] = function () {\n\t      var\n\t        args = Array.prototype.slice.call(arguments),\n\t        options = null,\n\t        cb,\n\t        query = {\n\t          controller: 'ms',\n\t          action: command\n\t        },\n\t        data = {};\n\t\n\t      if (args.length && typeof args[args.length - 1] === 'function') {\n\t        cb = args.pop();\n\t      }\n\t\n\t      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\t\n\t      if (!commands[command].getter) {\n\t        data.body = {};\n\t      }\n\t\n\t      if (commands[command].required) {\n\t        commands[command].required.forEach(function (param) {\n\t          var value = args.shift();\n\t\n\t          if (value === undefined) {\n\t            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n\t          }\n\t\n\t          assignParameter(data, commands[command].getter, param, value);\n\t        });\n\t      }\n\t\n\t      if (args.length > 1) {\n\t        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n\t      }\n\t\n\t      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n\t        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n\t      }\n\t\n\t      if (args.length) {\n\t        options = Object.assign({}, args[0]);\n\t\n\t        if (Array.isArray(commands[command].opts)) {\n\t          commands[command].opts.forEach(function (opt) {\n\t            if (options[opt] !== null && options[opt] !== undefined) {\n\t              assignParameter(data, commands[command].getter, opt, options[opt]);\n\t              delete options[opt];\n\t            }\n\t          });\n\t        }\n\t      }\n\t\n\t      /*\n\t       Options function mapper does not necessarily need\n\t       options to be passed by clients.\n\t       */\n\t      if (typeof commands[command].opts === 'function') {\n\t        commands[command].opts(data, options || {});\n\t      }\n\t\n\t      this.kuzzle.query(query, data, options, cb && function (err, res) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t\n\t        if (commands[command].mapResults) {\n\t          return cb(null, commands[command].mapResults(res.result));\n\t        }\n\t\n\t        cb(null, res.result);\n\t      });\n\t\n\t      if (!commands[command].getter) {\n\t        return this;\n\t      }\n\t    };\n\t  });\n\t})();\n\t\n\t/**\n\t *\n\t * @param {object} data - target data object\n\t * @param {boolean} getter - tells if the command is a getter one\n\t * @param {string} name - parameter name\n\t * @param {*} value - parameter value\n\t */\n\tfunction assignParameter(data, getter, name, value) {\n\t  if (getter || name === '_id') {\n\t    data[name] = value;\n\t  }\n\t  else {\n\t    data.body[name] = value;\n\t  }\n\t}\n\t\n\t/**\n\t * Assign the provided options for the georadius* redis functions\n\t * to the request object, as expected by Kuzzle API\n\t *\n\t * Mutates the provided data and options objects\n\t *\n\t * @param {object} data\n\t * @param {object} options\n\t */\n\tfunction assignGeoRadiusOptions(data, options) {\n\t  var parsed = [];\n\t\n\t  Object.keys(options)\n\t    .filter(function (opt) {\n\t      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n\t    })\n\t    .forEach(function (opt) {\n\t      if (opt === 'withcoord' || opt === 'withdist') {\n\t        parsed.push(opt);\n\t        delete options[opt];\n\t      }\n\t      else if (opt === 'count' || opt === 'sort') {\n\t        if (opt === 'count') {\n\t          parsed.push('count');\n\t        }\n\t\n\t        parsed.push(options[opt]);\n\t      }\n\t\n\t      delete options[opt];\n\t    });\n\t\n\t  if (parsed.length > 0) {\n\t    data.options = parsed;\n\t  }\n\t}\n\t\n\t/**\n\t * Force the WITHSCORES option on z*range* routes\n\t *\n\t * Mutates the provided data and options objects\n\t *\n\t * @param {object} data\n\t * @param {object} options\n\t */\n\tfunction assignZrangeOptions(data, options) {\n\t  data.options = ['withscores'];\n\t\n\t  if (options.limit) {\n\t    data.limit = options.limit;\n\t    delete options.limit;\n\t  }\n\t}\n\t\n\t/**\n\t * Maps geopos results, from array<array<string>> to array<array<number>>\n\t *\n\t * @param {Array.<Array.<string>>} results\n\t * @return {Array.<Array.<Number>>}\n\t */\n\tfunction mapGeoposResults(results) {\n\t  return results.map(function (coords) {\n\t    return coords.map(function (latlon) {\n\t      return parseFloat(latlon);\n\t    });\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Maps georadius results to the format specified in the SDK documentation,\n\t * preventing different formats depending on the passed options\n\t *\n\t * Results can be either an array of point names, or an array\n\t * of arrays, each one of them containing the point name,\n\t * and additional informations depending on the passed options\n\t * (coordinates, distances)\n\t *\n\t * @param {Array} results\n\t * @return {Array.<Object>}\n\t */\n\tfunction mapGeoRadiusResults(results) {\n\t  // Simple array of point names (no options provided)\n\t  if (!Array.isArray(results[0])) {\n\t    return results.map(function (point) {\n\t      return {name: point};\n\t    });\n\t  }\n\t\n\t  return results.map(function (point) {\n\t    // The point id is always the first item\n\t    var p = {\n\t        name: point[0]\n\t      },\n\t      i;\n\t\n\t    for (i = 1; i < point.length; i++) {\n\t      // withcoord result are in an array...\n\t      if (Array.isArray(point[i])) {\n\t        p.coordinates = point[i].map(function (coord) {\n\t          return parseFloat(coord);\n\t        });\n\t      }\n\t      else {\n\t        // ... and withdist are not\n\t        p.distance = parseFloat(point[i]);\n\t      }\n\t    }\n\t\n\t    return p;\n\t  });\n\t}\n\t\n\t/**\n\t * Map a string result to an array of strings.\n\t * Used to uniformize polymorphic results from redis\n\t *\n\t * @param {Array|string} results\n\t * @return {Array.<string>}\n\t */\n\tfunction mapStringToArray (results) {\n\t  return Array.isArray(results) ? results : [results];\n\t}\n\t\n\t/**\n\t * Map an array of strings to an array of integers\n\t *\n\t * @param {Array.<string>} results\n\t * @return {Array.<Number>}\n\t */\n\tfunction mapArrayStringToArrayInt(results) {\n\t  return results.map(function (value) {\n\t    return parseInt(value);\n\t  });\n\t}\n\t\n\t/**\n\t * Map zrange results with WITHSCORES:\n\t * [\n\t *  \"member1\",\n\t *  \"score of member1\",\n\t *  \"member2\",\n\t *  \"score of member2\"\n\t * ]\n\t *\n\t * into the following format:\n\t * [\n\t *  {\"member\": \"member1\", \"score\": <score of member1>},\n\t *  {\"member\": \"member2\", \"score\": <score of member2>},\n\t * ]\n\t *\n\t *\n\t * @param {Array.<string>} results\n\t * @return {Array.<Object>}\n\t */\n\tfunction mapZrangeResults(results) {\n\t  var\n\t    buffer = null,\n\t    mapped = [];\n\t\n\t  results.forEach(function (value) {\n\t    if (buffer === null) {\n\t      buffer = value;\n\t    }\n\t    else {\n\t      mapped.push({member: buffer, score: parseFloat(value)});\n\t      buffer = null;\n\t    }\n\t  });\n\t\n\t  return mapped;\n\t}\n\t\n\t/**\n\t * Map *scan calls results, from:\n\t * [\n\t *   \"<cursor>\",\n\t *   [\n\t *     \"value1\",\n\t *     \"value2\", \n\t *     \"...\"\n\t *   ]\n\t * ]\n\t *\n\t * To:\n\t * {\n\t *   cursor: <cursor>,\n\t *   values: [\n\t *     \"value1\",\n\t *     \"value2\",\n\t *     \"...\"\n\t *   ]\n\t * }\n\t * \n\t * @param  {array.<string|array>} results \n\t * @return {object}\n\t */\n\tfunction mapScanResults(results) {\n\t  return {\n\t    cursor: results[0],\n\t    values: results[1]\n\t  };\n\t}\n\t\n\tmodule.exports = MemoryStorage;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  uuidv4 = __webpack_require__(6),\n\t  Document = __webpack_require__(2);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n\t *\n\t * In Kuzzle, you don’t exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n\t *\n\t * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n\t * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n\t * document change (because it is created, updated or deleted), then you’ll receive a notification about it.\n\t *\n\t * @param {object} collection - an instantiated and valid kuzzle object\n\t * @param {object} [options] - subscription optional configuration\n\t * @constructor\n\t */\n\tfunction Room(collection, options) {\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    callback: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    channel: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    id: {\n\t      value: uuidv4()\n\t    },\n\t    lastRenewal: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    notifier: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    onDoneCB: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    queue: {\n\t      value: [],\n\t      writable: true\n\t    },\n\t    // Delay before allowing a subscription renewal\n\t    renewalDelay: {\n\t      value: 500\n\t    },\n\t    scope: {\n\t      value: options && options.scope ? options.scope : 'all'\n\t    },\n\t    state: {\n\t      value: options && options.state ? options.state : 'done'\n\t    },\n\t    subscribing: {\n\t      value: false,\n\t      writable: true\n\t    },\n\t    users: {\n\t      value: options && options.users ? options.users : 'none'\n\t    },\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    filters: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(collection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    volatile: {\n\t      value: (options && options.volatile) ? options.volatile : {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    roomId: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    subscribeToSelf: {\n\t      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['count'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of other subscriptions on that room.\n\t *\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tRoom.prototype.count = function (cb) {\n\t  var data;\n\t\n\t  this.kuzzle.callbackRequired('Room.count', cb);\n\t\n\t  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\t\n\t  if (!isReady.call(this)) {\n\t    this.queue.push({action: 'count', args: [cb]});\n\t    return;\n\t  }\n\t\n\t  if (!this.roomId) {\n\t    throw new Error('Room.count: cannot count subscriptions on an inactive room');\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n\t    cb(err, res && res.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Renew the subscription using new filters\n\t *\n\t * @param {object} [filters] - Filters in Kuzzle DSL format\n\t * @param {responseCallback} notificationCB - called for each new notification\n\t * @param {responseCallback} [cb] - handles the query response\n\t */\n\tRoom.prototype.renew = function (filters, notificationCB, cb) {\n\t  var\n\t    self = this,\n\t    now = Date.now(),\n\t    subscribeQuery = {\n\t      scope: self.scope,\n\t      state: self.state,\n\t      users: self.users\n\t    };\n\t\n\t  if (typeof filters === 'function') {\n\t    cb = notificationCB;\n\t    notificationCB = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = self.onDoneCB;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Room.renew', notificationCB);\n\t\n\t  /*\n\t    Skip subscription renewal if another one was performed a moment before\n\t   */\n\t  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n\t    return cb && cb(new Error('Subscription already renewed less than ' + self.renewalDelay + 'ms ago'));\n\t  }\n\t\n\t  if (filters) {\n\t    self.filters = filters;\n\t  }\n\t\n\t  /*\n\t   if not yet connected, register itself to the subscriptions list and wait for the\n\t   main Kuzzle object to renew once online\n\t    */\n\t  if (self.kuzzle.state !== 'connected') {\n\t    self.callback = notificationCB;\n\t    self.onDoneCB = cb;\n\t    self.kuzzle.subscriptions.pending[self.id] = self;\n\t    return;\n\t  }\n\t\n\t  if (self.subscribing) {\n\t    self.queue.push({action: 'renew', args: [filters, notificationCB, cb]});\n\t    return;\n\t  }\n\t\n\t  self.unsubscribe();\n\t  self.roomId = null;\n\t  self.subscribing = true;\n\t  self.callback = notificationCB;\n\t  self.onDoneCB = cb;\n\t  self.kuzzle.subscriptions.pending[self.id] = self;\n\t\n\t  subscribeQuery.body = self.filters;\n\t  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, self.headers);\n\t\n\t  self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'subscribe'), subscribeQuery, {volatile: self.volatile}, function (error, response) {\n\t    delete self.kuzzle.subscriptions.pending[self.id];\n\t    self.subscribing = false;\n\t\n\t    if (error) {\n\t      self.queue = [];\n\t      return cb && cb(new Error('Error during Kuzzle subscription: ' + error.message));\n\t    }\n\t\n\t    self.lastRenewal = now;\n\t    self.roomId = response.result.roomId;\n\t    self.channel = response.result.channel;\n\t\n\t    if (!self.kuzzle.subscriptions[self.roomId]) {\n\t      self.kuzzle.subscriptions[self.roomId] = {};\n\t    }\n\t\n\t    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\t\n\t    self.notifier = notificationCallback.bind(self);\n\t    self.kuzzle.network.on(self.channel, self.notifier);\n\t\n\t    dequeue.call(self);\n\t    cb && cb(null, self);\n\t  });\n\t};\n\t\n\t/**\n\t * Unsubscribes from Kuzzle.\n\t *\n\t * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n\t * pending subscriptions reaches 0, and only if there is still no listener on that room.\n\t * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n\t *\n\t * @return {*} this\n\t */\n\tRoom.prototype.unsubscribe = function () {\n\t  var\n\t    self = this,\n\t    room = self.roomId,\n\t    interval;\n\t\n\t  if (!isReady.call(this)) {\n\t    self.queue.push({action: 'unsubscribe', args: []});\n\t    return self;\n\t  }\n\t\n\t  if (room) {\n\t    self.kuzzle.network.off(self.channel, this.notifier);\n\t\n\t    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n\t      delete self.kuzzle.subscriptions[room];\n\t\n\t      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n\t        self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n\t      } else {\n\t        interval = setInterval(function () {\n\t          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n\t            if (!self.kuzzle.subscriptions[room]) {\n\t              self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n\t            }\n\t            clearInterval(interval);\n\t          }\n\t        }, 100);\n\t      }\n\t    } else {\n\t      delete self.kuzzle.subscriptions[room][self.id];\n\t    }\n\t\n\t    self.roomId = null;\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tRoom.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Callback called by the network handler when a message is sent to the subscribed room ID\n\t * Calls the registered callback if the notification passes the subscription filters\n\t *\n\t * @param {object} data - data\n\t * @returns {*}\n\t */\n\tfunction notificationCallback (data) {\n\t  if (data.type === 'TokenExpired') {\n\t    this.kuzzle.jwtToken = undefined;\n\t    return this.kuzzle.emitEvent('tokenExpired');\n\t  }\n\t\n\t  if (data.type === 'document') {\n\t    data.document = new Document(this.collection, data.result._id, data.result._source, data.result._meta);\n\t    delete data.result;\n\t  }\n\t\n\t  if (this.kuzzle.requestHistory[data.requestId]) {\n\t    if (this.subscribeToSelf) {\n\t      this.callback(null, data);\n\t    }\n\t    delete this.kuzzle.requestHistory[data.requestId];\n\t  } else {\n\t    this.callback(null, data);\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Dequeue actions performed while subscription was being renewed\n\t */\n\tfunction dequeue () {\n\t  var element;\n\t\n\t  while (this.queue.length > 0) {\n\t    element = this.queue.shift();\n\t\n\t    this[element.action].apply(this, element.args);\n\t  }\n\t}\n\t\n\tfunction isReady() {\n\t  return this.kuzzle.state === 'connected' && !this.subscribing;\n\t}\n\t\n\tmodule.exports = Room;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @param {Collection} collection\n\t * @param {int} total\n\t * @param {Document[]} documents\n\t * @param {object} aggregations\n\t * @param {object} options\n\t * @param {object} filters\n\t * @param {SearchResult} previous\n\t * @property {Collection} collection\n\t * @property {number} total\n\t * @property {Document[]} documents\n\t * @property {object} aggregations\n\t * @property {object} options\n\t * @property {object} filters\n\t * @property {number} fetchedDocument\n\t * @constructor\n\t */\n\tfunction SearchResult (collection, total, documents, aggregations, options, filters, previous) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    total: {\n\t      value: total,\n\t      enumerable: true\n\t    },\n\t    documents: {\n\t      value: documents,\n\t      enumerable: true\n\t    },\n\t    aggregations: {\n\t      value: aggregations || {},\n\t      enumerable: true\n\t    },\n\t    options: {\n\t      value: options || {},\n\t      enumerable: true\n\t    },\n\t    filters: {\n\t      value: filters || {},\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    fetchedDocument: {\n\t      value: previous instanceof SearchResult ? documents.length + previous.fetchedDocument : documents.length,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (this.collection.kuzzle.bluebird) {\n\t    return this.collection.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['fetchNext'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * @param {function} cb\n\t */\n\tSearchResult.prototype.fetchNext = function (cb) {\n\t  var\n\t    filters,\n\t    options = Object.assign({}, this.options),\n\t    self = this;\n\t  \n\t  options.previous = this;\n\t\n\t  // retrieve next results with scroll if original search use it\n\t  if (options.scrollId) {\n\t    if (this.fetchedDocument >= this.getTotal()) {\n\t      cb(null, null);\n\t      return;\n\t    }\n\t\n\t    // from and size parameters are not valid for a scroll action\n\t    if (typeof options.from !== 'undefined') {\n\t      delete options.from;\n\t    }\n\t\n\t    if (options.size) {\n\t      delete options.size;\n\t    }\n\t\n\t    this.collection.scroll(options.scrollId, options, this.filters || {}, cb);\n\t\n\t    return;\n\t  }\n\t\n\t  // retrieve next results using ES's search_after\n\t  if (options.size && this.filters.sort) {\n\t    if (this.fetchedDocument >= this.getTotal()) {\n\t      cb(null, null);\n\t      return;\n\t    }\n\t\n\t    if (options.from) {\n\t      delete options.from;\n\t    }\n\t\n\t    filters = Object.assign(this.filters, {search_after: []});\n\t\n\t    filters.sort.forEach(function (sortRule) {\n\t      filters.search_after.push(self.documents[self.documents.length - 1].content[Object.keys(sortRule)[0]]);\n\t    });\n\t\n\t    this.collection.search(filters, options, cb);\n\t\n\t    return;\n\t  }\n\t\n\t  // retrieve next results with from/size if original search use it\n\t  if (options.from !== undefined && options.size !== undefined) {\n\t    filters = Object.assign({}, this.filters);\n\t\n\t    // check if we need to do next request to fetch all matching documents\n\t    options.from += options.size;\n\t\n\t    if (options.from >= this.getTotal()) {\n\t      cb(null, null);\n\t\n\t      return;\n\t    }\n\t\n\t    this.collection.search(filters, options, cb);\n\t\n\t    return;\n\t  }\n\t\n\t  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n\t};\n\t\n\t/**\n\t * @returns {Document[]}\n\t */\n\tSearchResult.prototype.getDocuments = function () {\n\t  return this.documents;\n\t};\n\t\n\t/**\n\t * @returns {number}\n\t */\n\tSearchResult.prototype.getTotal = function () {\n\t  return this.total;\n\t};\n\t\n\t/**\n\t * @returns {object}\n\t */\n\tSearchResult.prototype.getAggregations = function () {\n\t  return this.aggregations;\n\t};\n\t\n\t/**\n\t * @returns {Object}\n\t */\n\tSearchResult.prototype.getOptions = function() {\n\t  return this.options;\n\t};\n\t\n\t/**\n\t * @returns {object}\n\t */\n\tSearchResult.prototype.getFilters = function() {\n\t  return this.filters;\n\t};\n\t\n\t/**\n\t * @returns {object}\n\t */\n\tSearchResult.prototype.getCollection = function () {\n\t  return this.collection;\n\t};\n\t\n\t/**\n\t * @returns {number}\n\t */\n\tSearchResult.prototype.getFetchedDocument = function () {\n\t  return this.fetchedDocument;\n\t};\n\t\n\tmodule.exports = SearchResult;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Sugar-code handling the result of a Room.renew call\n\t * @constructor\n\t */\n\tfunction SubscribeResult() {\n\t  this.cbs = [];\n\t  this.error = null;\n\t  this.room = null;\n\t}\n\t\n\t/**\n\t * Registers a callback to be called with a subscription result\n\t * @param {Function} cb\n\t */\n\tSubscribeResult.prototype.onDone = function (cb) {\n\t  if (this.error || this.room) {\n\t    cb(this.error, this.room);\n\t  }\n\t  else {\n\t    this.cbs.push(cb);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Calls all registered callbacks\n\t *\n\t * @param {Object} error object\n\t * @param {Room} room\n\t */\n\tSubscribeResult.prototype.done = function (error, room) {\n\t  this.error = error;\n\t  this.room = room;\n\t\n\t  this.cbs.forEach(function (cb) {\n\t    cb(error, room);\n\t  });\n\t};\n\t\n\tmodule.exports = SubscribeResult;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t *\n\t * @param host\n\t * @param port\n\t * @param sslConnection\n\t * @returns {Object} tnstantiated WebSocket/Socket.IO object\n\t */\n\t\n\tfunction network(host, port, sslConnection) {\n\t  // Web browser / NodeJS websocket handling\n\t  if (typeof window !== 'undefined') {\n\t    // use native websockets if the browser supports it\n\t    if (typeof WebSocket !== 'undefined') {\n\t      return new (__webpack_require__(4))(host, port, sslConnection);\n\t    }\n\t    // otherwise fallback to socket.io, if available\n\t    else if (window.io) {\n\t      return new (__webpack_require__(14))(host, port, sslConnection);\n\t    }\n\t\n\t    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n\t  }\n\t\n\t  return new (__webpack_require__(4))(host, port, sslConnection);\n\t}\n\t\n\tmodule.exports = network;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\tfunction SocketIO(host, port, ssl) {\n\t  this.host = host;\n\t  this.port = port;\n\t  this.ssl = ssl;\n\t  this.socket = null;\n\t  this.wasConnected = false;\n\t  this.forceDisconnect = false;\n\t  this.handlers = {\n\t    connect: [],\n\t    reconnect: [],\n\t    connectError: [],\n\t    disconnect: []\n\t  };\n\t  this.retrying = false;\n\t\n\t  /**\n\t   * Creates a new socket from the provided arguments\n\t   *\n\t   * @constructor\n\t   * @param {boolean} autoReconnect\n\t   * @param {int} reconnectionDelay\n\t   */\n\t  this.connect = function (autoReconnect, reconnectionDelay) {\n\t    var self = this;\n\t\n\t    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n\t      reconnection: autoReconnect,\n\t      reconnectionDelay: reconnectionDelay,\n\t      forceNew: true\n\t    });\n\t\n\t    this.socket.on('connect', function() {\n\t      if (self.wasConnected) {\n\t        self.handlers.reconnect.forEach(function(handler) {\n\t          handler();\n\t        });\n\t      }\n\t      else {\n\t        self.handlers.connect.forEach(function(handler) {\n\t          handler();\n\t        });\n\t      }\n\t\n\t      self.wasConnected = true;\n\t    });\n\t\n\t    this.socket.on('connect_error', function(error) {\n\t      onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n\t    });\n\t\n\t    this.socket.on('disconnect', function() {\n\t      var error;\n\t\n\t      if (self.forceDisconnect) {\n\t        self.handlers.disconnect.forEach(function(handler) {\n\t          handler();\n\t        });\n\t      }\n\t      else {\n\t        error = new Error('An error occurred, this may due that kuzzle was not ready yet');\n\t        error.status = 500;\n\t\n\t        onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n\t      }\n\t\n\t      self.forceDisconnect = false;\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whence a connection is established\n\t   *\n\t   * @param {function} callback\n\t   */\n\t  this.onConnect = function (callback) {\n\t    if (this.handlers.connect.indexOf(callback) === -1) {\n\t      this.handlers.connect.push(callback);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection error is received\n\t   * @param {function} callback\n\t   */\n\t  this.onConnectError = function (callback) {\n\t    if (this.handlers.connectError.indexOf(callback) === -1) {\n\t      this.handlers.connectError.push(callback);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a disconnection occurred\n\t   * @param {function} callback\n\t   */\n\t  this.onDisconnect = function (callback) {\n\t    if (this.handlers.disconnect.indexOf(callback) === -1) {\n\t      this.handlers.disconnect.push(callback);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection has been reestablished\n\t   * @param {function} callback\n\t   */\n\t  this.onReconnect = function (callback) {\n\t    if (this.handlers.reconnect.indexOf(callback) === -1) {\n\t      this.handlers.reconnect.push(callback);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room. Once 1 message is received, fires the\n\t   * callback and unregister it afterward.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.once = function (roomId, callback) {\n\t    this.socket.once(roomId, callback);\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.on = function (roomId, callback) {\n\t    this.socket.on(roomId, callback);\n\t  };\n\t\n\t  /**\n\t   * Unregisters a callback from a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.off = function (roomId, callback) {\n\t    this.socket.off(roomId, callback);\n\t  };\n\t\n\t\n\t  /**\n\t   * Sends a payload to the connected server\n\t   *\n\t   * @param {Object} payload\n\t   */\n\t  this.send = function (payload) {\n\t    this.socket.emit('kuzzle', payload);\n\t  };\n\t\n\t  /**\n\t   * Closes the connection\n\t   */\n\t  this.close = function () {\n\t    this.forceDisconnect = true;\n\t\n\t    this.socket.close();\n\t    this.socket = null;\n\t  };\n\t}\n\t\n\t/**\n\t * Called when the connection closes with an error state\n\t *\n\t * @param {SocketIO}\n\t * @param {boolean} autoReconnect\n\t * @param {number} reconnectionDelay\n\t * @param {Error} error\n\t */\n\tfunction onClientNetworkError(socketio, autoReconnect, reconnectionDelay, error) {\n\t  if (autoReconnect && !socketio.retrying && !socketio.stopRetryingToConnect) {\n\t    socketio.retrying = true;\n\t    setTimeout(function () {\n\t      socketio.retrying = false;\n\t      socketio.connect(autoReconnect, reconnectionDelay);\n\t    }, reconnectionDelay);\n\t  }\n\t\n\t  socketio.handlers.connectError.forEach(function(handler) {\n\t    handler(error);\n\t  });\n\t}\n\t\n\t\n\tmodule.exports = SocketIO;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SecurityDocument = __webpack_require__(1);\n\t\n\tfunction Profile(Security, id, content, meta) {\n\t\n\t  SecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteProfile'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateProfile'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['hydrate', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tProfile.prototype = Object.create(SecurityDocument.prototype, {\n\t  constructor: {\n\t    value: Profile\n\t  }\n\t});\n\t\n\t/**\n\t * Persist to the persistent layer the current profile\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.save = function (options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!this.content.policies) {\n\t    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.serialize();\n\t\n\t  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Add a policy in the policies list\n\t * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n\t *\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.addPolicy = function (policy) {\n\t\n\t  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n\t  }\n\t\n\t  if (!this.content.policies) {\n\t    this.content.policies = [];\n\t  }\n\t\n\t  this.content.policies.push(policy);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set policies list\n\t * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.setPolicies = function (policies) {\n\t\n\t  if (!Array.isArray(policies)) {\n\t    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t  }\n\t\n\t  policies.map(function (policy) {\n\t    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t    }\n\t  });\n\t\n\t  this.content.policies = policies;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this securityDocument\n\t */\n\tProfile.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Returns the list of policies associated to this profile.\n\t * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @return {object} an array of policies\n\t */\n\tProfile.prototype.getPolicies = function () {\n\t  return this.content.policies;\n\t};\n\t\n\tmodule.exports = Profile;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SecurityDocument = __webpack_require__(1);\n\t\n\tfunction Role(Security, id, content, meta) {\n\t\n\t  SecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteRole'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateRole'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tRole.prototype = Object.create(SecurityDocument.prototype, {\n\t  constructor: {\n\t    value: Role\n\t  }\n\t});\n\t\n\t/**\n\t * Saves this role into Kuzzle.\n\t *\n\t * If this is a new role, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Role} this object\n\t */\n\tRole.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = Role;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  Role = __webpack_require__(16),\n\t  Profile = __webpack_require__(15),\n\t  User = __webpack_require__(5);\n\t\n\t/**\n\t * Kuzzle security constructor\n\t *\n\t * @param kuzzle\n\t * @returns {Security}\n\t * @constructor\n\t */\n\tfunction Security(kuzzle) {\n\t\n\t  Object.defineProperty(this, 'kuzzle', {\n\t    value: kuzzle\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (action) {\n\t      return {\n\t        controller: 'security',\n\t        action: action\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * Retrieve a single Role using its unique role ID.\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchRole = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!id) {\n\t    throw new Error('Id parameter is mandatory for fetchRole function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on roles according to a filter\n\t *\n\t * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been created won’t be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t *\n\t */\n\tSecurity.prototype.searchRoles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = result.result.hits.map(function (doc) {\n\t      return new Role(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    cb(null, { total: result.result.total, roles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new role in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same role already exists: throw an error if sets to false.\n\t *        Replace the existing role otherwise\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.createRole: cannot create a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a role in Kuzzle.\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content},\n\t    action = 'updateRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateRole: cannot update a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete role.\n\t *\n\t * There is a small delay between role deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Role id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteRole = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - role id\n\t * @param {object} content - role content\n\t * @param {object} meta - role metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.role = function(id, content, meta) {\n\t  return new Role(this, id, content, meta);\n\t};\n\t\n\t\n\t/**\n\t * Get a specific profile from kuzzle\n\t *\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchProfile = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for fetchProfile function');\n\t  }\n\t\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n\t    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on profiles according to a filter\n\t *\n\t *\n\t * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been created won’t be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.searchProfiles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n\t    var\n\t      documents,\n\t      scrollId;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new Profile(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    if (response.result.scrollId) {\n\t      scrollId = response.result.scrollId;\n\t    }\n\t\n\t    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new profile in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same profile already exists: throw an error if sets to false.\n\t *        Replace the existing profile otherwise\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {array} policies - list of policies to attach to the new profile\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createProfile = function (id, policies, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t\n\t  if (policies) {\n\t    data.body = { policies: policies };\n\t  }\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a profile in Kuzzle.\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {array} policies - the list of policies to apply to this profile\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t\n\t  if (policies) {\n\t    data.body = {policies: policies};\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    var updatedContent = {};\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    Object.keys(res.result._source).forEach(function (property) {\n\t      updatedContent[property] = res.result._source[property];\n\t    });\n\t\n\t    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete profile.\n\t *\n\t * There is a small delay between profile deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteProfile = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t */\n\tSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Security.scrollProfiles: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n\t    var profiles = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (profile) {\n\t      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\t\n\t      newProfile.version = profile._version;\n\t\n\t      profiles.push(newProfile);\n\t    });\n\t\n\t    cb(null, {\n\t      total: result.result.total,\n\t      profiles: profiles,\n\t      scrollId: scrollId\n\t    });\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - profile id\n\t * @param {object} content - profile content\n\t * @param {object} meta - profile metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.profile = function(id, content, meta) {\n\t  return new Profile(this, id, content, meta);\n\t};\n\t\n\t/**\n\t * Get a specific user from kuzzle using its unique ID\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchUser = function (id, options, cb) {\n\t  var\n\t    data = {_id: id},\n\t    self = this;\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for fetchUser function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on user according to a filter\n\t *\n\t * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been created won’t be returned by this function.\n\t *\n\t * @param {Object} filters - same filters as documents filters\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.searchUsers = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n\t    var\n\t      documents,\n\t      scrollId = null;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new User(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    if (response.result.scrollId) {\n\t      scrollId = response.result.scrollId;\n\t    }\n\t\n\t    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Replace an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.replaceUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new restricted user in Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profile` in `content` must only contains the profile id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (content.profileIds) {\n\t    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateUser: cannot update an user without an user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete user.\n\t *\n\t * There is a small delay between user deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteUser = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t */\n\tSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Security.scrollUsers: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n\t    var users = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (user) {\n\t      var newUser = new User(self, user._id, user._source, user._meta);\n\t\n\t      newUser.version = user._version;\n\t\n\t      users.push(newUser);\n\t    });\n\t\n\t    cb(null, {\n\t      total: result.result.total,\n\t      users: users,\n\t      scrollId: scrollId\n\t    });\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - user id\n\t * @param {object} content - user content\n\t * @param {object} meta - user metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.user = function(id, content, meta) {\n\t  return new User(this, id, content, meta);\n\t};\n\t\n\t/**\n\t * Tells whether an action is allowed, denied or conditional based on the rights\n\t * rights provided as the first argument. An action is defined as a couple of\n\t * action and controller (mandatory), plus an index and a collection(optional).\n\t *\n\t * @param {object} rights - The rights rights associated to a user\n\t *                            (see getMyrights and getUserrights).\n\t * @param {string} controller - The controller to check the action onto.\n\t * @param {string} action - The action to perform.\n\t * @param {string} index - (optional) The name of index to perform the action onto.\n\t * @param {string} collection - (optional) The name of the collection to perform the action onto.\n\t *\n\t * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n\t *                   correspond to rights containing closures.\n\t *                   See also http://kuzzle.io/guide/#roles-definition\n\t */\n\tSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n\t  var filteredRights;\n\t\n\t  if (!rights || typeof rights !== 'object') {\n\t    throw new Error('rights parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!controller || typeof controller !== 'string') {\n\t    throw new Error('controller parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!action || typeof action !== 'string') {\n\t    throw new Error('action parameter is mandatory for isActionAllowed function');\n\t  }\n\t\n\t  // We filter in all the rights that match the request (including wildcards).\n\t  filteredRights = rights\n\t    .filter(function (right) {\n\t      return right.controller === controller || right.controller === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.action === action || right.action === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.index === index || right.index === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.collection === collection || right.collection === '*';\n\t    });\n\t\n\t  // Then, if at least one right allows the action, we return 'allowed'\n\t  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n\t    return 'allowed';\n\t  }\n\t  // If no right allows the action, we check for conditionals.\n\t  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n\t    return 'conditional';\n\t  }\n\t  // Otherwise we return 'denied'.\n\t  return 'denied';\n\t};\n\t\n\t\n\t/**\n\t * Gets the rights array of a given user.\n\t *\n\t * @param {string} userId The id of the user.\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {function} cb The callback containing the normalized array of rights.\n\t */\n\tSecurity.prototype.getUserRights = function (userId, options, cb) {\n\t  var\n\t    data = {_id: userId},\n\t    self = this;\n\t\n\t  if (!userId || typeof userId !== 'string') {\n\t    throw new Error('userId parameter is mandatory for getUserRights function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Create credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result._source);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete credentials of the specified <strategy> for the user <kuid> .\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieve a list of accepted fields per authentication strategy.\n\t *\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getAllCredentialFields = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve the list of accepted field names by the specified <strategy>.\n\t *\n\t * @param strategy\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Get credential information of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Check the existence of the specified <strategy>’s credentials for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Updates credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Validate credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\tmodule.exports = Security;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t}\n\t\n\tfunction bytesToUuid(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = byteToHex;\n\t  return bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\tmodule.exports = bytesToUuid;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Unique ID creation requires a high quality random # generator.  In the\n\t// browser this is a little complicated due to unknown quality of Math.random()\n\t// and inconsistent support for the `crypto` API.  We do the best we can via\n\t// feature-detection\n\tvar rng;\n\t\n\tvar crypto = (window).crypto || (window).msCrypto; // for IE 11\n\tif (crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(rnds8);\n\t    return rnds8;\n\t  };\n\t}\n\t\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return rnds;\n\t  };\n\t}\n\t\n\tmodule.exports = rng;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// kuzzle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap acd8f2ec6a57e2c5517f","var\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('./eventEmitter'),\n  Collection = require('./Collection.js'),\n  Security = require('./security/Security'),\n  MemoryStorage = require('./MemoryStorage'),\n  User = require('./security/User'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n */\nfunction Kuzzle (host, options, cb) {\n  var self = this;\n\n  if (!(this instanceof Kuzzle)) {\n    return new Kuzzle(host, options, cb);\n  }\n  KuzzleEventEmitter.call(this);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!host || host === '') {\n    throw new Error('host argument missing');\n  }\n\n  Object.defineProperties(this, {\n    // 'private' properties\n    cleanHistoryTimer: {\n      value: null,\n      writable: true\n    },\n    collections: {\n      value: {},\n      writable: true\n    },\n    connectCB: {\n      value: cb\n    },\n    eventActions: {\n      value: [\n        'connected',\n        'networkError',\n        'disconnected',\n        'reconnected',\n        'tokenExpired',\n        'loginAttempt',\n        'offlineQueuePush',\n        'offlineQueuePop',\n        'queryError',\n        'discarded'\n      ],\n      writable: false\n    },\n    queuing: {\n      value: false,\n      writable: true\n    },\n    requestHistory: {\n      value: {},\n      writable: true\n    },\n    state: {\n      value: 'initializing',\n      writable: true\n    },\n    subscriptions: {\n      /*\n       Contains the centralized subscription list in the following format:\n          pending: {\n            subscriptionUid_1: kuzzleRoomInstance_1,\n            subscriptionUid_2: kuzzleRoomInstance_2,\n            subscriptionUid_...: kuzzleRoomInstance_...\n          },\n          'roomId': {\n            subscriptionUid_1: kuzzleRoomInstance_1,\n            subscriptionUid_2: kuzzleRoomInstance_2,\n            subscriptionUid_...: kuzzleRoomInstance_...\n          }\n\n       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n       This structure also allows renewing subscriptions after a connection loss\n       */\n      value: {\n        pending: {}\n      },\n      writable: true\n    },\n    // configuration properties\n    autoReconnect: {\n      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n      writable: true,\n      enumerable: true\n    },\n    defaultIndex: {\n      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n      writable: true,\n      enumerable: true\n    },\n    reconnectionDelay: {\n      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n      writable: true,\n      enumerable: true\n    },\n    host: {\n      value: host,\n      writable: true,\n      enumerable: true\n    },\n    port: {\n      value: (options && typeof options.port === 'number') ? options.port : 7512,\n      enumerable: true,\n      writable: true\n    },\n    sslConnection: {\n      value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n      writable: true,\n      enumerable: true\n    },\n    autoQueue: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoReplay: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoResubscribe: {\n      value: true,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    volatile: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    /*\n      Offline queue use the following format:\n            [\n              {\n                ts: <query timestamp>,\n                query: 'query',\n                cb: callbackFunction\n              }\n            ]\n     */\n    offlineQueue: {\n      value: [],\n      enumerable: true,\n      writable: true\n    },\n    queueFilter: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    queueMaxSize: {\n      value: 500,\n      enumerable: true,\n      writable: true\n    },\n    queueTTL: {\n      value: 120000,\n      enumerable: true,\n      writable: true\n    },\n    replayInterval: {\n      value: 10,\n      enumerable: true,\n      writable: true\n    },\n    jwtToken: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    offlineQueueLoader: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    sdkVersion: {\n      value: (typeof SDKVERSION === 'undefined') ? require('../package.json').version : SDKVERSION,\n      writable: false\n    }\n  });\n\n  if (options) {\n    Object.keys(options).forEach(function (opt) {\n      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n        self[opt] = options[opt];\n      }\n    });\n\n    if (options.offlineMode === 'auto' && this.autoReconnect) {\n      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n    }\n  }\n\n  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n  Object.defineProperty(this, 'isValid', {\n    value: function () {\n      if (self.state === 'disconnected') {\n        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n      }\n    }\n  });\n\n  // Helper function copying headers to the query data\n  Object.defineProperty(this, 'addHeaders', {\n    value: function (query, headers) {\n      Object.keys(headers).forEach(function (header) {\n        if (!query[header]) {\n          query[header] = headers[header];\n        }\n      });\n\n      return query;\n    }\n  });\n\n  /**\n   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n   * and is called by these methods\n   */\n  Object.defineProperty(this, 'callbackRequired', {\n    value: function (errorMessagePrefix, callback) {\n      if (!callback || typeof callback !== 'function') {\n        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n      }\n    }\n  });\n\n  /**\n   * Create an attribute security that embed all methods to manage Role, Profile and User\n   */\n  Object.defineProperty(this, 'security', {\n    value: new Security(this),\n    enumerable: true\n  });\n\n  Object.defineProperty(this, 'memoryStorage', {\n    value: new MemoryStorage(this),\n    enumerable: true\n  });\n\n  Object.defineProperties(this, {\n    eventTimeout: {\n      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200,\n      writeable: false\n    }\n  });\n\n  Object.defineProperty(this, 'protectedEvents', {\n    value: {\n      connected: {timeout: this.eventTimeout},\n      error: {timeout: this.eventTimeout},\n      disconnected: {timeout: this.eventTimeout},\n      reconnected: {timeout: this.eventTimeout},\n      tokenExpired: {timeout: this.eventTimeout},\n      loginAttempt: {timeout: this.eventTimeout}\n    },\n    writeable: false\n  });\n\n  if (!options || !options.connect || options.connect === 'auto') {\n    this.connect();\n  } else {\n    this.state = 'ready';\n  }\n\n  this.cleanHistoryTimer = setInterval(function () { cleanHistory(self.requestHistory); }, 1000);\n\n  if (this.bluebird) {\n    return this.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n          'listCollections', 'createIndex', 'listIndexes', 'login', 'logout',\n          'now', 'query', 'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n        ];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\nKuzzle.prototype = Object.create(KuzzleEventEmitter.prototype);\nKuzzle.prototype.constructor = Kuzzle;\n\n/**\n* Emit an event to all registered listeners\n* An event cannot be emitted multiple times before a timeout has been reached.\n*/\nKuzzle.prototype.emit = function(eventName) {\n  var\n    now = Date.now(),\n    protectedEvent = this.protectedEvents[eventName];\n\n  if (protectedEvent) {\n    if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n      return false;\n    }\n    protectedEvent.lastEmitted = now;\n  }\n  KuzzleEventEmitter.prototype.emit.apply(this, arguments);\n};\nKuzzle.prototype.emitEvent = Kuzzle.prototype.emit;\n\n/**\n * Connects to a Kuzzle instance using the provided host name.\n * @returns {Object} this\n */\nKuzzle.prototype.connect = function () {\n  var self = this;\n\n  if (self.network) {\n    self.disconnect();\n  }\n\n  self.network = networkWrapper(self.host, self.port, self.sslConnection);\n\n  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n    return self;\n  }\n\n  self.state = 'connecting';\n  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\n  self.network.onConnect(function () {\n    self.state = 'connected';\n    renewAllSubscriptions.call(self);\n    dequeue.call(self);\n    self.emitEvent('connected');\n\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n  });\n\n  self.network.on('discarded', function (data) {\n    self.emitEvent('discarded', data);\n  });\n\n  self.network.onConnectError(function (error) {\n    var connectionError = new Error('Unable to connect to kuzzle proxy server at \"' + self.host + ':' + self.port + '\"');\n\n    connectionError.internal = error;\n    self.state = 'error';\n    self.emitEvent('networkError', connectionError);\n\n    disableAllSubscriptions.call(self);\n\n    if (self.connectCB) {\n      self.connectCB(connectionError);\n    }\n  });\n\n  self.network.onDisconnect(function () {\n    self.state = 'offline';\n\n    if (!self.autoReconnect) {\n      self.disconnect();\n    }\n\n    if (self.autoQueue) {\n      self.queuing = true;\n    }\n\n    self.emitEvent('disconnected');\n  });\n\n  self.network.onReconnect(function () {\n    var reconnect = function () {\n      // renew subscriptions\n      if (self.autoResubscribe) {\n        renewAllSubscriptions.call(self);\n      }\n\n      // replay queued requests\n      if (self.autoReplay) {\n        cleanQueue.call(self);\n        dequeue.call(self);\n      }\n\n      // alert listeners\n      self.emitEvent('reconnected');\n    };\n\n    self.state = 'connected';\n\n    if (self.jwtToken) {\n      self.checkToken(self.jwtToken, function (err, res) {\n        // shouldn't obtain an error but let's invalidate the token anyway\n        if (err || !res.valid) {\n          self.jwtToken = undefined;\n          self.emitEvent('tokenExpired');\n        }\n\n        reconnect();\n      });\n    } else {\n      reconnect();\n    }\n  });\n\n  return this;\n};\n\n/**\n * Set the jwtToken used to query kuzzle\n * @param token\n * @returns {Kuzzle}\n */\nKuzzle.prototype.setJwtToken = function(token) {\n  if (typeof token === 'string') {\n    this.jwtToken = token;\n  } else if (typeof token === 'object') {\n    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n      this.jwtToken = token.result.jwt;\n    } else {\n      this.emitEvent('loginAttempt', {\n        success: false,\n        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n      });\n\n      return this;\n    }\n  } else {\n    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n    return this;\n  }\n\n  renewAllSubscriptions.call(this);\n  this.emitEvent('loginAttempt', {success: true});\n  return this;\n};\n\n/**\n * Unset the jwtToken used to query kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.unsetJwtToken = function() {\n  this.jwtToken = undefined;\n\n  removeAllSubscriptions.call(this);\n\n  return this;\n};\n\n/**\n * Get the jwtToken used by kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.getJwtToken = function() {\n  return this.jwtToken;\n};\n\n/**\n * Send login request to kuzzle with credentials\n * If login success, store the jwtToken into kuzzle object\n *\n * @param strategy\n * @param credentials\n * @param expiresIn\n * @param cb\n */\nKuzzle.prototype.login = function (strategy) {\n  var\n    self = this,\n    request = {\n      body: {},\n      strategy: strategy\n    },\n    cb = null;\n\n  if (!strategy || typeof strategy !== 'string') {\n    throw new Error('Kuzzle.login: strategy required');\n  }\n\n  // Handle arguments (credentials, expiresIn, cb)\n  if (arguments[1]) {\n    if (typeof arguments[1] === 'object') {\n      request.body = arguments[1];\n    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n      request.expiresIn = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n    }\n  }\n  if (arguments[2]) {\n    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n      request.expiresIn = arguments[2];\n    } else if (typeof arguments[2] === 'function') {\n      cb = arguments[2];\n    }\n  }\n  if (arguments[3] && typeof arguments[3] === 'function') {\n    cb = arguments[3];\n  }\n\n  this.query({controller: 'auth', action: 'login'}, request, {queuable: false}, function(error, response) {\n    if (!error) {\n      if (response.result.jwt) {\n        self.setJwtToken(response.result.jwt);\n      }\n\n      cb && cb(null, response.result);\n    }\n    else {\n      cb && cb(error);\n      self.emitEvent('loginAttempt', {success: false, error: error.message});\n    }\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the current user.\n *\n * @param credentials\n * @param strategy\n * @param options\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.createMyCredentials = function (strategy, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'createMyCredentials'}, {strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the current user.\n *\n * @param strategy\n * @param options\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.deleteMyCredentials = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'deleteMyCredentials'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Get credential information of the specified <strategy> for the current user.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nKuzzle.prototype.getMyCredentials = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'getMyCredentials'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Update credentials of the specified <strategy> for the current user.\n *\n * @param strategy\n * @param credentals\n * @param options\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.updateMyCredentials = function (strategy, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'updateMyCredentials'}, {strategy: strategy, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the current user.\n *\n * @param strategy\n * @param credentials\n * @param options\n * @param cb\n */\nKuzzle.prototype.validateMyCredentials = function (strategy, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'validateMyCredentials'}, {strategy: strategy, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Create a kuzzle index\n *\n * @param {string} index\n * @param {object} [options]\n * @param {responseCallback} cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.createIndex = function (index, options, cb) {\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.createIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'index', action: 'create', index: index}, {}, options, typeof cb !== 'function' ? null : function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return this;\n};\n\n/**\n * Send logout request to kuzzle with jwtToken.\n *\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.logout = function (cb) {\n  var\n    self = this,\n    request = {\n      action: 'logout',\n      controller: 'auth',\n      requestId: uuidv4(),\n      body: {}\n    };\n\n  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, typeof cb !== 'function' ? null : function(error) {\n    cb(error, self);\n  });\n\n  self.unsetJwtToken();\n\n  return self;\n};\n\n/**\n * Checks whether a given jwt token still represents a valid session in Kuzzle.\n *\n * @param  {string}   token     The jwt token to check\n * @param  {function} cb  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n */\nKuzzle.prototype.checkToken = function (token, cb) {\n  var\n    request = {\n      body: {\n        token: token\n      }\n    };\n\n  this.callbackRequired('Kuzzle.checkToken', cb);\n\n  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Fetches the current user.\n *\n * @param  {function} cb  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n */\nKuzzle.prototype.whoAmI = function (cb) {\n  var self = this;\n\n  self.callbackRequired('Kuzzle.whoAmI', cb);\n\n  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, res) {\n    cb(err, err ? undefined : new User(self.security, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Gets the rights array of the currently logged user.\n *\n * @param {object} [options] - Optional parameters\n * @param  {function} cb The callback containing the normalized array of rights.\n */\nKuzzle.prototype.getMyRights = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.callbackRequired('Kuzzle.getMyRights', cb);\n\n  self.query({controller: 'auth', action:'getMyRights'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Update current user in Kuzzle.\n *\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Kuzzle} this object\n */\nKuzzle.prototype.updateSelf = function (content, options, cb) {\n  var\n    self = this,\n    data = {},\n    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data.body = content;\n\n  self.query(queryArgs, data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return this;\n};\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n */\nfunction cleanQueue () {\n  var\n    self = this,\n    now = Date.now(),\n    lastDocumentIndex = -1;\n\n  if (self.queueTTL > 0) {\n    self.offlineQueue.forEach(function (query, index) {\n      if (query.ts < now - self.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      self.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(function (droppedRequest) {\n          self.emitEvent('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n    self.offlineQueue\n      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n      .forEach(function (droppedRequest) {\n        self.emitEvent('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n\n/**\n * Clean history from requests made more than 10s ago\n */\nfunction cleanHistory (requestHistory) {\n  var\n    now = Date.now();\n\n  Object.keys(requestHistory).forEach(function (key) {\n    if (requestHistory[key] < now - 10000) {\n      delete requestHistory[key];\n    }\n  });\n}\n\n/**\n * Emit a request to Kuzzle\n *\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (request, cb) {\n  var\n    self = this;\n\n  if (self.jwtToken !== undefined || cb) {\n    self.network.once(request.requestId, function (response) {\n      var error = null;\n\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        self.jwtToken = undefined;\n        self.emitEvent('tokenExpired', request, cb);\n      }\n\n      if (response.error) {\n        error = new Error(response.error.message);\n        Object.assign(error, response.error);\n        error.status = response.status;\n        self.emitEvent('queryError', error, request, cb);\n      }\n\n      if (cb) {\n        cb(error, response);\n      }\n    });\n  }\n\n  this.network.send(request);\n\n  // Track requests made to allow Room.subscribeToSelf to work\n  self.requestHistory[request.requestId] = Date.now();\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue () {\n  var\n    self = this,\n    additionalQueue,\n    uniqueQueue = {},\n    dequeuingProcess = function () {\n      if (self.offlineQueue.length > 0) {\n        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\n        setTimeout(function () {\n          dequeuingProcess();\n        }, Math.max(0, self.replayInterval));\n      } else {\n        self.queuing = false;\n      }\n    };\n\n  if (self.offlineQueueLoader) {\n    if (typeof self.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n    }\n\n    additionalQueue = self.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      self.offlineQueue = additionalQueue\n        .concat(self.offlineQueue)\n        .filter(function (request) {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\n/**\n * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n * successful login attempt\n */\nfunction renewAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.renew(subscription.callback);\n    });\n  });\n}\n\n/**\n * Remove all registered subscriptions. Triggered either by a logout query or by un-setting the token\n */\nfunction removeAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.unsubscribe();\n    });\n  });\n}\n\n/**\n * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n * insertion.\n *\n * @param {string} event - name of the global event to subscribe to\n * @param {function} listener - callback to invoke each time an event is fired\n */\nKuzzle.prototype.addListener = function(event, listener) {\n  this.isValid();\n\n  if (this.eventActions.indexOf(event) === -1) {\n    throw new Error('[' + event + '] is not a known event. Known events: ' + this.eventActions.toString());\n  }\n\n  return KuzzleEventEmitter.prototype.addListener.call(this, event, listener);\n};\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method returns all available statistics from Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getAllStatistics = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n  this.query({controller:'server', action: 'getAllStats'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n *\n * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n  var\n    queryCB,\n    body;\n\n  if (!cb) {\n    if (arguments.length === 1) {\n      cb = arguments[0];\n      options = null;\n      timestamp = null;\n    } else {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'object') {\n        options = arguments[0];\n        timestamp = null;\n      } else {\n        timestamp = arguments[0];\n        options = null;\n      }\n    }\n  }\n\n  queryCB = function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, timestamp ? res.result.hits : [res.result]);\n  };\n\n  this.callbackRequired('Kuzzle.getStatistics', cb);\n\n  body = timestamp ? {body: {startTime: timestamp}} : {};\n  this.query({controller: 'server', action: timestamp ? 'getStats' : 'getLastStats'}, body, options, queryCB);\n};\n\n/**\n * Create a new instance of a Collection object.\n * If no index is specified, takes the default index.\n *\n * @param {string} collection - The name of the data collection you want to manipulate\n * @param {string} [index] - The name of the data index containing the data collection\n * @returns {Collection} A Collection instance\n */\nKuzzle.prototype.collection = function(collection, index) {\n  this.isValid();\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Unable to create a new data collection object: no index specified');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  if (typeof index !== 'string' || typeof collection !== 'string') {\n    throw new Error('Invalid index or collection argument: string expected');\n  }\n\n  if (!this.collections[index]) {\n    this.collections[index] = {};\n  }\n\n  if (!this.collections[index][collection]) {\n    this.collections[index][collection] = new Collection(this, collection, index);\n  }\n\n  return this.collections[index][collection];\n};\n\n/**\n * Empties the offline queue without replaying it.\n *\n * @returns {Kuzzle}\n */\nKuzzle.prototype.flushQueue = function () {\n  this.offlineQueue = [];\n  return this;\n};\n\n/**\n * Returns the list of known persisted data collections.\n *\n * @param {string} [index] - Index containing collections to be listed\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.listCollections = function () {\n  var\n    index,\n    options,\n    cb,\n    args = Array.prototype.slice.call(arguments),\n    query;\n\n  args.forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.listCollections: index required');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.listCollections', cb);\n\n  query = {type: options && options.type || 'all'};\n\n  this.query({index: index, controller: 'collection', action: 'list'}, query, options, function (err, res) {\n    cb(err, err ? undefined : res.result.collections);\n  });\n};\n\n/**\n * Returns the list of existing indexes in Kuzzle\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.listIndexes = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.listIndexes', cb);\n\n  this.query({controller: 'index', action: 'list'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.indexes);\n  });\n};\n\n/**\n * Disconnects from Kuzzle and invalidate this instance.\n */\nKuzzle.prototype.disconnect = function () {\n  var collection;\n\n  clearInterval(this.cleanHistoryTimer);\n  this.state = 'disconnected';\n  this.network.close();\n  this.network = null;\n\n  for (collection in this.collections) {\n    if (this.collections.hasOwnProperty(collection)) {\n      delete this.collections[collection];\n    }\n  }\n};\n\n/**\n * Returns the server informations\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getServerInfo = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n  this.query({controller: 'server', action: 'info'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.serverInfo);\n  });\n};\n\n/**\n * Forces an index refresh\n *\n * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n * @returns {Kuzzle}\n */\nKuzzle.prototype.refreshIndex = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.refreshIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.query({ index: index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\n  return this;\n};\n\n/**\n * Returns de current autoRefresh status for the given index\n *\n * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optinal arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getAutoRefresh = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.getAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n  this.query({ index: index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n};\n\n/**\n * (Un)Sets the autoRefresh flag on the given index\n *\n * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n * @param {boolean} autoRefresh - The autoRefresh value to set\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query result\n * @returns {object} this\n */\nKuzzle.prototype.setAutoRefresh = function () {\n  var\n    index,\n    autoRefresh,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'boolean':\n        autoRefresh = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.setAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (autoRefresh === undefined) {\n    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n  }\n\n  this.query({ index: index, controller: 'index', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\n  return this;\n};\n\n/**\n * Return the current Kuzzle's UTC Epoch time, in milliseconds\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.now = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.now', cb);\n\n  this.query({controller: 'server', action: 'now'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.now);\n  });\n};\n\n/**\n * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n * Base method used to send read queries to Kuzzle\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} queryArgs - Query configuration\n * @param {object} query - The query data\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n  var\n    attr,\n    object = {\n      action: queryArgs.action,\n      controller: queryArgs.controller,\n      volatile: this.volatile\n    },\n    self = this;\n\n  this.isValid();\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options) {\n    if (options.queuable === false && self.state === 'offline') {\n      return self;\n    }\n\n    if (options.refresh) {\n      object.refresh = options.refresh;\n    }\n\n    if (typeof options.from !== 'undefined' && options.from !== null) {\n      object.from = options.from;\n    }\n\n    if (options.size) {\n      object.size = options.size;\n    }\n\n    if (options.scroll) {\n      object.scroll = options.scroll;\n    }\n\n    if (options.scrollId) {\n      object.scrollId = options.scrollId;\n    }\n\n    if (options.volatile) {\n      Object.keys(options.volatile).forEach(function (meta) {\n        object.volatile[meta] = options.volatile[meta];\n      });\n    }\n  }\n\n  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n    throw new Error('Invalid query parameter: ' + query);\n  }\n\n  if (query.volatile) {\n    Object.keys(query.volatile).forEach(function (meta) {\n      object.volatile[meta] = query.volatile[meta];\n    });\n  }\n\n  for (attr in query) {\n    if (attr !== 'volatile' && query.hasOwnProperty(attr)) {\n      object[attr] = query[attr];\n    }\n  }\n\n  object = self.addHeaders(object, this.headers);\n\n  /*\n   * Do not add the token for the checkToken route, to avoid getting a token error when\n   * a developer simply wish to verify his token\n   */\n  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n    object.jwt = self.jwtToken;\n  }\n\n  if (queryArgs.collection) {\n    object.collection = queryArgs.collection;\n  }\n\n  if (queryArgs.index) {\n    object.index = queryArgs.index;\n  }\n\n  if (!object.requestId) {\n    object.requestId = uuidv4();\n  }\n\n  object.volatile.sdkVersion = this.sdkVersion;\n\n  if (self.state === 'connected' || (options && options.queuable === false)) {\n    if (self.state === 'connected') {\n      emitRequest.call(this, object, cb);\n    } else {\n      discardRequest(object, cb);\n    }\n  } else if (self.queuing || (options && options.queuable === true) || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n    cleanQueue.call(this, object, cb);\n    if (!self.queueFilter || self.queueFilter(object)) {\n      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n    } else {\n      discardRequest(object, cb);\n    }\n  }\n  else {\n    discardRequest(object, cb);\n  }\n\n  return self;\n};\n\n/**\n * Replays the requests queued during offline mode.\n * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n */\nKuzzle.prototype.replayQueue = function () {\n  if (this.state !== 'offline' && !this.autoReplay) {\n    cleanQueue.call(this);\n    dequeue.call(this);\n  }\n\n  return this;\n};\n\n/**\n * Sets the default Kuzzle index\n *\n * @param index\n * @returns this\n */\nKuzzle.prototype.setDefaultIndex = function (index) {\n  if (typeof index !== 'string') {\n    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n  }\n\n  if (index.length === 0) {\n    throw new Error('Cannot set an empty index as the default index');\n  }\n\n  this.defaultIndex = index;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzle.prototype.setHeaders = function (content, replace) {\n  var self = this;\n\n  if (typeof content !== 'object' || Array.isArray(content)) {\n    throw new Error('Expected a content object, received a ' + typeof content);\n  }\n\n  if (replace) {\n    self.headers = content;\n  } else {\n    Object.keys(content).forEach(function (key) {\n      self.headers[key] = content[key];\n    });\n  }\n\n  return self;\n};\n\n/**\n * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.startQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = true;\n  }\n  return this;\n};\n\n/**\n * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.stopQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = false;\n  }\n\n  return this;\n};\n\nfunction discardRequest(object, cb) {\n  if (cb) {\n    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n  }\n}\n\nfunction disableAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.subscribing = false;\n    });\n  });\n}\n\nmodule.exports = Kuzzle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Kuzzle.js\n// module id = 0\n// module chunks = 0","function SecurityDocument(Security, id, content, meta) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: Security.kuzzle\n    },\n    Security: {\n      value: Security\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    meta: {\n      value: meta || {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function won’t be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {SecurityDocument} this\n */\nSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {SecurityDocument} this\n */\nSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = SecurityDocument;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/SecurityDocument.js\n// module id = 1\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * Document is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {Collection} collection - an instanciated Collection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @param {object} [meta] - Initializes this document with the provided meta\n * @constructor\n */\nfunction Document(collection, documentId, content, meta) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: collection,\n      enumerable: false\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: false\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(collection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    meta: {\n      value: meta || {},\n      enumerable: true,\n      writable: false\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  if (this.version) {\n    data._version = this.version;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.delete: cannot delete a document without a document ID');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n    cb(err, err ? undefined : self.id);\n  });\n};\n\n/**\n * Checks if this document exists in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.exists = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('Document.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n    if (error) {\n      return cb && cb(error);\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function won’t be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nDocument.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n\nmodule.exports = Document;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Document.js\n// module id = 2\n// module chunks = 0","function KuzzleEventEmitter() {\n  if (typeof window !== 'undefined') {\n    this._events = {};\n    this._onceEvents = {};\n  }\n}\n\nif (typeof window === 'undefined') {\n  KuzzleEventEmitter.prototype = require('events').prototype;\n  KuzzleEventEmitter.prototype.constructor = KuzzleEventEmitter;\n} else {\n\n  KuzzleEventEmitter.prototype.on = function(eventName, listener) {\n    var\n      listenerType = typeof listener,\n      listeners;\n\n    if (!eventName || !listener) {\n      return;\n    }\n\n    if (listenerType !== 'function') {\n      throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n    }\n\n    listeners = this.listeners(eventName);\n    // only add once\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener);\n    }\n\n    // Handles `newListener` event (see https://nodejs.org/api/events.html#events_event_newlistener)\n    this.emit('newListener', eventName, listener);\n\n    return this;\n  };\n  KuzzleEventEmitter.prototype.addListener = KuzzleEventEmitter.prototype.on;\n\n  KuzzleEventEmitter.prototype.prependListener = function(eventName, listener) {\n    var listeners;\n\n    if (!eventName || !listener) {\n      return;\n    }\n\n    listeners = this.listeners(eventName);\n    // only add once\n    if (listeners.indexOf(listener) === -1) {\n      this._events[eventName] = new Array(listener).concat(listeners);\n    }\n\n    // Handles `newListener` event (see https://nodejs.org/api/events.html#events_event_newlistener)\n    this.emit('newListener', eventName, listener);\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.once = function(eventName, listener) {\n    var onceListeners;\n\n    if (!eventName || !listener) {\n      return;\n    }\n\n\n    this.on(eventName, listener);\n    onceListeners = this._onceEvents[eventName] = this._onceEvents[eventName] || {};\n    onceListeners[listener] = true;\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.prependOnceListener = function(eventName, listener) {\n    var onceListeners;\n\n    if (!eventName || !listener) {\n      return;\n    }\n    this.prependListener(eventName, listener);\n    onceListeners = this._onceEvents[eventName] = this._onceEvents[eventName] || {};\n    onceListeners[listener] = true;\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.removeListener = function(eventName, listener) {\n    var\n      index,\n      listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return;\n    }\n\n    index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    // Handles `removeListener` event (see https://nodejs.org/api/events.html#events_event_removeListener)\n    this.emit('removeListener', eventName, listener);\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.removeAllListeners = function(eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n      delete this._onceEvents[eventName];\n    } else {\n      this._events = [];\n      this._onceEvents = [];\n    }\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.emit = function(eventName) {\n    var\n      i = 0,\n      listeners,\n      args,\n      onceListeners,\n      notifyList;\n\n    listeners = this._events && this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return;\n    }\n\n    args = Array.prototype.slice.call(arguments, 1);\n    // once stuff\n    onceListeners = this._onceEvents && this._onceEvents[eventName] || {};\n\n    notifyList = new Array();\n\n    listener = listeners[i];\n    while (listener) {\n      // trigger listener\n      notifyList.push(listener);\n      // get next listener\n      if (onceListeners[listener]) {\n        // remove listener\n        this.removeListener(eventName,listener);\n        // unset once flag\n        delete onceListeners[listener];\n      } else {\n        i++;\n      }\n      listener = listeners[i];\n    }\n    for (item in notifyList) {\n      // trigger listener\n      if (notifyList[item] !== undefined) {\n        notifyList[item].apply(this, args);\n      }\n    }\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.eventNames = function () {\n    return Object.keys(this._events);\n  };\n\n  KuzzleEventEmitter.prototype.listenerCount = function (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  };\n\n  KuzzleEventEmitter.prototype.listeners = function (eventName) {\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n    return this._events[eventName];\n  };\n\n}\n// Aliases:\nKuzzleEventEmitter.prototype.emitEvent = KuzzleEventEmitter.prototype.emit;\nKuzzleEventEmitter.prototype.off = KuzzleEventEmitter.prototype.removeListener;\n\nmodule.exports = KuzzleEventEmitter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/eventEmitter/index.js\n// module id = 3\n// module chunks = 0","var\n  KuzzleEventEmitter = require('../../eventEmitter');\n\nfunction WSNode(host, port, ssl) {\n  var self = this;\n  KuzzleEventEmitter.call(this);\n\n  this.WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : require('ws');\n  this.host = host;\n  this.port = port;\n  this.ssl = ssl;\n  this.client = null;\n  this.wasConnected = false;\n  this.retrying = false;\n  this.lasturl = null;\n  this.stopRetryingToConnect = false;\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   * @returns {Object} Socket\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    var\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      options = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    if (url !== this.lasturl) {\n      self.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new this.WebSocket(url, options);\n\n    this.client.onopen = function () {\n      if (self.wasConnected) {\n        self.emitEvent('reconnect');\n      }\n      else {\n        self.emitEvent('connect');\n      }\n      self.wasConnected = true;\n      self.stopRetryingToConnect = false;\n    };\n\n    this.client.onclose = function (closeEvent, message) {\n      var error;\n      var status;\n      var reason = message;\n\n      if (typeof closeEvent === 'number') {\n        status = closeEvent;\n      }\n      else {\n        status = closeEvent.code;\n\n        if (closeEvent.reason) {\n          reason = closeEvent.reason;\n        }\n      }\n\n      if (status === 1000) {\n        self.emitEvent('disconnect');\n      }\n      else {\n        error = new Error(reason);\n        error.status = status;\n\n        onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n      }\n    };\n\n    this.client.onerror = function (error) {\n      if (!(error instanceof Error)) {\n        error = new Error(error);\n      }\n\n      onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n    };\n\n    this.client.onmessage = function (payload) {\n      var data = JSON.parse(payload.data || payload);\n\n      if (data.room) {\n        self.emitEvent(data.room, data);\n      }\n      else {\n        self.emitEvent('discarded', data);\n      }\n    };\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    this.addListener('connect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    this.addListener('networkError', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    this.addListener('disconnect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    this.addListener('reconnect', callback);\n  };\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.removeAllListeners();\n    this.wasConnected = false;\n    this.client.close();\n    this.client = null;\n    self.stopRetryingToConnect = true;\n  };\n}\nWSNode.prototype = Object.create(KuzzleEventEmitter.prototype);\nWSNode.prototype.constructor = WSNode;\n\n\n/**\n * Called when the connection closes with an error state\n *\n * @param {WSNode} \n * @param {boolean} autoReconnect\n * @param {number} reconnectionDelay\n * @param {Error} error\n */\nfunction onClientNetworkError(ws, autoReconnect, reconnectionDelay, error) {\n  if (autoReconnect && !ws.retrying && !ws.stopRetryingToConnect) {\n    ws.retrying = true;\n    setTimeout(function () {\n      ws.retrying = false;\n      ws.connect(autoReconnect, reconnectionDelay);\n    }, reconnectionDelay);\n  }\n\n  ws.emitEvent('networkError', error);\n}\n\nmodule.exports = WSNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/wrappers/websocket.js\n// module id = 4\n// module chunks = 0","var\n  KuzzleSecurityDocument = require('./SecurityDocument');\n\n/**\n * @param {Security} Security\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction User(Security, id, content, meta) {\n  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    },\n    credentials: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: User\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {User} this\n */\nUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * @param {object} credentials\n */\nUser.prototype.setCredentials = function (credentials) {\n  if (typeof credentials !== 'object') {\n    throw new Error('Parameter \"credentials\" must be a object');\n  }\n\n  this.credentials = credentials;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {User} this\n */\nUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Creates this user into Kuzzle\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.create = function (options, cb) {\n  var\n    data = this.creationSerialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n\n/**\n * Replaces the latest version of this user in Kuzzle by the current content of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.replace = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n\n  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content, meta: this.meta};\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.creationSerialize = function () {\n  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array.<string>} the associated profiles IDs\n */\nUser.prototype.getProfileIds = function () {\n  return this.content.profileIds || [];\n};\n\n/**\n * Return the associated Profile objects\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nUser.prototype.getProfiles = function (options, cb) {\n  var \n    self = this,\n    fetchedProfiles = [],\n    errored = false;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\n  if (!self.content.profileIds) {\n    return cb(null, fetchedProfiles);\n  }\n\n  self.content.profileIds.forEach(function (profileId) {\n    self.Security.fetchProfile(profileId, options, function (error, profile) {\n      if (error) {\n        if (errored) {\n          return;\n        }\n\n        errored = true; // prevents multiple callback resolutions\n        return cb(error);\n      }\n\n      fetchedProfiles.push(profile);\n\n      if (fetchedProfiles.length === self.content.profileIds.length) {\n        cb(null, fetchedProfiles);\n      }\n    });\n  });\n};\n\nmodule.exports = User;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/User.js\n// module id = 5\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/uuid/v4.js\n// module id = 6\n// module chunks = 0","var\n  KuzzleSearchResult = require('./SearchResult'),\n  Document = require('./Document'),\n  CollectionMapping = require('./CollectionMapping'),\n  Room = require('./Room'),\n  SubscribeResult = require('./SubscribeResult');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n *\n * @property {string} collection\n * @property {string} index\n * @property {Kuzzle} kuzzle\n * @property {Array.<string>} collection\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} collection - name of the data collection to handle\n * @param {string} index - Index containing the data collection\n * @constructor\n */\nfunction Collection(kuzzle, collection, index) {\n  if (!index || !collection) {\n    throw new Error('The Collection object constructor needs an index and a collection arguments');\n  }\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.count = function (filters, options, cb) {\n  var\n    query;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.count', cb);\n\n  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n    cb(err, err ? undefined : res.result.count);\n  });\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.create = function (options, cb) {\n  var data = {},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n *        If the same document already exists:\n *          - resolves with an error if set to \"error\".\n *          - replaces the existing document if set to \"replace\"\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a Document object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options && options.ifExist) {\n    if (options.ifExist === 'replace') {\n      action = 'createOrReplace';\n    }\n    else if (options.ifExist !== 'error') {\n      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n    }\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  data = self.kuzzle.addHeaders(data, self.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    var doc;\n\n    if (err) {\n      return cb(err);\n    }\n\n    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n    doc.version = res.result._version;\n    cb(null, doc);\n  });\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Collection} this\n */\nCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = {query: arg};\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    if (err) {\n      cb(err);\n    }\n    else {\n      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n    }\n  });\n\n  return this;\n};\n\n/**\n * Deletes the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.deleteSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Returns a boolean indicating whether or not a document with provided ID exists.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} options [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.documentExists = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.fetch', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n};\n\n/**\n * Instantiates a CollectionMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\n  kuzzleMapping = new CollectionMapping(this);\n  kuzzleMapping.refresh(options, cb);\n};\n\n/**\n * Create the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Create or replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create or replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Delete specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to delete\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Get specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Update the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to update\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Retrieves the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.getSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a Document instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\n\nCollection.prototype.search = function (filters, options, cb) {\n  var\n    query,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.search', cb);\n\n  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      result.result.aggregations ? result.result.aggregations : {},\n      options,\n      filters,\n      options.previous || null\n    ));\n  });\n};\n\n/**\n * A \"scroll\" option can be passed to search queries, creating persistent\n * paginated results.\n * This method can be used to manually get the next page of a search result,\n * instead of using KuzzleSearchResult.next()\n *\n * @param {string} scrollId\n * @param {object} [options]\n * @param {object} [filters]\n * @param {responseCallback} cb\n */\nCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Collection.scroll: scrollId is required');\n  }\n\n  if (!cb) {\n    cb = filters;\n    filters = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      {},\n      options,\n      filters,\n      options.previous || null\n    ));\n  });\n\n  return this;\n};\n\n/**\n * Retrieves next result of a search with scroll query.\n *\n * @param {string} scrollId\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n  var\n    data = { scrollId: scrollId };\n\n  if (!scrollId) {\n    throw new Error('Collection.scrollSpecifications: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\n  if (options && options.scroll) {\n    data.scroll = options.scroll;\n  }\n\n  this.kuzzle.query(\n    { controller: 'collection', action: 'scrollSpecifications'},\n    this.kuzzle.addHeaders(data, this.headers),\n    options,\n    function (err, res) {\n      cb (err, err ? undefined : res.result);\n    }\n  );\n};\n\n/**\n * Searches specifications across indexes/collections according to the provided filters\n *\n * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.searchSpecifications = function (filters, options, cb) {\n  var\n    data = { body: { query: filters } },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} cb - called for each new notification\n * @returns {*} KuzzleSubscribeResult object\n */\nCollection.prototype.subscribe = function (filters, options, cb) {\n  var\n    room,\n    subscribeResult;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.subscribe', cb);\n\n  subscribeResult = new SubscribeResult();\n  room = new Room(this, options);\n\n  room.renew(filters, cb, subscribeResult.done.bind(subscribeResult));\n\n  return subscribeResult;\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options && options.retryOnConflict) {\n    data.retryOnConflict = options.retryOnConflict;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    (new Document(self, res.result._id)).refresh(cb);\n  });\n\n  return self;\n};\n\n/**\n * Updates the current specifications of this collection\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Validates the provided specifications\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result.valid);\n  });\n};\n\n/**\n * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nCollection.prototype.document = function (id, content) {\n  return new Document(this, id, content);\n};\n\n/**\n * Instantiate a new Room object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [options] - subscription configuration\n * @constructor\n */\nCollection.prototype.room = function (options) {\n  return new Room(this, options);\n};\n\n/**\n * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n * @constructor\n */\nCollection.prototype.collectionMapping = function (mapping) {\n  return new CollectionMapping(this, mapping);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nCollection.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = Collection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Collection.js\n// module id = 7\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you won’t be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} collection - Instance of the inherited Collection object\n * @param {object} [mapping] - mappings\n * @constructor\n */\nfunction CollectionMapping(collection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(collection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set', 'setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nCollectionMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the “apply” function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nCollectionMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n      }\n    } else {\n      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function won’t be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {CollectionMapping}\n */\nCollectionMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nCollectionMapping.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = CollectionMapping;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CollectionMapping.js\n// module id = 8\n// module chunks = 0","// Parameter mutualization\nvar\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true, \n    required: ['_id', 'cursor'], \n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']},\n  setIdFieldValue = {required: ['_id', 'field', 'value']},\n  setEntries = {required: ['entries']};\n\n// Redis commands\nvar\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds']},\n    expireat: {required: ['_id', 'timestamp']},\n    flushdb: {},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: getIdField,\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: setIdFieldValue,\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries']},\n    hscan: getxScan,\n    hset: setIdFieldValue,\n    hsetnx: setIdFieldValue,\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value']},\n    ltrim: {required: ['_id', 'start', 'stop']},\n    mget: getKeys,\n    mset: setEntries,\n    msetnx: setEntries,\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: setId,\n    pexpire: {required: ['_id', 'milliseconds']},\n    pexpireat: {required: ['_id', 'timestamp']},\n    pfadd: {required: ['_id', 'elements']},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources']},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds']},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey']},\n    renamenx: {required: ['_id', 'newkey']},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx']},\n    setex: {required: ['_id', 'value', 'seconds']},\n    setnx: setIdValue,\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: getMember,\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member']},\n    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction MemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  this.setHeaders = kuzzle.setHeaders.bind(this);\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\n(function () {\n  Object.keys(commands).forEach(function (command) {\n    MemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (args.length && typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\n      if (!commands[command].getter) {\n        data.body = {};\n      }\n\n      if (commands[command].required) {\n        commands[command].required.forEach(function (param) {\n          var value = args.shift();\n\n          if (value === undefined) {\n            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n          }\n\n          assignParameter(data, commands[command].getter, param, value);\n        });\n      }\n\n      if (args.length > 1) {\n        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n      }\n\n      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n      }\n\n      if (args.length) {\n        options = Object.assign({}, args[0]);\n\n        if (Array.isArray(commands[command].opts)) {\n          commands[command].opts.forEach(function (opt) {\n            if (options[opt] !== null && options[opt] !== undefined) {\n              assignParameter(data, commands[command].getter, opt, options[opt]);\n              delete options[opt];\n            }\n          });\n        }\n      }\n\n      /*\n       Options function mapper does not necessarily need\n       options to be passed by clients.\n       */\n      if (typeof commands[command].opts === 'function') {\n        commands[command].opts(data, options || {});\n      }\n\n      this.kuzzle.query(query, data, options, cb && function (err, res) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (commands[command].mapResults) {\n          return cb(null, commands[command].mapResults(res.result));\n        }\n\n        cb(null, res.result);\n      });\n\n      if (!commands[command].getter) {\n        return this;\n      }\n    };\n  });\n})();\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  var parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions(data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults(results) {\n  return results.map(function (coords) {\n    return coords.map(function (latlon) {\n      return parseFloat(latlon);\n    });\n  });\n}\n\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    var p = {\n        name: point[0]\n      },\n      i;\n\n    for (i = 1; i < point.length; i++) {\n      // withcoord result are in an array...\n      if (Array.isArray(point[i])) {\n        p.coordinates = point[i].map(function (coord) {\n          return parseFloat(coord);\n        });\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(point[i]);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray (results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt(results) {\n  return results.map(function (value) {\n    return parseInt(value);\n  });\n}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults(results) {\n  var\n    buffer = null,\n    mapped = [];\n\n  results.forEach(function (value) {\n    if (buffer === null) {\n      buffer = value;\n    }\n    else {\n      mapped.push({member: buffer, score: parseFloat(value)});\n      buffer = null;\n    }\n  });\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\", \n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n * \n * @param  {array.<string|array>} results \n * @return {object}\n */\nfunction mapScanResults(results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/MemoryStorage.js\n// module id = 9\n// module chunks = 0","var\n  uuidv4 = require('uuid/v4'),\n  Document = require('./Document');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you don’t exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then you’ll receive a notification about it.\n *\n * @param {object} collection - an instantiated and valid kuzzle object\n * @param {object} [options] - subscription optional configuration\n * @constructor\n */\nfunction Room(collection, options) {\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    callback: {\n      value: null,\n      writable: true\n    },\n    channel: {\n      value: null,\n      writable: true\n    },\n    id: {\n      value: uuidv4()\n    },\n    lastRenewal: {\n      value: null,\n      writable: true\n    },\n    notifier: {\n      value: null,\n      writable: true\n    },\n    onDoneCB: {\n      value: null,\n      writable: true\n    },\n    queue: {\n      value: [],\n      writable: true\n    },\n    // Delay before allowing a subscription renewal\n    renewalDelay: {\n      value: 500\n    },\n    scope: {\n      value: options && options.scope ? options.scope : 'all'\n    },\n    state: {\n      value: options && options.state ? options.state : 'done'\n    },\n    subscribing: {\n      value: false,\n      writable: true\n    },\n    users: {\n      value: options && options.users ? options.users : 'none'\n    },\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    filters: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(collection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    volatile: {\n      value: (options && options.volatile) ? options.volatile : {},\n      enumerable: true,\n      writable: true\n    },\n    roomId: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    subscribeToSelf: {\n      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['count'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of other subscriptions on that room.\n *\n * @param {responseCallback} cb - Handles the query response\n */\nRoom.prototype.count = function (cb) {\n  var data;\n\n  this.kuzzle.callbackRequired('Room.count', cb);\n\n  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\n  if (!isReady.call(this)) {\n    this.queue.push({action: 'count', args: [cb]});\n    return;\n  }\n\n  if (!this.roomId) {\n    throw new Error('Room.count: cannot count subscriptions on an inactive room');\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n    cb(err, res && res.result.count);\n  });\n};\n\n/**\n * Renew the subscription using new filters\n *\n * @param {object} [filters] - Filters in Kuzzle DSL format\n * @param {responseCallback} notificationCB - called for each new notification\n * @param {responseCallback} [cb] - handles the query response\n */\nRoom.prototype.renew = function (filters, notificationCB, cb) {\n  var\n    self = this,\n    now = Date.now(),\n    subscribeQuery = {\n      scope: self.scope,\n      state: self.state,\n      users: self.users\n    };\n\n  if (typeof filters === 'function') {\n    cb = notificationCB;\n    notificationCB = filters;\n    filters = null;\n  }\n\n  if (!cb) {\n    cb = self.onDoneCB;\n  }\n\n  self.kuzzle.callbackRequired('Room.renew', notificationCB);\n\n  /*\n    Skip subscription renewal if another one was performed a moment before\n   */\n  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n    return cb && cb(new Error('Subscription already renewed less than ' + self.renewalDelay + 'ms ago'));\n  }\n\n  if (filters) {\n    self.filters = filters;\n  }\n\n  /*\n   if not yet connected, register itself to the subscriptions list and wait for the\n   main Kuzzle object to renew once online\n    */\n  if (self.kuzzle.state !== 'connected') {\n    self.callback = notificationCB;\n    self.onDoneCB = cb;\n    self.kuzzle.subscriptions.pending[self.id] = self;\n    return;\n  }\n\n  if (self.subscribing) {\n    self.queue.push({action: 'renew', args: [filters, notificationCB, cb]});\n    return;\n  }\n\n  self.unsubscribe();\n  self.roomId = null;\n  self.subscribing = true;\n  self.callback = notificationCB;\n  self.onDoneCB = cb;\n  self.kuzzle.subscriptions.pending[self.id] = self;\n\n  subscribeQuery.body = self.filters;\n  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, self.headers);\n\n  self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'subscribe'), subscribeQuery, {volatile: self.volatile}, function (error, response) {\n    delete self.kuzzle.subscriptions.pending[self.id];\n    self.subscribing = false;\n\n    if (error) {\n      self.queue = [];\n      return cb && cb(new Error('Error during Kuzzle subscription: ' + error.message));\n    }\n\n    self.lastRenewal = now;\n    self.roomId = response.result.roomId;\n    self.channel = response.result.channel;\n\n    if (!self.kuzzle.subscriptions[self.roomId]) {\n      self.kuzzle.subscriptions[self.roomId] = {};\n    }\n\n    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\n    self.notifier = notificationCallback.bind(self);\n    self.kuzzle.network.on(self.channel, self.notifier);\n\n    dequeue.call(self);\n    cb && cb(null, self);\n  });\n};\n\n/**\n * Unsubscribes from Kuzzle.\n *\n * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n * pending subscriptions reaches 0, and only if there is still no listener on that room.\n * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n *\n * @return {*} this\n */\nRoom.prototype.unsubscribe = function () {\n  var\n    self = this,\n    room = self.roomId,\n    interval;\n\n  if (!isReady.call(this)) {\n    self.queue.push({action: 'unsubscribe', args: []});\n    return self;\n  }\n\n  if (room) {\n    self.kuzzle.network.off(self.channel, this.notifier);\n\n    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n      delete self.kuzzle.subscriptions[room];\n\n      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n        self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n      } else {\n        interval = setInterval(function () {\n          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n            if (!self.kuzzle.subscriptions[room]) {\n              self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n            }\n            clearInterval(interval);\n          }\n        }, 100);\n      }\n    } else {\n      delete self.kuzzle.subscriptions[room][self.id];\n    }\n\n    self.roomId = null;\n  }\n\n  return self;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nRoom.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n/**\n * Callback called by the network handler when a message is sent to the subscribed room ID\n * Calls the registered callback if the notification passes the subscription filters\n *\n * @param {object} data - data\n * @returns {*}\n */\nfunction notificationCallback (data) {\n  if (data.type === 'TokenExpired') {\n    this.kuzzle.jwtToken = undefined;\n    return this.kuzzle.emitEvent('tokenExpired');\n  }\n\n  if (data.type === 'document') {\n    data.document = new Document(this.collection, data.result._id, data.result._source, data.result._meta);\n    delete data.result;\n  }\n\n  if (this.kuzzle.requestHistory[data.requestId]) {\n    if (this.subscribeToSelf) {\n      this.callback(null, data);\n    }\n    delete this.kuzzle.requestHistory[data.requestId];\n  } else {\n    this.callback(null, data);\n  }\n}\n\n\n/**\n * Dequeue actions performed while subscription was being renewed\n */\nfunction dequeue () {\n  var element;\n\n  while (this.queue.length > 0) {\n    element = this.queue.shift();\n\n    this[element.action].apply(this, element.args);\n  }\n}\n\nfunction isReady() {\n  return this.kuzzle.state === 'connected' && !this.subscribing;\n}\n\nmodule.exports = Room;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Room.js\n// module id = 10\n// module chunks = 0","/**\n * @param {Collection} collection\n * @param {int} total\n * @param {Document[]} documents\n * @param {object} aggregations\n * @param {object} options\n * @param {object} filters\n * @param {SearchResult} previous\n * @property {Collection} collection\n * @property {number} total\n * @property {Document[]} documents\n * @property {object} aggregations\n * @property {object} options\n * @property {object} filters\n * @property {number} fetchedDocument\n * @constructor\n */\nfunction SearchResult (collection, total, documents, aggregations, options, filters, previous) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    total: {\n      value: total,\n      enumerable: true\n    },\n    documents: {\n      value: documents,\n      enumerable: true\n    },\n    aggregations: {\n      value: aggregations || {},\n      enumerable: true\n    },\n    options: {\n      value: options || {},\n      enumerable: true\n    },\n    filters: {\n      value: filters || {},\n      enumerable: true\n    },\n    // writable properties\n    fetchedDocument: {\n      value: previous instanceof SearchResult ? documents.length + previous.fetchedDocument : documents.length,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  // promisifying\n  if (this.collection.kuzzle.bluebird) {\n    return this.collection.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['fetchNext'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * @param {function} cb\n */\nSearchResult.prototype.fetchNext = function (cb) {\n  var\n    filters,\n    options = Object.assign({}, this.options),\n    self = this;\n  \n  options.previous = this;\n\n  // retrieve next results with scroll if original search use it\n  if (options.scrollId) {\n    if (this.fetchedDocument >= this.getTotal()) {\n      cb(null, null);\n      return;\n    }\n\n    // from and size parameters are not valid for a scroll action\n    if (typeof options.from !== 'undefined') {\n      delete options.from;\n    }\n\n    if (options.size) {\n      delete options.size;\n    }\n\n    this.collection.scroll(options.scrollId, options, this.filters || {}, cb);\n\n    return;\n  }\n\n  // retrieve next results using ES's search_after\n  if (options.size && this.filters.sort) {\n    if (this.fetchedDocument >= this.getTotal()) {\n      cb(null, null);\n      return;\n    }\n\n    if (options.from) {\n      delete options.from;\n    }\n\n    filters = Object.assign(this.filters, {search_after: []});\n\n    filters.sort.forEach(function (sortRule) {\n      filters.search_after.push(self.documents[self.documents.length - 1].content[Object.keys(sortRule)[0]]);\n    });\n\n    this.collection.search(filters, options, cb);\n\n    return;\n  }\n\n  // retrieve next results with from/size if original search use it\n  if (options.from !== undefined && options.size !== undefined) {\n    filters = Object.assign({}, this.filters);\n\n    // check if we need to do next request to fetch all matching documents\n    options.from += options.size;\n\n    if (options.from >= this.getTotal()) {\n      cb(null, null);\n\n      return;\n    }\n\n    this.collection.search(filters, options, cb);\n\n    return;\n  }\n\n  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n};\n\n/**\n * @returns {Document[]}\n */\nSearchResult.prototype.getDocuments = function () {\n  return this.documents;\n};\n\n/**\n * @returns {number}\n */\nSearchResult.prototype.getTotal = function () {\n  return this.total;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getAggregations = function () {\n  return this.aggregations;\n};\n\n/**\n * @returns {Object}\n */\nSearchResult.prototype.getOptions = function() {\n  return this.options;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getFilters = function() {\n  return this.filters;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getCollection = function () {\n  return this.collection;\n};\n\n/**\n * @returns {number}\n */\nSearchResult.prototype.getFetchedDocument = function () {\n  return this.fetchedDocument;\n};\n\nmodule.exports = SearchResult;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/SearchResult.js\n// module id = 11\n// module chunks = 0","/**\n * Sugar-code handling the result of a Room.renew call\n * @constructor\n */\nfunction SubscribeResult() {\n  this.cbs = [];\n  this.error = null;\n  this.room = null;\n}\n\n/**\n * Registers a callback to be called with a subscription result\n * @param {Function} cb\n */\nSubscribeResult.prototype.onDone = function (cb) {\n  if (this.error || this.room) {\n    cb(this.error, this.room);\n  }\n  else {\n    this.cbs.push(cb);\n  }\n\n  return this;\n};\n\n/**\n * Calls all registered callbacks\n *\n * @param {Object} error object\n * @param {Room} room\n */\nSubscribeResult.prototype.done = function (error, room) {\n  this.error = error;\n  this.room = room;\n\n  this.cbs.forEach(function (cb) {\n    cb(error, room);\n  });\n};\n\nmodule.exports = SubscribeResult;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/SubscribeResult.js\n// module id = 12\n// module chunks = 0","/**\n *\n * @param host\n * @param port\n * @param sslConnection\n * @returns {Object} tnstantiated WebSocket/Socket.IO object\n */\n\nfunction network(host, port, sslConnection) {\n  // Web browser / NodeJS websocket handling\n  if (typeof window !== 'undefined') {\n    // use native websockets if the browser supports it\n    if (typeof WebSocket !== 'undefined') {\n      return new (require('./wrappers/websocket'))(host, port, sslConnection);\n    }\n    // otherwise fallback to socket.io, if available\n    else if (window.io) {\n      return new (require('./wrappers/socketio'))(host, port, sslConnection);\n    }\n\n    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n  }\n\n  return new (require('./wrappers/websocket'))(host, port, sslConnection);\n}\n\nmodule.exports = network;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/index.js\n// module id = 13\n// module chunks = 0","function SocketIO(host, port, ssl) {\n  this.host = host;\n  this.port = port;\n  this.ssl = ssl;\n  this.socket = null;\n  this.wasConnected = false;\n  this.forceDisconnect = false;\n  this.handlers = {\n    connect: [],\n    reconnect: [],\n    connectError: [],\n    disconnect: []\n  };\n  this.retrying = false;\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    var self = this;\n\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: autoReconnect,\n      reconnectionDelay: reconnectionDelay,\n      forceNew: true\n    });\n\n    this.socket.on('connect', function() {\n      if (self.wasConnected) {\n        self.handlers.reconnect.forEach(function(handler) {\n          handler();\n        });\n      }\n      else {\n        self.handlers.connect.forEach(function(handler) {\n          handler();\n        });\n      }\n\n      self.wasConnected = true;\n    });\n\n    this.socket.on('connect_error', function(error) {\n      onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n    });\n\n    this.socket.on('disconnect', function() {\n      var error;\n\n      if (self.forceDisconnect) {\n        self.handlers.disconnect.forEach(function(handler) {\n          handler();\n        });\n      }\n      else {\n        error = new Error('An error occurred, this may due that kuzzle was not ready yet');\n        error.status = 500;\n\n        onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n      }\n\n      self.forceDisconnect = false;\n    });\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    if (this.handlers.connect.indexOf(callback) === -1) {\n      this.handlers.connect.push(callback);\n    }\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    if (this.handlers.connectError.indexOf(callback) === -1) {\n      this.handlers.connectError.push(callback);\n    }\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    if (this.handlers.disconnect.indexOf(callback) === -1) {\n      this.handlers.disconnect.push(callback);\n    }\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    if (this.handlers.reconnect.indexOf(callback) === -1) {\n      this.handlers.reconnect.push(callback);\n    }\n  };\n\n  /**\n   * Registers a callback on a room. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.once = function (roomId, callback) {\n    this.socket.once(roomId, callback);\n  };\n\n  /**\n   * Registers a callback on a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.on = function (roomId, callback) {\n    this.socket.on(roomId, callback);\n  };\n\n  /**\n   * Unregisters a callback from a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.off = function (roomId, callback) {\n    this.socket.off(roomId, callback);\n  };\n\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    this.socket.emit('kuzzle', payload);\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.forceDisconnect = true;\n\n    this.socket.close();\n    this.socket = null;\n  };\n}\n\n/**\n * Called when the connection closes with an error state\n *\n * @param {SocketIO}\n * @param {boolean} autoReconnect\n * @param {number} reconnectionDelay\n * @param {Error} error\n */\nfunction onClientNetworkError(socketio, autoReconnect, reconnectionDelay, error) {\n  if (autoReconnect && !socketio.retrying && !socketio.stopRetryingToConnect) {\n    socketio.retrying = true;\n    setTimeout(function () {\n      socketio.retrying = false;\n      socketio.connect(autoReconnect, reconnectionDelay);\n    }, reconnectionDelay);\n  }\n\n  socketio.handlers.connectError.forEach(function(handler) {\n    handler(error);\n  });\n}\n\n\nmodule.exports = SocketIO;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/wrappers/socketio.js\n// module id = 14\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Profile(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nProfile.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Profile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Profile} this\n */\nProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {Profile} this\n */\nProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {Profile} this\n */\nProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = Profile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Profile.js\n// module id = 15\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Role(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nRole.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Role\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Role} this object\n */\nRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = Role;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Role.js\n// module id = 16\n// module chunks = 0","var\n  Role = require('./Role'),\n  Profile = require('./Profile'),\n  User = require('./User');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {Security}\n * @constructor\n */\nfunction Security(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.fetchRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for fetchRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new Role(self, doc._id, doc._source, doc._meta);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @param {object} meta - role metadata\n * @constructor\n */\nSecurity.prototype.role = function(id, content, meta) {\n  return new Role(this, id, content, meta);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new Profile(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {array} policies - list of policies to attach to the new profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = { policies: policies };\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {array} policies - the list of policies to apply to this profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = {policies: policies};\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollProfiles: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n    var profiles = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (profile) {\n      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\n      newProfile.version = profile._version;\n\n      profiles.push(newProfile);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      profiles: profiles,\n      scrollId: scrollId\n    });\n  });\n};\n\n/**\n * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @param {object} meta - profile metadata\n * @constructor\n */\nSecurity.prototype.profile = function(id, content, meta) {\n  return new Profile(this, id, content, meta);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId = null;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new User(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Replace an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.replaceUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (content.profileIds) {\n    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollUsers: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n    var users = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (user) {\n      var newUser = new User(self, user._id, user._source, user._meta);\n\n      newUser.version = user._version;\n\n      users.push(newUser);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      users: users,\n      scrollId: scrollId\n    });\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @param {object} meta - user metadata\n * @constructor\n */\nSecurity.prototype.user = function(id, content, meta) {\n  return new User(this, id, content, meta);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the user <kuid> .\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a list of accepted fields per authentication strategy.\n *\n * @param options\n * @param cb\n */\nSecurity.prototype.getAllCredentialFields = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Retrieve the list of accepted field names by the specified <strategy>.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Get credential information of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Check the existence of the specified <strategy>’s credentials for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Updates credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n */\nSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\nmodule.exports = Security;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Security.js\n// module id = 17\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/events/events.js\n// module id = 18\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/uuid/lib/bytesToUuid.js\n// module id = 19\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/uuid/lib/rng-browser.js\n// module id = 20\n// module chunks = 0"],"sourceRoot":""}