{"version":3,"sources":["webpack://Kuzzle/webpack/universalModuleDefinition","webpack://Kuzzle/webpack/bootstrap","webpack://Kuzzle/./src/security/SecurityDocument.js","webpack://Kuzzle/../node_modules/uuid/v4.js","webpack://Kuzzle/./src/eventEmitter/index.js","webpack://Kuzzle/./src/Document.js","webpack://Kuzzle/./src/security/User.js","webpack://Kuzzle/./src/networkWrapper/wrappers/websocket.js","webpack://Kuzzle/./src/Kuzzle.js","webpack://Kuzzle/../node_modules/uuid/lib/rng-browser.js","webpack://Kuzzle/../node_modules/uuid/lib/bytesToUuid.js","webpack://Kuzzle/../node_modules/events/events.js","webpack://Kuzzle/./src/Collection.js","webpack://Kuzzle/./src/SearchResult.js","webpack://Kuzzle/./src/CollectionMapping.js","webpack://Kuzzle/./src/Room.js","webpack://Kuzzle/./src/SubscribeResult.js","webpack://Kuzzle/./src/security/Security.js","webpack://Kuzzle/./src/security/Role.js","webpack://Kuzzle/./src/security/Profile.js","webpack://Kuzzle/./src/MemoryStorage.js","webpack://Kuzzle/./src/networkWrapper/index.js","webpack://Kuzzle/./src/networkWrapper/wrappers/socketio.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SecurityDocument","Security","id","content","meta","Error","defineProperties","this","kuzzle","writable","setContent","bluebird","promisifyAll","suffix","filter","func","target","passes","indexOf","data","serialize","_id","body","delete","options","cb","undefined","query","buildQueryArgs","deleteActionName","error","res","result","update","self","updateActionName","response","_source","rng","bytesToUuid","buf","offset","Array","rnds","random","ii","KuzzleEventEmitter","_events","_onceEvents","constructor","on","eventName","listener","listeners","listenerType","push","emit","addListener","prependListener","concat","once","prependOnceListener","removeListener","index","length","splice","removeAllListeners","args","onceListeners","notifyList","slice","arguments","item","apply","eventNames","keys","listenerCount","emitEvent","off","Document","collection","documentId","dataCollection","headers","JSON","parse","stringify","version","_version","addHeaders","toString","err","exists","refresh","callbackRequired","newDocument","_meta","save","action","publish","replace","forEach","subscribe","filters","ids","values","setHeaders","KuzzleSecurityDocument","User","credentials","setProfiles","profileIds","isArray","setCredentials","addProfile","profileId","creationSerialize","saveRestricted","getProfileIds","getProfiles","fetchedProfiles","errored","fetchProfile","profile","WSNode","host","port","ssl","WebSocket","e","code","client","wasConnected","retrying","lasturl","stopRetryingToConnect","connect","autoReconnect","reconnectionDelay","url","perMessageDeflate","onopen","onclose","closeEvent","message","status","reason","onClientNetworkError","onerror","onmessage","payload","room","onConnect","callback","onConnectError","onDisconnect","onReconnect","send","readyState","OPEN","close","ws","setTimeout","uuidv4","Collection","MemoryStorage","networkWrapper","Kuzzle","collections","connectCB","eventActions","queuing","state","subscriptions","pending","defaultIndex","sslConnection","autoQueue","autoReplay","autoResubscribe","volatile","offlineQueue","queueFilter","queueMaxSize","queueTTL","replayInterval","jwtToken","offlineQueueLoader","sdkVersion","opt","getOwnPropertyDescriptor","offlineMode","header","errorMessagePrefix","eventTimeout","writeable","connected","timeout","disconnected","reconnected","tokenExpired","loginAttempt","cleanQueue","now","Date","lastDocumentIndex","ts","droppedRequest","emitRequest","request","network","requestId","assign","dequeue","additionalQueue","uniqueQueue","dequeuingProcess","shift","Math","max","controller","renewAllSubscriptions","roomId","subscriptionId","subscription","renew","discardRequest","protectedEvent","protectedEvents","lastEmitted","disconnect","connectionError","internal","subscribing","reconnect","checkToken","valid","setJwtToken","token","success","jwt","unsetJwtToken","unsubscribe","getJwtToken","login","strategy","expiresIn","queuable","createMyCredentials","deleteMyCredentials","getMyCredentials","updateMyCredentials","validateMyCredentials","createIndex","logout","whoAmI","security","getMyRights","hits","updateSelf","event","isValid","getAllStatistics","getStatistics","timestamp","queryCB","startTime","flushQueue","listCollections","arg","type","listIndexes","indexes","getServerInfo","serverInfo","refreshIndex","getAutoRefresh","setAutoRefresh","autoRefresh","queryArgs","attr","from","size","scroll","scrollId","sdkInstanceId","replayQueue","setDefaultIndex","startQueuing","stopQueuing","getRandomValues","crypto","msCrypto","rnds8","Uint8Array","byteToHex","substr","bth","join","EventEmitter","_maxListeners","isFunction","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","TypeError","er","handler","len","context","newListener","warned","console","trace","fired","g","list","position","evlistener","emitter","KuzzleSearchResult","CollectionMapping","Room","SubscribeResult","count","mapping","createDocument","document","ifExist","doc","deleteDocument","deleteSpecifications","documentExists","fetchDocument","getMapping","mCreateDocument","documents","map","mCreateOrReplaceDocument","mDeleteDocument","documentIds","mGetDocument","mReplaceDocument","mUpdateDocument","getSpecifications","publishMessage","replaceDocument","search","_scroll_id","total","aggregations","previous","scrollSpecifications","searchSpecifications","subscribeResult","done","truncate","updateDocument","retryOnConflict","updateSpecifications","specifications","validateSpecifications","collectionMapping","SearchResult","fetchedDocument","fetchNext","getTotal","sort","search_after","sortRule","getDocuments","getAggregations","getOptions","getFilters","getCollection","getFetchedDocument","properties","mappings","set","field","channel","lastRenewal","notifier","onDoneCB","queue","renewalDelay","scope","users","subscribeToSelf","isReady","notificationCB","subscribeQuery","notificationData","element","interval","setInterval","clearInterval","cbs","onDone","Role","Profile","fetchRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","role","searchProfiles","profiles","createProfile","policies","updateProfile","updatedContent","deleteProfile","scrollProfiles","newProfile","fetchUser","searchUsers","createUser","replaceUser","createRestrictedUser","updateUser","deleteUser","scrollUsers","user","newUser","isActionAllowed","rights","filteredRights","right","some","getUserRights","userId","createCredentials","kuid","deleteCredentials","getAllCredentialFields","getCredentialFields","getCredentials","hasCredentials","updateCredentials","validateCredentials","addPolicy","policy","roleId","setPolicies","getPolicies","getId","required","getIdField","getKeys","getMember","getxScan","opts","mapResults","mapScanResults","getZrange","assignZrangeOptions","mapZrangeResults","getZrangeBy","setId","setIdValue","setIdFieldValue","setEntries","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","geoadd","geodist","parseFloat","geohash","geopos","results","coords","latlon","georadius","assignGeoRadiusOptions","mapGeoRadiusResults","georadiusbymember","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","setex","setnx","sinter","sinterstore","sismember","smembers","smove","spop","mapStringToArray","srandmember","srem","sscan","strlen","sunion","sunionstore","time","parseInt","touch","ttl","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","assignParameter","parsed","limit","point","coordinates","coord","distance","buffer","mapped","member","score","cursor","command","pop","param","io","socketio","handlers","connectError","socket","forceDisconnect","reconnection","forceNew"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","function SecurityDocument(Security, id, content, meta) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: Security.kuzzle\n    },\n    Security: {\n      value: Security\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    meta: {\n      value: meta || {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function won’t be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {SecurityDocument} this\n */\nSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {SecurityDocument} this\n */\nSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = SecurityDocument;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","function KuzzleEventEmitter() {\n  if (typeof window !== 'undefined') {\n    this._events = {};\n    this._onceEvents = {};\n  }\n}\n\nif (typeof window === 'undefined') {\n  KuzzleEventEmitter.prototype = require('events').prototype;\n  KuzzleEventEmitter.prototype.constructor = KuzzleEventEmitter;\n} else {\n\n  KuzzleEventEmitter.prototype.on = function(eventName, listener) {\n    var\n      listenerType = typeof listener,\n      listeners;\n\n    if (!eventName || !listener) {\n      return;\n    }\n\n    if (listenerType !== 'function') {\n      throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n    }\n\n    listeners = this.listeners(eventName);\n    // only add once\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener);\n    }\n\n    // Handles `newListener` event (see https://nodejs.org/api/events.html#events_event_newlistener)\n    this.emit('newListener', eventName, listener);\n\n    return this;\n  };\n  KuzzleEventEmitter.prototype.addListener = KuzzleEventEmitter.prototype.on;\n\n  KuzzleEventEmitter.prototype.prependListener = function(eventName, listener) {\n    var listeners;\n\n    if (!eventName || !listener) {\n      return;\n    }\n\n    listeners = this.listeners(eventName);\n    // only add once\n    if (listeners.indexOf(listener) === -1) {\n      this._events[eventName] = new Array(listener).concat(listeners);\n    }\n\n    // Handles `newListener` event (see https://nodejs.org/api/events.html#events_event_newlistener)\n    this.emit('newListener', eventName, listener);\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.once = function(eventName, listener) {\n    var onceListeners;\n\n    if (!eventName || !listener) {\n      return;\n    }\n\n\n    this.on(eventName, listener);\n    onceListeners = this._onceEvents[eventName] = this._onceEvents[eventName] || {};\n    onceListeners[listener] = true;\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.prependOnceListener = function(eventName, listener) {\n    var onceListeners;\n\n    if (!eventName || !listener) {\n      return;\n    }\n    this.prependListener(eventName, listener);\n    onceListeners = this._onceEvents[eventName] = this._onceEvents[eventName] || {};\n    onceListeners[listener] = true;\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.removeListener = function(eventName, listener) {\n    var\n      index,\n      listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return;\n    }\n\n    index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    // Handles `removeListener` event (see https://nodejs.org/api/events.html#events_event_removeListener)\n    this.emit('removeListener', eventName, listener);\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.removeAllListeners = function(eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n      delete this._onceEvents[eventName];\n    } else {\n      this._events = [];\n      this._onceEvents = [];\n    }\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.emit = function(eventName) {\n    var\n      i = 0,\n      listeners,\n      args,\n      onceListeners,\n      notifyList;\n\n    listeners = this._events && this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return;\n    }\n\n    args = Array.prototype.slice.call(arguments, 1);\n    // once stuff\n    onceListeners = this._onceEvents && this._onceEvents[eventName] || {};\n\n    notifyList = new Array();\n\n    listener = listeners[i];\n    while (listener) {\n      // trigger listener\n      notifyList.push(listener);\n      // get next listener\n      if (onceListeners[listener]) {\n        // remove listener\n        this.removeListener(eventName,listener);\n        // unset once flag\n        delete onceListeners[listener];\n      } else {\n        i++;\n      }\n      listener = listeners[i];\n    }\n    for (item in notifyList) {\n      // trigger listener\n      if (notifyList[item] !== undefined) {\n        notifyList[item].apply(this, args);\n      }\n    }\n\n    return this;\n  };\n\n  KuzzleEventEmitter.prototype.eventNames = function () {\n    return Object.keys(this._events);\n  };\n\n  KuzzleEventEmitter.prototype.listenerCount = function (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  };\n\n  KuzzleEventEmitter.prototype.listeners = function (eventName) {\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n    return this._events[eventName];\n  };\n\n}\n// Aliases:\nKuzzleEventEmitter.prototype.emitEvent = KuzzleEventEmitter.prototype.emit;\nKuzzleEventEmitter.prototype.off = KuzzleEventEmitter.prototype.removeListener;\n\nmodule.exports = KuzzleEventEmitter;\n","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * Document is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {Collection} collection - an instanciated Collection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @param {object} [meta] - Initializes this document with the provided meta\n * @constructor\n */\nfunction Document(collection, documentId, content, meta) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: collection,\n      enumerable: false\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: false\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(collection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    meta: {\n      value: meta || {},\n      enumerable: true,\n      writable: false\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  if (this.version) {\n    data._version = this.version;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.delete: cannot delete a document without a document ID');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n    cb(err, err ? undefined : self.id);\n  });\n};\n\n/**\n * Checks if this document exists in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.exists = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('Document.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    action = data._id ? 'createOrReplace' : 'create',\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', action), data, options, function (error, res) {\n    if (error) {\n      return cb && cb(error);\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function won’t be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nDocument.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n\nmodule.exports = Document;\n","var\n  KuzzleSecurityDocument = require('./SecurityDocument');\n\n/**\n * @param {Security} Security\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction User(Security, id, content, meta) {\n  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    },\n    credentials: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: User\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {User} this\n */\nUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * @param {object} credentials\n */\nUser.prototype.setCredentials = function (credentials) {\n  if (typeof credentials !== 'object') {\n    throw new Error('Parameter \"credentials\" must be a object');\n  }\n\n  this.credentials = credentials;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {User} this\n */\nUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Creates this user into Kuzzle\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.create = function (options, cb) {\n  var\n    data = this.creationSerialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n\n/**\n * Replaces the latest version of this user in Kuzzle by the current content of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.replace = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n\n  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content, meta: this.meta};\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.creationSerialize = function () {\n  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array.<string>} the associated profiles IDs\n */\nUser.prototype.getProfileIds = function () {\n  return this.content.profileIds || [];\n};\n\n/**\n * Return the associated Profile objects\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nUser.prototype.getProfiles = function (options, cb) {\n  var \n    self = this,\n    fetchedProfiles = [],\n    errored = false;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\n  if (!self.content.profileIds) {\n    return cb(null, fetchedProfiles);\n  }\n\n  self.content.profileIds.forEach(function (profileId) {\n    self.Security.fetchProfile(profileId, options, function (error, profile) {\n      if (error) {\n        if (errored) {\n          return;\n        }\n\n        errored = true; // prevents multiple callback resolutions\n        return cb(error);\n      }\n\n      fetchedProfiles.push(profile);\n\n      if (fetchedProfiles.length === self.content.profileIds.length) {\n        cb(null, fetchedProfiles);\n      }\n    });\n  });\n};\n\nmodule.exports = User;\n","var\n  KuzzleEventEmitter = require('../../eventEmitter');\n\nfunction WSNode(host, port, ssl) {\n  var self = this;\n  KuzzleEventEmitter.call(this);\n\n  this.WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : require('ws');\n  this.host = host;\n  this.port = port;\n  this.ssl = ssl;\n  this.client = null;\n  this.wasConnected = false;\n  this.retrying = false;\n  this.lasturl = null;\n  this.stopRetryingToConnect = false;\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   * @returns {Object} Socket\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    var\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      options = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    if (url !== this.lasturl) {\n      self.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new this.WebSocket(url, options);\n\n    this.client.onopen = function () {\n      if (self.wasConnected) {\n        self.emitEvent('reconnect');\n      }\n      else {\n        self.emitEvent('connect');\n      }\n      self.wasConnected = true;\n      self.stopRetryingToConnect = false;\n    };\n\n    this.client.onclose = function (closeEvent, message) {\n      var error;\n      var status;\n      var reason = message;\n\n      if (typeof closeEvent === 'number') {\n        status = closeEvent;\n      }\n      else {\n        status = closeEvent.code;\n\n        if (closeEvent.reason) {\n          reason = closeEvent.reason;\n        }\n      }\n\n      if (status === 1000) {\n        self.emitEvent('disconnect');\n      }\n      else {\n        error = new Error(reason);\n        error.status = status;\n\n        onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n      }\n    };\n\n    this.client.onerror = function (error) {\n      if (!(error instanceof Error)) {\n        error = new Error(error);\n      }\n\n      onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n    };\n\n    this.client.onmessage = function (payload) {\n      var data = JSON.parse(payload.data || payload);\n\n      if (data.room) {\n        self.emitEvent(data.room, data);\n      }\n      else {\n        self.emitEvent('discarded', data);\n      }\n    };\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    this.addListener('connect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    this.addListener('networkError', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    this.addListener('disconnect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    this.addListener('reconnect', callback);\n  };\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.removeAllListeners();\n    this.wasConnected = false;\n    this.client.close();\n    this.client = null;\n    self.stopRetryingToConnect = true;\n  };\n}\nWSNode.prototype = Object.create(KuzzleEventEmitter.prototype);\nWSNode.prototype.constructor = WSNode;\n\n\n/**\n * Called when the connection closes with an error state\n *\n * @param {WSNode} \n * @param {boolean} autoReconnect\n * @param {number} reconnectionDelay\n * @param {Error} error\n */\nfunction onClientNetworkError(ws, autoReconnect, reconnectionDelay, error) {\n  if (autoReconnect && !ws.retrying && !ws.stopRetryingToConnect) {\n    ws.retrying = true;\n    setTimeout(function () {\n      ws.retrying = false;\n      ws.connect(autoReconnect, reconnectionDelay);\n    }, reconnectionDelay);\n  }\n\n  ws.emitEvent('networkError', error);\n}\n\nmodule.exports = WSNode;\n","var\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('./eventEmitter'),\n  Collection = require('./Collection.js'),\n  Security = require('./security/Security'),\n  MemoryStorage = require('./MemoryStorage'),\n  User = require('./security/User'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n */\nfunction Kuzzle (host, options, cb) {\n  var self = this;\n\n  if (!(this instanceof Kuzzle)) {\n    return new Kuzzle(host, options, cb);\n  }\n  KuzzleEventEmitter.call(this);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!host || host === '') {\n    throw new Error('host argument missing');\n  }\n\n  Object.defineProperties(this, {\n    // 'private' properties\n    id: {\n      value: uuidv4()\n    },\n    collections: {\n      value: {},\n      writable: true\n    },\n    connectCB: {\n      value: cb\n    },\n    eventActions: {\n      value: [\n        'connected',\n        'networkError',\n        'disconnected',\n        'reconnected',\n        'tokenExpired',\n        'loginAttempt',\n        'offlineQueuePush',\n        'offlineQueuePop',\n        'queryError',\n        'discarded'\n      ],\n      writable: false\n    },\n    queuing: {\n      value: false,\n      writable: true\n    },\n    state: {\n      value: 'initializing',\n      writable: true\n    },\n    subscriptions: {\n      /*\n       Contains the centralized subscription list in the following format:\n          pending: {\n            subscriptionUid_1: kuzzleRoomInstance_1,\n            subscriptionUid_2: kuzzleRoomInstance_2,\n            subscriptionUid_...: kuzzleRoomInstance_...\n          },\n          'roomId': {\n            subscriptionUid_1: kuzzleRoomInstance_1,\n            subscriptionUid_2: kuzzleRoomInstance_2,\n            subscriptionUid_...: kuzzleRoomInstance_...\n          }\n\n       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n       This structure also allows renewing subscriptions after a connection loss\n       */\n      value: {\n        pending: {}\n      },\n      writable: true\n    },\n    // configuration properties\n    autoReconnect: {\n      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n      writable: true,\n      enumerable: true\n    },\n    defaultIndex: {\n      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n      writable: true,\n      enumerable: true\n    },\n    reconnectionDelay: {\n      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n      writable: true,\n      enumerable: true\n    },\n    host: {\n      value: host,\n      writable: true,\n      enumerable: true\n    },\n    port: {\n      value: (options && typeof options.port === 'number') ? options.port : 7512,\n      enumerable: true,\n      writable: true\n    },\n    sslConnection: {\n      value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n      writable: true,\n      enumerable: true\n    },\n    autoQueue: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoReplay: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoResubscribe: {\n      value: true,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    volatile: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    /*\n      Offline queue use the following format:\n            [\n              {\n                ts: <query timestamp>,\n                query: 'query',\n                cb: callbackFunction\n              }\n            ]\n     */\n    offlineQueue: {\n      value: [],\n      enumerable: true,\n      writable: true\n    },\n    queueFilter: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    queueMaxSize: {\n      value: 500,\n      enumerable: true,\n      writable: true\n    },\n    queueTTL: {\n      value: 120000,\n      enumerable: true,\n      writable: true\n    },\n    replayInterval: {\n      value: 10,\n      enumerable: true,\n      writable: true\n    },\n    jwtToken: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    offlineQueueLoader: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    sdkVersion: {\n      value: (typeof SDKVERSION === 'undefined') ? require('../package.json').version : SDKVERSION,\n      writable: false\n    }\n  });\n\n  if (options) {\n    Object.keys(options).forEach(function (opt) {\n      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n        self[opt] = options[opt];\n      }\n    });\n\n    if (options.offlineMode === 'auto' && this.autoReconnect) {\n      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n    }\n  }\n\n  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n  Object.defineProperty(this, 'isValid', {\n    value: function () {\n      if (self.state === 'disconnected') {\n        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n      }\n    }\n  });\n\n  // Helper function copying headers to the query data\n  Object.defineProperty(this, 'addHeaders', {\n    value: function (query, headers) {\n      Object.keys(headers).forEach(function (header) {\n        if (!query[header]) {\n          query[header] = headers[header];\n        }\n      });\n\n      return query;\n    }\n  });\n\n  /**\n   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n   * and is called by these methods\n   */\n  Object.defineProperty(this, 'callbackRequired', {\n    value: function (errorMessagePrefix, callback) {\n      if (!callback || typeof callback !== 'function') {\n        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n      }\n    }\n  });\n\n  /**\n   * Create an attribute security that embed all methods to manage Role, Profile and User\n   */\n  Object.defineProperty(this, 'security', {\n    value: new Security(this),\n    enumerable: true\n  });\n\n  Object.defineProperty(this, 'memoryStorage', {\n    value: new MemoryStorage(this),\n    enumerable: true\n  });\n\n  Object.defineProperties(this, {\n    eventTimeout: {\n      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200,\n      writeable: false\n    }\n  });\n\n  Object.defineProperty(this, 'protectedEvents', {\n    value: {\n      connected: {timeout: this.eventTimeout},\n      error: {timeout: this.eventTimeout},\n      disconnected: {timeout: this.eventTimeout},\n      reconnected: {timeout: this.eventTimeout},\n      tokenExpired: {timeout: this.eventTimeout},\n      loginAttempt: {timeout: this.eventTimeout}\n    },\n    writeable: false\n  });\n\n  if (!options || !options.connect || options.connect === 'auto') {\n    this.connect();\n  } else {\n    this.state = 'ready';\n  }\n\n  if (this.bluebird) {\n    return this.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n          'listCollections', 'createIndex', 'listIndexes', 'login', 'logout',\n          'now', 'query', 'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n        ];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\nKuzzle.prototype = Object.create(KuzzleEventEmitter.prototype);\nKuzzle.prototype.constructor = Kuzzle;\n\n/**\n* Emit an event to all registered listeners\n* An event cannot be emitted multiple times before a timeout has been reached.\n*/\nKuzzle.prototype.emit = function(eventName) {\n  var\n    now = Date.now(),\n    protectedEvent = this.protectedEvents[eventName];\n\n  if (protectedEvent) {\n    if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n      return false;\n    }\n    protectedEvent.lastEmitted = now;\n  }\n  KuzzleEventEmitter.prototype.emit.apply(this, arguments);\n};\nKuzzle.prototype.emitEvent = Kuzzle.prototype.emit;\n\n/**\n * Connects to a Kuzzle instance using the provided host name.\n * @returns {Object} this\n */\nKuzzle.prototype.connect = function () {\n  var self = this;\n\n  if (self.network) {\n    self.disconnect();\n  }\n\n  self.network = networkWrapper(self.host, self.port, self.sslConnection);\n\n  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n    return self;\n  }\n\n  self.state = 'connecting';\n  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\n  self.network.onConnect(function () {\n    self.state = 'connected';\n    renewAllSubscriptions.call(self);\n    dequeue.call(self);\n    self.emitEvent('connected');\n\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n  });\n\n  self.network.on('discarded', function (data) {\n    self.emitEvent('discarded', data);\n  });\n\n  self.network.onConnectError(function (error) {\n    var connectionError = new Error('Unable to connect to kuzzle proxy server at \"' + self.host + ':' + self.port + '\"');\n\n    connectionError.internal = error;\n    self.state = 'error';\n    self.emitEvent('networkError', connectionError);\n\n    disableAllSubscriptions.call(self);\n\n    if (self.connectCB) {\n      self.connectCB(connectionError);\n    }\n  });\n\n  self.network.onDisconnect(function () {\n    self.state = 'offline';\n\n    if (!self.autoReconnect) {\n      self.disconnect();\n    }\n\n    if (self.autoQueue) {\n      self.queuing = true;\n    }\n\n    self.emitEvent('disconnected');\n  });\n\n  self.network.onReconnect(function () {\n    var reconnect = function () {\n      // renew subscriptions\n      if (self.autoResubscribe) {\n        renewAllSubscriptions.call(self);\n      }\n\n      // replay queued requests\n      if (self.autoReplay) {\n        cleanQueue.call(self);\n        dequeue.call(self);\n      }\n\n      // alert listeners\n      self.emitEvent('reconnected');\n    };\n\n    self.state = 'connected';\n\n    if (self.jwtToken) {\n      self.checkToken(self.jwtToken, function (err, res) {\n        // shouldn't obtain an error but let's invalidate the token anyway\n        if (err || !res.valid) {\n          self.jwtToken = undefined;\n          self.emitEvent('tokenExpired');\n        }\n\n        reconnect();\n      });\n    } else {\n      reconnect();\n    }\n  });\n\n  return this;\n};\n\n/**\n * Set the jwtToken used to query kuzzle\n * @param token\n * @returns {Kuzzle}\n */\nKuzzle.prototype.setJwtToken = function(token) {\n  if (typeof token === 'string') {\n    this.jwtToken = token;\n  } else if (typeof token === 'object') {\n    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n      this.jwtToken = token.result.jwt;\n    } else {\n      this.emitEvent('loginAttempt', {\n        success: false,\n        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n      });\n\n      return this;\n    }\n  } else {\n    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n    return this;\n  }\n\n  renewAllSubscriptions.call(this);\n  this.emitEvent('loginAttempt', {success: true});\n  return this;\n};\n\n/**\n * Unset the jwtToken used to query kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.unsetJwtToken = function() {\n  this.jwtToken = undefined;\n\n  removeAllSubscriptions.call(this);\n\n  return this;\n};\n\n/**\n * Get the jwtToken used by kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.getJwtToken = function() {\n  return this.jwtToken;\n};\n\n/**\n * Send login request to kuzzle with credentials\n * If login success, store the jwtToken into kuzzle object\n *\n * @param strategy\n * @param credentials\n * @param expiresIn\n * @param cb\n */\nKuzzle.prototype.login = function (strategy) {\n  var\n    self = this,\n    request = {\n      body: {},\n      strategy: strategy\n    },\n    cb = null;\n\n  if (!strategy || typeof strategy !== 'string') {\n    throw new Error('Kuzzle.login: strategy required');\n  }\n\n  // Handle arguments (credentials, expiresIn, cb)\n  if (arguments[1]) {\n    if (typeof arguments[1] === 'object') {\n      request.body = arguments[1];\n    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n      request.expiresIn = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n    }\n  }\n  if (arguments[2]) {\n    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n      request.expiresIn = arguments[2];\n    } else if (typeof arguments[2] === 'function') {\n      cb = arguments[2];\n    }\n  }\n  if (arguments[3] && typeof arguments[3] === 'function') {\n    cb = arguments[3];\n  }\n\n  this.query({controller: 'auth', action: 'login'}, request, {queuable: false}, function(error, response) {\n    if (!error) {\n      if (response.result.jwt) {\n        self.setJwtToken(response.result.jwt);\n      }\n\n      cb && cb(null, response.result);\n    }\n    else {\n      cb && cb(error);\n      self.emitEvent('loginAttempt', {success: false, error: error.message});\n    }\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the current user.\n *\n * @param credentials\n * @param strategy\n * @param options\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.createMyCredentials = function (strategy, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'createMyCredentials'}, {strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the current user.\n *\n * @param strategy\n * @param options\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.deleteMyCredentials = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'deleteMyCredentials'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Get credential information of the specified <strategy> for the current user.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nKuzzle.prototype.getMyCredentials = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'getMyCredentials'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Update credentials of the specified <strategy> for the current user.\n *\n * @param strategy\n * @param credentals\n * @param options\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.updateMyCredentials = function (strategy, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'updateMyCredentials'}, {strategy: strategy, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the current user.\n *\n * @param strategy\n * @param credentials\n * @param options\n * @param cb\n */\nKuzzle.prototype.validateMyCredentials = function (strategy, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'auth', action: 'validateMyCredentials'}, {strategy: strategy, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Create a kuzzle index\n *\n * @param {string} index\n * @param {object} [options]\n * @param {responseCallback} cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.createIndex = function (index, options, cb) {\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.createIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'index', action: 'create', index: index}, {}, options, typeof cb !== 'function' ? null : function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return this;\n};\n\n/**\n * Send logout request to kuzzle with jwtToken.\n *\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.logout = function (cb) {\n  var\n    self = this,\n    request = {\n      action: 'logout',\n      controller: 'auth',\n      requestId: uuidv4(),\n      body: {}\n    };\n\n  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, typeof cb !== 'function' ? null : function(error) {\n    cb(error, self);\n  });\n\n  self.unsetJwtToken();\n\n  return self;\n};\n\n/**\n * Checks whether a given jwt token still represents a valid session in Kuzzle.\n *\n * @param  {string}   token     The jwt token to check\n * @param  {function} cb  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n */\nKuzzle.prototype.checkToken = function (token, cb) {\n  var\n    request = {\n      body: {\n        token: token\n      }\n    };\n\n  this.callbackRequired('Kuzzle.checkToken', cb);\n\n  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Fetches the current user.\n *\n * @param  {function} cb  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n */\nKuzzle.prototype.whoAmI = function (cb) {\n  var self = this;\n\n  self.callbackRequired('Kuzzle.whoAmI', cb);\n\n  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, res) {\n    cb(err, err ? undefined : new User(self.security, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Gets the rights array of the currently logged user.\n *\n * @param {object} [options] - Optional parameters\n * @param  {function} cb The callback containing the normalized array of rights.\n */\nKuzzle.prototype.getMyRights = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.callbackRequired('Kuzzle.getMyRights', cb);\n\n  self.query({controller: 'auth', action:'getMyRights'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Update current user in Kuzzle.\n *\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Kuzzle} this object\n */\nKuzzle.prototype.updateSelf = function (content, options, cb) {\n  var\n    self = this,\n    data = {},\n    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data.body = content;\n\n  self.query(queryArgs, data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return this;\n};\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n */\nfunction cleanQueue () {\n  var\n    self = this,\n    now = Date.now(),\n    lastDocumentIndex = -1;\n\n  if (self.queueTTL > 0) {\n    self.offlineQueue.forEach(function (query, index) {\n      if (query.ts < now - self.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      self.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(function (droppedRequest) {\n          self.emitEvent('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n    self.offlineQueue\n      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n      .forEach(function (droppedRequest) {\n        self.emitEvent('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n/**\n * Emit a request to Kuzzle\n *\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (request, cb) {\n  var\n    self = this;\n\n  if (self.jwtToken !== undefined || cb) {\n    self.network.once(request.requestId, function (response) {\n      var error = null;\n\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        self.jwtToken = undefined;\n        self.emitEvent('tokenExpired', request, cb);\n      }\n\n      if (response.error) {\n        error = new Error(response.error.message);\n        Object.assign(error, response.error);\n        error.status = response.status;\n        self.emitEvent('queryError', error, request, cb);\n      }\n\n      if (cb) {\n        cb(error, response);\n      }\n    });\n  }\n\n  this.network.send(request);\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue () {\n  var\n    self = this,\n    additionalQueue,\n    uniqueQueue = {},\n    dequeuingProcess = function () {\n      if (self.offlineQueue.length > 0) {\n        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\n        setTimeout(function () {\n          dequeuingProcess();\n        }, Math.max(0, self.replayInterval));\n      } else {\n        self.queuing = false;\n      }\n    };\n\n  if (self.offlineQueueLoader) {\n    if (typeof self.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n    }\n\n    additionalQueue = self.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      self.offlineQueue = additionalQueue\n        .concat(self.offlineQueue)\n        .filter(function (request) {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\n/**\n * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n * successful login attempt\n */\nfunction renewAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.renew(subscription.callback);\n    });\n  });\n}\n\n/**\n * Remove all registered subscriptions. Triggered either by a logout query or by un-setting the token\n */\nfunction removeAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.unsubscribe();\n    });\n  });\n}\n\n/**\n * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n * insertion.\n *\n * @param {string} event - name of the global event to subscribe to\n * @param {function} listener - callback to invoke each time an event is fired\n */\nKuzzle.prototype.addListener = function(event, listener) {\n  this.isValid();\n\n  if (this.eventActions.indexOf(event) === -1) {\n    throw new Error('[' + event + '] is not a known event. Known events: ' + this.eventActions.toString());\n  }\n\n  return KuzzleEventEmitter.prototype.addListener.call(this, event, listener);\n};\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method returns all available statistics from Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getAllStatistics = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n  this.query({controller:'server', action: 'getAllStats'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n *\n * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n  var\n    queryCB,\n    body;\n\n  if (!cb) {\n    if (arguments.length === 1) {\n      cb = arguments[0];\n      options = null;\n      timestamp = null;\n    } else {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'object') {\n        options = arguments[0];\n        timestamp = null;\n      } else {\n        timestamp = arguments[0];\n        options = null;\n      }\n    }\n  }\n\n  queryCB = function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, timestamp ? res.result.hits : [res.result]);\n  };\n\n  this.callbackRequired('Kuzzle.getStatistics', cb);\n\n  body = timestamp ? {body: {startTime: timestamp}} : {};\n  this.query({controller: 'server', action: timestamp ? 'getStats' : 'getLastStats'}, body, options, queryCB);\n};\n\n/**\n * Create a new instance of a Collection object.\n * If no index is specified, takes the default index.\n *\n * @param {string} collection - The name of the data collection you want to manipulate\n * @param {string} [index] - The name of the data index containing the data collection\n * @returns {Collection} A Collection instance\n */\nKuzzle.prototype.collection = function(collection, index) {\n  this.isValid();\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Unable to create a new data collection object: no index specified');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  if (typeof index !== 'string' || typeof collection !== 'string') {\n    throw new Error('Invalid index or collection argument: string expected');\n  }\n\n  if (!this.collections[index]) {\n    this.collections[index] = {};\n  }\n\n  if (!this.collections[index][collection]) {\n    this.collections[index][collection] = new Collection(this, collection, index);\n  }\n\n  return this.collections[index][collection];\n};\n\n/**\n * Empties the offline queue without replaying it.\n *\n * @returns {Kuzzle}\n */\nKuzzle.prototype.flushQueue = function () {\n  this.offlineQueue = [];\n  return this;\n};\n\n/**\n * Returns the list of known persisted data collections.\n *\n * @param {string} [index] - Index containing collections to be listed\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.listCollections = function () {\n  var\n    index,\n    options,\n    cb,\n    args = Array.prototype.slice.call(arguments),\n    query;\n\n  args.forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.listCollections: index required');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.listCollections', cb);\n\n  query = {type: options && options.type || 'all'};\n\n  this.query({index: index, controller: 'collection', action: 'list'}, query, options, function (err, res) {\n    cb(err, err ? undefined : res.result.collections);\n  });\n};\n\n/**\n * Returns the list of existing indexes in Kuzzle\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.listIndexes = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.listIndexes', cb);\n\n  this.query({controller: 'index', action: 'list'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.indexes);\n  });\n};\n\n/**\n * Disconnects from Kuzzle and invalidate this instance.\n */\nKuzzle.prototype.disconnect = function () {\n  var collection;\n\n  this.state = 'disconnected';\n  this.network.close();\n  this.network = null;\n\n  for (collection in this.collections) {\n    if (this.collections.hasOwnProperty(collection)) {\n      delete this.collections[collection];\n    }\n  }\n};\n\n/**\n * Returns the server informations\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getServerInfo = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n  this.query({controller: 'server', action: 'info'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.serverInfo);\n  });\n};\n\n/**\n * Forces an index refresh\n *\n * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n * @returns {Kuzzle}\n */\nKuzzle.prototype.refreshIndex = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.refreshIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.query({ index: index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\n  return this;\n};\n\n/**\n * Returns de current autoRefresh status for the given index\n *\n * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optinal arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getAutoRefresh = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.getAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n  this.query({ index: index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n};\n\n/**\n * (Un)Sets the autoRefresh flag on the given index\n *\n * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n * @param {boolean} autoRefresh - The autoRefresh value to set\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query result\n * @returns {object} this\n */\nKuzzle.prototype.setAutoRefresh = function () {\n  var\n    index,\n    autoRefresh,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'boolean':\n        autoRefresh = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.setAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (autoRefresh === undefined) {\n    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n  }\n\n  this.query({ index: index, controller: 'index', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\n  return this;\n};\n\n/**\n * Return the current Kuzzle's UTC Epoch time, in milliseconds\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.now = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.now', cb);\n\n  this.query({controller: 'server', action: 'now'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.now);\n  });\n};\n\n/**\n * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n * Base method used to send read queries to Kuzzle\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} queryArgs - Query configuration\n * @param {object} query - The query data\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n  var\n    attr,\n    object = {\n      action: queryArgs.action,\n      controller: queryArgs.controller,\n      volatile: this.volatile\n    },\n    self = this;\n\n  this.isValid();\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options) {\n    if (options.queuable === false && self.state === 'offline') {\n      return self;\n    }\n\n    if (options.refresh) {\n      object.refresh = options.refresh;\n    }\n\n    if (typeof options.from !== 'undefined' && options.from !== null) {\n      object.from = options.from;\n    }\n\n    if (options.size) {\n      object.size = options.size;\n    }\n\n    if (options.scroll) {\n      object.scroll = options.scroll;\n    }\n\n    if (options.scrollId) {\n      object.scrollId = options.scrollId;\n    }\n\n    if (options.volatile) {\n      Object.keys(options.volatile).forEach(function (meta) {\n        object.volatile[meta] = options.volatile[meta];\n      });\n    }\n  }\n\n  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n    throw new Error('Invalid query parameter: ' + query);\n  }\n\n  if (query.volatile) {\n    Object.keys(query.volatile).forEach(function (meta) {\n      object.volatile[meta] = query.volatile[meta];\n    });\n  }\n\n  for (attr in query) {\n    if (attr !== 'volatile' && query.hasOwnProperty(attr)) {\n      object[attr] = query[attr];\n    }\n  }\n\n  object = self.addHeaders(object, this.headers);\n\n  /*\n   * Do not add the token for the checkToken route, to avoid getting a token error when\n   * a developer simply wish to verify his token\n   */\n  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n    object.jwt = self.jwtToken;\n  }\n\n  if (queryArgs.collection) {\n    object.collection = queryArgs.collection;\n  }\n\n  if (queryArgs.index) {\n    object.index = queryArgs.index;\n  }\n\n  if (!object.requestId) {\n    object.requestId = uuidv4();\n  }\n\n  object.volatile.sdkVersion = this.sdkVersion;\n  object.volatile.sdkInstanceId = this.id;\n\n  if (self.state === 'connected' || (options && options.queuable === false)) {\n    if (self.state === 'connected') {\n      emitRequest.call(this, object, cb);\n    } else {\n      discardRequest(object, cb);\n    }\n  } else if (self.queuing || (options && options.queuable === true) || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n    cleanQueue.call(this, object, cb);\n    if (!self.queueFilter || self.queueFilter(object)) {\n      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n    } else {\n      discardRequest(object, cb);\n    }\n  }\n  else {\n    discardRequest(object, cb);\n  }\n\n  return self;\n};\n\n/**\n * Replays the requests queued during offline mode.\n * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n */\nKuzzle.prototype.replayQueue = function () {\n  if (this.state !== 'offline' && !this.autoReplay) {\n    cleanQueue.call(this);\n    dequeue.call(this);\n  }\n\n  return this;\n};\n\n/**\n * Sets the default Kuzzle index\n *\n * @param index\n * @returns this\n */\nKuzzle.prototype.setDefaultIndex = function (index) {\n  if (typeof index !== 'string') {\n    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n  }\n\n  if (index.length === 0) {\n    throw new Error('Cannot set an empty index as the default index');\n  }\n\n  this.defaultIndex = index;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzle.prototype.setHeaders = function (content, replace) {\n  var self = this;\n\n  if (typeof content !== 'object' || Array.isArray(content)) {\n    throw new Error('Expected a content object, received a ' + typeof content);\n  }\n\n  if (replace) {\n    self.headers = content;\n  } else {\n    Object.keys(content).forEach(function (key) {\n      self.headers[key] = content[key];\n    });\n  }\n\n  return self;\n};\n\n/**\n * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.startQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = true;\n  }\n  return this;\n};\n\n/**\n * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.stopQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = false;\n  }\n\n  return this;\n};\n\nfunction discardRequest(object, cb) {\n  if (cb) {\n    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n  }\n}\n\nfunction disableAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.subscribing = false;\n    });\n  });\n}\n\nmodule.exports = Kuzzle;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","var\n  KuzzleSearchResult = require('./SearchResult'),\n  Document = require('./Document'),\n  CollectionMapping = require('./CollectionMapping'),\n  Room = require('./Room'),\n  SubscribeResult = require('./SubscribeResult');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n *\n * @property {string} collection\n * @property {string} index\n * @property {Kuzzle} kuzzle\n * @property {Array.<string>} collection\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} collection - name of the data collection to handle\n * @param {string} index - Index containing the data collection\n * @constructor\n */\nfunction Collection(kuzzle, collection, index) {\n  if (!index || !collection) {\n    throw new Error('The Collection object constructor needs an index and a collection arguments');\n  }\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.count = function (filters, options, cb) {\n  var\n    query;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.count', cb);\n\n  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n    cb(err, err ? undefined : res.result.count);\n  });\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [mappings] - Optional collection mappings\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.create = function () {\n  var\n    i,\n    data = {},\n    mapping = null,\n    options = null,\n    cb = null,\n    self = this;\n\n  for (i = 0; i < arguments.length; i++) {\n    if (typeof arguments[i] === 'function') {\n      if (i < arguments.length - 1) {\n        throw new Error('Invalid argument: ' + arguments[i+1]);\n      }\n\n      cb = arguments[i];\n    } else if (typeof arguments[i] === 'object' && !Array.isArray(arguments[i])) {\n      if (mapping === null) {\n        mapping = arguments[i];\n      } else if (options === null) {\n        options = arguments[i];\n      } else {\n        throw new Error('Too many objects arguments');\n      }\n    } else {\n      throw new Error('Invalid argument: ' + arguments[i]);\n    }\n  }\n\n  if (mapping === null || (options === null && typeof mapping.queuable === 'boolean')) {\n    options = mapping;\n    data = {};\n  } else {\n    data = {body: mapping};\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n *        If the same document already exists:\n *          - resolves with an error if set to \"error\".\n *          - replaces the existing document if set to \"replace\"\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a Document object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options && options.ifExist) {\n    if (options.ifExist === 'replace') {\n      action = 'createOrReplace';\n    }\n    else if (options.ifExist !== 'error') {\n      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n    }\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  data = self.kuzzle.addHeaders(data, self.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    var doc;\n\n    if (err) {\n      return cb(err);\n    }\n\n    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n    doc.version = res.result._version;\n    cb(null, doc);\n  });\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Collection} this\n */\nCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = {query: arg};\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    if (err) {\n      cb(err);\n    }\n    else {\n      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n    }\n  });\n\n  return this;\n};\n\n/**\n * Deletes the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.deleteSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Returns a boolean indicating whether or not a document with provided ID exists.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} options [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.documentExists = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.fetch', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n};\n\n/**\n * Instantiates a CollectionMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\n  kuzzleMapping = new CollectionMapping(this);\n  kuzzleMapping.refresh(options, cb);\n};\n\n/**\n * Create the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Create or replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create or replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Delete specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to delete\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Get specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Update the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to update\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Retrieves the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.getSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a Document instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\n\nCollection.prototype.search = function (filters, options, cb) {\n  var\n    query,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.search', cb);\n\n  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      result.result.aggregations ? result.result.aggregations : {},\n      options,\n      filters,\n      options.previous || null\n    ));\n  });\n};\n\n/**\n * A \"scroll\" option can be passed to search queries, creating persistent\n * paginated results.\n * This method can be used to manually get the next page of a search result,\n * instead of using KuzzleSearchResult.next()\n *\n * @param {string} scrollId\n * @param {object} [options]\n * @param {object} [filters]\n * @param {responseCallback} cb\n */\nCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Collection.scroll: scrollId is required');\n  }\n\n  if (!cb) {\n    cb = filters;\n    filters = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      {},\n      options,\n      filters,\n      options.previous || null\n    ));\n  });\n\n  return this;\n};\n\n/**\n * Retrieves next result of a search with scroll query.\n *\n * @param {string} scrollId\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n  var\n    data = { scrollId: scrollId };\n\n  if (!scrollId) {\n    throw new Error('Collection.scrollSpecifications: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\n  if (options && options.scroll) {\n    data.scroll = options.scroll;\n  }\n\n  this.kuzzle.query(\n    { controller: 'collection', action: 'scrollSpecifications'},\n    this.kuzzle.addHeaders(data, this.headers),\n    options,\n    function (err, res) {\n      cb (err, err ? undefined : res.result);\n    }\n  );\n};\n\n/**\n * Searches specifications across indexes/collections according to the provided filters\n *\n * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.searchSpecifications = function (filters, options, cb) {\n  var\n    data = { body: { query: filters } },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} cb - called for each new notification\n * @returns {*} KuzzleSubscribeResult object\n */\nCollection.prototype.subscribe = function (filters, options, cb) {\n  var\n    room,\n    subscribeResult;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.subscribe', cb);\n\n  subscribeResult = new SubscribeResult();\n  room = new Room(this, options);\n\n  room.renew(filters, cb, subscribeResult.done.bind(subscribeResult));\n\n  return subscribeResult;\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options && options.retryOnConflict) {\n    data.retryOnConflict = options.retryOnConflict;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    (new Document(self, res.result._id)).refresh(cb);\n  });\n\n  return self;\n};\n\n/**\n * Updates the current specifications of this collection\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Validates the provided specifications\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result.valid);\n  });\n};\n\n/**\n * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nCollection.prototype.document = function (id, content) {\n  return new Document(this, id, content);\n};\n\n/**\n * Instantiate a new Room object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [options] - subscription configuration\n * @constructor\n */\nCollection.prototype.room = function (options) {\n  return new Room(this, options);\n};\n\n/**\n * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n * @constructor\n */\nCollection.prototype.collectionMapping = function (mapping) {\n  return new CollectionMapping(this, mapping);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nCollection.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = Collection;\n","/**\n * @param {Collection} collection\n * @param {int} total\n * @param {Document[]} documents\n * @param {object} aggregations\n * @param {object} options\n * @param {object} filters\n * @param {SearchResult} previous\n * @property {Collection} collection\n * @property {number} total\n * @property {Document[]} documents\n * @property {object} aggregations\n * @property {object} options\n * @property {object} filters\n * @property {number} fetchedDocument\n * @constructor\n */\nfunction SearchResult (collection, total, documents, aggregations, options, filters, previous) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    total: {\n      value: total,\n      enumerable: true\n    },\n    documents: {\n      value: documents,\n      enumerable: true\n    },\n    aggregations: {\n      value: aggregations || {},\n      enumerable: true\n    },\n    options: {\n      value: options || {},\n      enumerable: true\n    },\n    filters: {\n      value: filters || {},\n      enumerable: true\n    },\n    // writable properties\n    fetchedDocument: {\n      value: previous instanceof SearchResult ? documents.length + previous.fetchedDocument : documents.length,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  // promisifying\n  if (this.collection.kuzzle.bluebird) {\n    return this.collection.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['fetchNext'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * @param {function} cb\n */\nSearchResult.prototype.fetchNext = function (cb) {\n  var\n    filters,\n    options = Object.assign({}, this.options),\n    self = this;\n  \n  options.previous = this;\n\n  // retrieve next results with scroll if original search use it\n  if (options.scrollId) {\n    if (this.fetchedDocument >= this.getTotal()) {\n      cb(null, null);\n      return;\n    }\n\n    // from and size parameters are not valid for a scroll action\n    if (typeof options.from !== 'undefined') {\n      delete options.from;\n    }\n\n    if (options.size) {\n      delete options.size;\n    }\n\n    this.collection.scroll(options.scrollId, options, this.filters || {}, cb);\n\n    return;\n  }\n\n  // retrieve next results using ES's search_after\n  if (options.size && this.filters.sort) {\n    if (this.fetchedDocument >= this.getTotal()) {\n      cb(null, null);\n      return;\n    }\n\n    if (options.from) {\n      delete options.from;\n    }\n\n    filters = Object.assign(this.filters, {search_after: []});\n\n    filters.sort.forEach(function (sortRule) {\n      filters.search_after.push(self.documents[self.documents.length - 1].content[Object.keys(sortRule)[0]]);\n    });\n\n    this.collection.search(filters, options, cb);\n\n    return;\n  }\n\n  // retrieve next results with from/size if original search use it\n  if (options.from !== undefined && options.size !== undefined) {\n    filters = Object.assign({}, this.filters);\n\n    // check if we need to do next request to fetch all matching documents\n    options.from += options.size;\n\n    if (options.from >= this.getTotal()) {\n      cb(null, null);\n\n      return;\n    }\n\n    this.collection.search(filters, options, cb);\n\n    return;\n  }\n\n  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n};\n\n/**\n * @returns {Document[]}\n */\nSearchResult.prototype.getDocuments = function () {\n  return this.documents;\n};\n\n/**\n * @returns {number}\n */\nSearchResult.prototype.getTotal = function () {\n  return this.total;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getAggregations = function () {\n  return this.aggregations;\n};\n\n/**\n * @returns {Object}\n */\nSearchResult.prototype.getOptions = function() {\n  return this.options;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getFilters = function() {\n  return this.filters;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getCollection = function () {\n  return this.collection;\n};\n\n/**\n * @returns {number}\n */\nSearchResult.prototype.getFetchedDocument = function () {\n  return this.fetchedDocument;\n};\n\nmodule.exports = SearchResult;\n","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you won’t be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} collection - Instance of the inherited Collection object\n * @param {object} [mapping] - mappings\n * @constructor\n */\nfunction CollectionMapping(collection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(collection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set', 'setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nCollectionMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the “apply” function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nCollectionMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n      }\n    } else {\n      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function won’t be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {CollectionMapping}\n */\nCollectionMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nCollectionMapping.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = CollectionMapping;\n","var\n  uuidv4 = require('uuid/v4'),\n  Document = require('./Document');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you don’t exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then you’ll receive a notification about it.\n *\n * @param {object} collection - an instantiated and valid kuzzle object\n * @param {object} [options] - subscription optional configuration\n * @constructor\n */\nfunction Room(collection, options) {\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    callback: {\n      value: null,\n      writable: true\n    },\n    channel: {\n      value: null,\n      writable: true\n    },\n    id: {\n      value: uuidv4()\n    },\n    lastRenewal: {\n      value: null,\n      writable: true\n    },\n    notifier: {\n      value: null,\n      writable: true\n    },\n    onDoneCB: {\n      value: null,\n      writable: true\n    },\n    queue: {\n      value: [],\n      writable: true\n    },\n    // Delay before allowing a subscription renewal\n    renewalDelay: {\n      value: 500\n    },\n    scope: {\n      value: options && options.scope ? options.scope : 'all'\n    },\n    state: {\n      value: options && options.state ? options.state : 'done'\n    },\n    subscribing: {\n      value: false,\n      writable: true\n    },\n    users: {\n      value: options && options.users ? options.users : 'none'\n    },\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    filters: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(collection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    volatile: {\n      value: (options && options.volatile) ? options.volatile : {},\n      enumerable: true,\n      writable: true\n    },\n    roomId: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    subscribeToSelf: {\n      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['count'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of other subscriptions on that room.\n *\n * @param {responseCallback} cb - Handles the query response\n */\nRoom.prototype.count = function (cb) {\n  var data;\n\n  this.kuzzle.callbackRequired('Room.count', cb);\n\n  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\n  if (!isReady.call(this)) {\n    this.queue.push({action: 'count', args: [cb]});\n    return;\n  }\n\n  if (!this.roomId) {\n    throw new Error('Room.count: cannot count subscriptions on an inactive room');\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n    cb(err, res && res.result.count);\n  });\n};\n\n/**\n * Renew the subscription using new filters\n *\n * @param {object} [filters] - Filters in Kuzzle DSL format\n * @param {responseCallback} notificationCB - called for each new notification\n * @param {responseCallback} [cb] - handles the query response\n */\nRoom.prototype.renew = function (filters, notificationCB, cb) {\n  var\n    self = this,\n    now = Date.now(),\n    subscribeQuery = {\n      scope: self.scope,\n      state: self.state,\n      users: self.users\n    };\n\n  if (typeof filters === 'function') {\n    cb = notificationCB;\n    notificationCB = filters;\n    filters = null;\n  }\n\n  if (!cb) {\n    cb = self.onDoneCB;\n  }\n\n  self.kuzzle.callbackRequired('Room.renew', notificationCB);\n\n  /*\n    Skip subscription renewal if another one was performed a moment before\n   */\n  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n    return cb && cb(new Error('Subscription already renewed less than ' + self.renewalDelay + 'ms ago'));\n  }\n\n  if (filters) {\n    self.filters = filters;\n  }\n\n  /*\n   if not yet connected, register itself to the subscriptions list and wait for the\n   main Kuzzle object to renew once online\n    */\n  if (self.kuzzle.state !== 'connected') {\n    self.callback = notificationCB;\n    self.onDoneCB = cb;\n    self.kuzzle.subscriptions.pending[self.id] = self;\n    return;\n  }\n\n  if (self.subscribing) {\n    self.queue.push({action: 'renew', args: [filters, notificationCB, cb]});\n    return;\n  }\n\n  self.unsubscribe();\n  self.roomId = null;\n  self.subscribing = true;\n  self.callback = notificationCB;\n  self.onDoneCB = cb;\n  self.kuzzle.subscriptions.pending[self.id] = self;\n\n  subscribeQuery.body = self.filters;\n  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, self.headers);\n\n  self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'subscribe'), subscribeQuery, {volatile: self.volatile}, function (error, response) {\n    delete self.kuzzle.subscriptions.pending[self.id];\n    self.subscribing = false;\n\n    if (error) {\n      self.queue = [];\n      return cb && cb(new Error('Error during Kuzzle subscription: ' + error.message));\n    }\n\n    self.lastRenewal = now;\n    self.roomId = response.result.roomId;\n    self.channel = response.result.channel;\n\n    if (!self.kuzzle.subscriptions[self.roomId]) {\n      self.kuzzle.subscriptions[self.roomId] = {};\n    }\n\n    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\n    self.notifier = notificationCallback.bind(self);\n    self.kuzzle.network.on(self.channel, self.notifier);\n\n    dequeue.call(self);\n    cb && cb(null, self);\n  });\n};\n\n/**\n * Unsubscribes from Kuzzle.\n *\n * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n * pending subscriptions reaches 0, and only if there is still no listener on that room.\n * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n *\n * @return {*} this\n */\nRoom.prototype.unsubscribe = function () {\n  var\n    self = this,\n    room = self.roomId,\n    interval;\n\n  if (!isReady.call(this)) {\n    self.queue.push({action: 'unsubscribe', args: []});\n    return self;\n  }\n\n  if (room) {\n    self.kuzzle.network.off(self.channel, this.notifier);\n\n    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n      delete self.kuzzle.subscriptions[room];\n\n      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n        self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n      } else {\n        interval = setInterval(function () {\n          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n            if (!self.kuzzle.subscriptions[room]) {\n              self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n            }\n            clearInterval(interval);\n          }\n        }, 100);\n      }\n    } else {\n      delete self.kuzzle.subscriptions[room][self.id];\n    }\n\n    self.roomId = null;\n  }\n\n  return self;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nRoom.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n/**\n * Callback called by the network handler when a message is sent to the subscribed room ID\n * Calls the registered callback if the notification passes the subscription filters\n *\n * @param {object} data - data\n * @returns {*}\n */\nfunction notificationCallback (data) {\n  var notificationData = Object.assign({}, data);\n\n  if (data.type === 'TokenExpired') {\n    this.kuzzle.jwtToken = undefined;\n    return this.kuzzle.emitEvent('tokenExpired');\n  }\n\n  if (notificationData.type === 'document') {\n    notificationData.document = new Document(this.collection, notificationData.result._id, notificationData.result._source, notificationData.result._meta);\n    delete notificationData.result;\n  }\n\n  if (this.subscribeToSelf || !notificationData.volatile || notificationData.volatile.sdkInstanceId !== this.kuzzle.id) {\n    this.callback(null, notificationData);\n  }\n}\n\n\n/**\n * Dequeue actions performed while subscription was being renewed\n */\nfunction dequeue () {\n  var element;\n\n  while (this.queue.length > 0) {\n    element = this.queue.shift();\n\n    this[element.action].apply(this, element.args);\n  }\n}\n\nfunction isReady() {\n  return this.kuzzle.state === 'connected' && !this.subscribing;\n}\n\nmodule.exports = Room;\n","/**\n * Sugar-code handling the result of a Room.renew call\n * @constructor\n */\nfunction SubscribeResult() {\n  this.cbs = [];\n  this.error = null;\n  this.room = null;\n}\n\n/**\n * Registers a callback to be called with a subscription result\n * @param {Function} cb\n */\nSubscribeResult.prototype.onDone = function (cb) {\n  if (this.error || this.room) {\n    cb(this.error, this.room);\n  }\n  else {\n    this.cbs.push(cb);\n  }\n\n  return this;\n};\n\n/**\n * Calls all registered callbacks\n *\n * @param {Object} error object\n * @param {Room} room\n */\nSubscribeResult.prototype.done = function (error, room) {\n  this.error = error;\n  this.room = room;\n\n  this.cbs.forEach(function (cb) {\n    cb(error, room);\n  });\n};\n\nmodule.exports = SubscribeResult;\n","var\n  Role = require('./Role'),\n  Profile = require('./Profile'),\n  User = require('./User');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {Security}\n * @constructor\n */\nfunction Security(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.fetchRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for fetchRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new Role(self, doc._id, doc._source, doc._meta);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @param {object} meta - role metadata\n * @constructor\n */\nSecurity.prototype.role = function(id, content, meta) {\n  return new Role(this, id, content, meta);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new Profile(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {array} policies - list of policies to attach to the new profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = { policies: policies };\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {array} policies - the list of policies to apply to this profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = {policies: policies};\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollProfiles: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n    var profiles = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (profile) {\n      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\n      newProfile.version = profile._version;\n\n      profiles.push(newProfile);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      profiles: profiles,\n      scrollId: scrollId\n    });\n  });\n};\n\n/**\n * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @param {object} meta - profile metadata\n * @constructor\n */\nSecurity.prototype.profile = function(id, content, meta) {\n  return new Profile(this, id, content, meta);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId = null;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new User(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Replace an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.replaceUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (content.profileIds) {\n    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollUsers: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n    var users = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (user) {\n      var newUser = new User(self, user._id, user._source, user._meta);\n\n      newUser.version = user._version;\n\n      users.push(newUser);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      users: users,\n      scrollId: scrollId\n    });\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @param {object} meta - user metadata\n * @constructor\n */\nSecurity.prototype.user = function(id, content, meta) {\n  return new User(this, id, content, meta);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the user <kuid> .\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a list of accepted fields per authentication strategy.\n *\n * @param options\n * @param cb\n */\nSecurity.prototype.getAllCredentialFields = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Retrieve the list of accepted field names by the specified <strategy>.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Get credential information of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Check the existence of the specified <strategy>’s credentials for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Updates credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n */\nSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\nmodule.exports = Security;\n","var SecurityDocument = require('./SecurityDocument');\n\nfunction Role(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nRole.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Role\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Role} this object\n */\nRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = Role;\n","var SecurityDocument = require('./SecurityDocument');\n\nfunction Profile(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nProfile.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Profile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Profile} this\n */\nProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {Profile} this\n */\nProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {Profile} this\n */\nProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = Profile;\n","// Parameter mutualization\nvar\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true,\n    required: ['_id', 'cursor'],\n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']},\n  setIdFieldValue = {required: ['_id', 'field', 'value']},\n  setEntries = {required: ['entries']};\n\n// Redis commands\nvar\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds']},\n    expireat: {required: ['_id', 'timestamp']},\n    flushdb: {},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: getIdField,\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: setIdFieldValue,\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries']},\n    hscan: getxScan,\n    hset: setIdFieldValue,\n    hsetnx: setIdFieldValue,\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value']},\n    ltrim: {required: ['_id', 'start', 'stop']},\n    mget: getKeys,\n    mset: setEntries,\n    msetnx: setEntries,\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: setId,\n    pexpire: {required: ['_id', 'milliseconds']},\n    pexpireat: {required: ['_id', 'timestamp']},\n    pfadd: {required: ['_id', 'elements']},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources']},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds']},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey']},\n    renamenx: {required: ['_id', 'newkey']},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx']},\n    setex: {required: ['_id', 'value', 'seconds']},\n    setnx: setIdValue,\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: getMember,\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member']},\n    sort: {required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction MemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  this.setHeaders = kuzzle.setHeaders.bind(this);\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\n(function () {\n  Object.keys(commands).forEach(function (command) {\n    MemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (args.length && typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\n      if (!commands[command].getter) {\n        data.body = {};\n      }\n\n      if (commands[command].required) {\n        commands[command].required.forEach(function (param) {\n          var value = args.shift();\n\n          if (value === undefined) {\n            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n          }\n\n          assignParameter(data, commands[command].getter, param, value);\n        });\n      }\n\n      if (args.length > 1) {\n        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n      }\n\n      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n      }\n\n      if (args.length) {\n        options = Object.assign({}, args[0]);\n\n        if (Array.isArray(commands[command].opts)) {\n          commands[command].opts.forEach(function (opt) {\n            if (options[opt] !== null && options[opt] !== undefined) {\n              assignParameter(data, commands[command].getter, opt, options[opt]);\n              delete options[opt];\n            }\n          });\n        }\n      }\n\n      /*\n       Options function mapper does not necessarily need\n       options to be passed by clients.\n       */\n      if (typeof commands[command].opts === 'function') {\n        commands[command].opts(data, options || {});\n      }\n\n      this.kuzzle.query(query, data, options, cb && function (err, res) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (commands[command].mapResults) {\n          return cb(null, commands[command].mapResults(res.result));\n        }\n\n        cb(null, res.result);\n      });\n\n      if (!commands[command].getter) {\n        return this;\n      }\n    };\n  });\n})();\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  var parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions(data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults(results) {\n  return results.map(function (coords) {\n    return coords.map(function (latlon) {\n      return parseFloat(latlon);\n    });\n  });\n}\n\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    var p = {\n        name: point[0]\n      },\n      i;\n\n    for (i = 1; i < point.length; i++) {\n      // withcoord result are in an array...\n      if (Array.isArray(point[i])) {\n        p.coordinates = point[i].map(function (coord) {\n          return parseFloat(coord);\n        });\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(point[i]);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray (results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt(results) {\n  return results.map(function (value) {\n    return parseInt(value);\n  });\n}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults(results) {\n  var\n    buffer = null,\n    mapped = [];\n\n  results.forEach(function (value) {\n    if (buffer === null) {\n      buffer = value;\n    }\n    else {\n      mapped.push({member: buffer, score: parseFloat(value)});\n      buffer = null;\n    }\n  });\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n *\n * @param  {array.<string|array>} results\n * @return {object}\n */\nfunction mapScanResults(results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorage;\n","/**\n *\n * @param host\n * @param port\n * @param sslConnection\n * @returns {Object} tnstantiated WebSocket/Socket.IO object\n */\n\nfunction network(host, port, sslConnection) {\n  // Web browser / NodeJS websocket handling\n  if (typeof window !== 'undefined') {\n    // use native websockets if the browser supports it\n    if (typeof WebSocket !== 'undefined') {\n      return new (require('./wrappers/websocket'))(host, port, sslConnection);\n    }\n    // otherwise fallback to socket.io, if available\n    else if (window.io) {\n      return new (require('./wrappers/socketio'))(host, port, sslConnection);\n    }\n\n    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n  }\n\n  return new (require('./wrappers/websocket'))(host, port, sslConnection);\n}\n\nmodule.exports = network;\n","function SocketIO(host, port, ssl) {\n  this.host = host;\n  this.port = port;\n  this.ssl = ssl;\n  this.socket = null;\n  this.wasConnected = false;\n  this.forceDisconnect = false;\n  this.handlers = {\n    connect: [],\n    reconnect: [],\n    connectError: [],\n    disconnect: []\n  };\n  this.retrying = false;\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    var self = this;\n\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: autoReconnect,\n      reconnectionDelay: reconnectionDelay,\n      forceNew: true\n    });\n\n    this.socket.on('connect', function() {\n      if (self.wasConnected) {\n        self.handlers.reconnect.forEach(function(handler) {\n          handler();\n        });\n      }\n      else {\n        self.handlers.connect.forEach(function(handler) {\n          handler();\n        });\n      }\n\n      self.wasConnected = true;\n    });\n\n    this.socket.on('connect_error', function(error) {\n      onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n    });\n\n    this.socket.on('disconnect', function() {\n      var error;\n\n      if (self.forceDisconnect) {\n        self.handlers.disconnect.forEach(function(handler) {\n          handler();\n        });\n      }\n      else {\n        error = new Error('An error occurred, this may due that kuzzle was not ready yet');\n        error.status = 500;\n\n        onClientNetworkError(self, autoReconnect, reconnectionDelay, error);\n      }\n\n      self.forceDisconnect = false;\n    });\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    if (this.handlers.connect.indexOf(callback) === -1) {\n      this.handlers.connect.push(callback);\n    }\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    if (this.handlers.connectError.indexOf(callback) === -1) {\n      this.handlers.connectError.push(callback);\n    }\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    if (this.handlers.disconnect.indexOf(callback) === -1) {\n      this.handlers.disconnect.push(callback);\n    }\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    if (this.handlers.reconnect.indexOf(callback) === -1) {\n      this.handlers.reconnect.push(callback);\n    }\n  };\n\n  /**\n   * Registers a callback on a room. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.once = function (roomId, callback) {\n    this.socket.once(roomId, callback);\n  };\n\n  /**\n   * Registers a callback on a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.on = function (roomId, callback) {\n    this.socket.on(roomId, callback);\n  };\n\n  /**\n   * Unregisters a callback from a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.off = function (roomId, callback) {\n    this.socket.off(roomId, callback);\n  };\n\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    this.socket.emit('kuzzle', payload);\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.forceDisconnect = true;\n\n    this.socket.close();\n    this.socket = null;\n  };\n}\n\n/**\n * Called when the connection closes with an error state\n *\n * @param {SocketIO}\n * @param {boolean} autoReconnect\n * @param {number} reconnectionDelay\n * @param {Error} error\n */\nfunction onClientNetworkError(socketio, autoReconnect, reconnectionDelay, error) {\n  if (autoReconnect && !socketio.retrying && !socketio.stopRetryingToConnect) {\n    socketio.retrying = true;\n    setTimeout(function () {\n      socketio.retrying = false;\n      socketio.connect(autoReconnect, reconnectionDelay);\n    }, reconnectionDelay);\n  }\n\n  socketio.handlers.connectError.forEach(function(handler) {\n    handler(error);\n  });\n}\n\n\nmodule.exports = SocketIO;\n"],"sourceRoot":""}