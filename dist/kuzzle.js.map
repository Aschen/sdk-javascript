{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9e5605a1d579c69f67e7","webpack:///./src/eventEmitter/index.js","webpack:///./src/Document.js","webpack:///./src/security/SecurityDocument.js","webpack:///./node_modules/uuid/v4.js","webpack:///./src/security/User.js","webpack:///./src/networkWrapper/protocols/abstract/realtime.js","webpack:///./src/Kuzzle.js","webpack:///./node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./src/Collection.js","webpack:///./src/SearchResult.js","webpack:///./src/CollectionMapping.js","webpack:///./src/Room.js","webpack:///./src/security/Security.js","webpack:///./src/security/Role.js","webpack:///./src/security/Profile.js","webpack:///./src/MemoryStorage.js","webpack:///./src/networkWrapper/index.js","webpack:///./src/networkWrapper/protocols/websocket.js","webpack:///./src/networkWrapper/protocols/socketio.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Listener","fn","once","arguments","length","undefined","_classCallCheck","KuzzleEventEmitter","_events","listeners","Boolean","find","listener","eventName","map","listenerType","_typeof","Error","_exists","push","addListener","concat","addOnceListener","prependListener","index","findIndex","splice","onceListeners","_len","payload","Array","_key","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","value","apply","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","toDelete","removeListener","keys","Document","collection","documentId","content","meta","defineProperties","dataCollection","kuzzle","id","writable","version","_version","setContent","bluebird","promisifyAll","suffix","filter","func","target","passes","indexOf","serialize","data","_id","body","toString","JSON","stringify","delete","options","cb","query","buildQueryArgs","exists","res","result","refresh","callbackRequired","error","newDocument","_source","_meta","save","publish","replace","forEach","key","subscribe","filters","ids","values","SecurityDocument","Security","deleteActionName","update","updateActionName","response","rng","bytesToUuid","buf","offset","rnds","random","ii","KuzzleSecurityDocument","User","credentials","create","constructor","setProfiles","profileIds","isArray","setCredentials","addProfile","profileId","creationSerialize","saveRestricted","getProfileIds","getProfiles","fetchedProfiles","errored","fetchProfile","profile","uuidv4","RTWrapper","host","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","port","ssl","sslConnection","queuing","reconnectionDelay","autoReconnect","autoQueue","autoReplay","state","offlineQueue","queueFilter","queueMaxSize","queueTTL","replayInterval","offlineQueueLoader","opt","getOwnPropertyDescriptor","offlineMode","wasConnected","stopRetryingToConnect","retrying","startQueuing","emit","stopQueuing","playQueue","_this2","setTimeout","connect","cleanQueue","network","uniqueQueue","additionalQueue","request","requestId","action","controller","dequeuingProcess","emitRequest","shift","Math","max","dequeue","notificationCB","_this3","on","channel","fromSelf","volatile","sdkInstanceId","removeAllListeners","queuable","ts","Date","now","discardRequest","jwt","message","assign","status","send","lastDocumentIndex","droppedRequest","Collection","MemoryStorage","networkWrapper","Kuzzle","_ret","eventActions","autoResubscribe","defaultIndex","protocol","sdkVersion","room","opts","subscribeCB","scope","users","type","unsetJwt","copy","document","notify","unsubscribeCB","roomId","unsubscribe","errorMessagePrefix","callback","eventTimeout","connected","timeout","disconnected","reconnected","tokenExpired","loginAttempt","set","checkPropertyType","eumerable","_get2","protectedEvent","protectedEvents","lastEmitted","_get","connectionError","internal","disconnect","checkToken","valid","token","success","strategy","_this4","expiresIn","setJwt","_this5","_this6","security","hits","event","startTime","stopTime","_len2","args","_key2","collections","flushQueue","_len3","_key3","arg","indexes","close","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","serverInfo","_len4","_key4","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_len5","_key5","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","autoRefresh","_len6","_key6","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","queryArgs","_arr","_i","prop","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","attr","typestr","crypto","window","msCrypto","getRandomValues","rnds8","Uint8Array","r","byteToHex","substr","bth","KuzzleSearchResult","CollectionMapping","Room","count","createDocument","ifExist","doc","deleteDocument","deleteSpecifications","documentExists","fetchDocument","getMapping","mCreateDocument","documents","mCreateOrReplaceDocument","mDeleteDocument","documentIds","mGetDocument","mReplaceDocument","mUpdateDocument","getSpecifications","publishMessage","replaceDocument","search","scroll","scrollId","scrollSpecifications","searchSpecifications","evtName","truncate","updateDocument","retryOnConflict","updateSpecifications","specifications","validateSpecifications","collectionMapping","mapping","SearchResult","raw","total","aggregations","from","size","_scroll_id","fetched","freeze","whitelist","includes","updateAfterSearch","sort","search_after","lastDocumentContent","sortRule","properties","mappings","field","_roomId","roomstate","isListening","resubscribe","deactivate","resubscribeConditional","subscribeToSelf","onDone","Role","Profile","fetchRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","role","searchProfiles","profiles","createProfile","policies","updateProfile","updatedContent","deleteProfile","scrollProfiles","newProfile","fetchUser","searchUsers","createUser","replaceUser","createRestrictedUser","updateUser","deleteUser","scrollUsers","user","newUser","isActionAllowed","rights","filteredRights","right","some","item","getUserRights","userId","createCredentials","kuid","deleteCredentials","getAllCredentialFields","getCredentialFields","getCredentials","hasCredentials","updateCredentials","validateCredentials","addPolicy","policy","roleId","setPolicies","getPolicies","getId","required","getIdField","getKeys","getMember","getxScan","mapResults","mapScanResults","getZrange","assignZrangeOptions","mapZrangeResults","getZrangeBy","setId","setIdValue","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","mapNoResult","geoadd","geodist","parseFloat","geohash","geopos","results","coords","latlon","georadius","assignGeoRadiusOptions","mapGeoRadiusResults","georadiusbymember","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","setex","setnx","sinter","sinterstore","sismember","smembers","smove","spop","mapStringToArray","srandmember","srem","sscan","strlen","sunion","sunionstore","time","parseInt","touch","ttl","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","assignParameter","parsed","limit","point","coordinates","coord","distance","buffer","mapped","member","score","cursor","command","slice","pop","param","WebSocket","io","WebSocketClient","WSNode","e","code","client","lasturl","url","perMessageDeflate","onopen","clientConnected","onclose","closeEvent","reason","clientDisconnected","clientNetworkError","onerror","onmessage","parse","readyState","OPEN","SocketIO","socket","forceDisconnect","eventsWrapper","reconnection","forceNew","_addEventWrapper","off","wrapper","_event","Set","add"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,UAAAH,GACA,iBAAAC,QACAA,QAAA,OAAAD,IAEAD,EAAA,OAAAC,IARA,CASC,oBAAAK,UAAAC,KAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAR,QAGA,IAAAC,EAAAK,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAV,YAUA,OANAW,EAAAH,GAAAI,KAAAX,EAAAD,QAAAC,IAAAD,QAAAO,GAGAN,EAAAS,GAAA,EAGAT,EAAAD,QAqCA,OAhCAO,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAf,EAAAgB,EAAAC,GACAV,EAAAW,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAvB,GACA,IAAAgB,EAAAhB,KAAAwB,WACA,WAA2B,OAAAxB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAM,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAQ,EAAAC,GAAsD,OAAAR,OAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDpB,EAAAuB,EAAA,GAGAvB,IAAAwB,EAAA,ykBC7DMC,EACJ,SAAAA,EAAYC,GAAkB,IAAdC,EAAcC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAAAG,EAAAjC,KAAA2B,GAC5B3B,KAAK4B,GAAKA,EACV5B,KAAK6B,KAAOA,GAIVK,aACJ,SAAAA,IAAcD,EAAAjC,KAAAkC,GACZlC,KAAKmC,qDAGEC,EAAWR,GAClB,OAAOS,QAAQD,EAAUE,KAAK,SAAAC,GAAA,OAAYA,EAASX,KAAOA,uCAGjDY,GACT,YAAgCR,IAA5BhC,KAAKmC,QAAQK,MAIVxC,KAAKmC,QAAQK,GAAWC,IAAI,SAAAF,GAAA,OAAYA,EAASX,yCAG7CY,EAAWD,GAAwB,IAAdV,EAAcC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAC9C,IAAKU,IAAcD,EACjB,OAAOvC,KAGT,IAAM0C,OAAA,IAAsBH,EAAtB,YAAAI,EAAsBJ,GAE5B,GAAqB,aAAjBG,EACF,MAAM,IAAIE,MAAJ,qDAA+DF,GAWvE,YARgCV,IAA5BhC,KAAKmC,QAAQK,KACfxC,KAAKmC,QAAQK,OAGVxC,KAAK6C,QAAQ7C,KAAKmC,QAAQK,GAAYD,IACzCvC,KAAKmC,QAAQK,GAAWM,KAAK,IAAInB,EAASY,EAAUV,IAG/C7B,gCAGLwC,EAAWD,GACb,OAAOvC,KAAK+C,YAAYP,EAAWD,2CAGpBC,EAAWD,GAAwB,IAAdV,EAAcC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAClD,OAAKU,GAAcD,QAIaP,IAA5BhC,KAAKmC,QAAQK,KACfxC,KAAKmC,QAAQK,OAGVxC,KAAK6C,QAAQ7C,KAAKmC,QAAQK,GAAYD,KACzCvC,KAAKmC,QAAQK,IAAc,IAAIb,EAASY,EAAUV,IAAOmB,OAAOhD,KAAKmC,QAAQK,KAGxExC,MAXEA,6CAcMwC,EAAWD,GAC1B,OAAOvC,KAAK+C,YAAYP,EAAWD,GAAU,gCAGzCC,EAAWD,GACf,OAAOvC,KAAKiD,gBAAgBT,EAAWD,+CAGpBC,EAAWD,GAC9B,OAAOvC,KAAKkD,gBAAgBV,EAAWD,GAAU,0CAGnCC,EAAWD,GACzB,IAAMH,EAAYpC,KAAKmC,QAAQK,GAE/B,IAAKJ,IAAcA,EAAUL,OAC3B,OAAO/B,KAGT,IAAMmD,EAAQf,EAAUgB,UAAU,SAAA/C,GAAA,OAAKA,EAAEuB,KAAOW,IAUhD,OARe,IAAXY,GACFf,EAAUiB,OAAOF,EAAO,GAGD,IAArBf,EAAUL,eACL/B,KAAKmC,QAAQK,GAGfxC,gDAGWwC,GAOlB,OANIA,SACKxC,KAAKmC,QAAQK,GAEpBxC,KAAKmC,WAGAnC,kCAGHwC,GACJ,IAAMJ,EAAYpC,KAAKmC,QAAQK,GAE/B,QAAkBR,IAAdI,EACF,OAAO,EAJkB,IAO3B,IAAMkB,KAPqBC,EAAAzB,UAAAC,OAATyB,EAASC,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAATF,EAASE,EAAA,GAAA5B,UAAA4B,GAAA,IAAAC,GAAA,EAAAC,GAAA,EAAAC,OAAA7B,EAAA,IAS3B,QAAA8B,EAAAC,EAAuB3B,EAAvB4B,OAAAC,cAAAN,GAAAG,EAAAC,EAAAG,QAAAC,MAAAR,GAAA,EAAkC,KAAvBpB,EAAuBuB,EAAAM,MAChC7B,EAASX,GAATyC,MAAA9B,EAAeiB,GAEXjB,EAASV,MACXyB,EAAcR,KAAKP,EAASX,KAbL,MAAA0C,GAAAV,GAAA,EAAAC,EAAAS,EAAA,aAAAX,GAAAI,EAAAQ,QAAAR,EAAAQ,SAAA,WAAAX,EAAA,MAAAC,GAAA,IAAAW,GAAA,EAAAC,GAAA,EAAAC,OAAA1C,EAAA,IAiB3B,QAAA2C,EAAAC,EAAuBtB,EAAvBU,OAAAC,cAAAO,GAAAG,EAAAC,EAAAV,QAAAC,MAAAK,GAAA,EAAsC,KAA3BK,EAA2BF,EAAAP,MACpCpE,KAAK8E,eAAetC,EAAWqC,IAlBN,MAAAP,GAAAG,GAAA,EAAAC,EAAAJ,EAAA,aAAAE,GAAAI,EAAAL,QAAAK,EAAAL,SAAA,WAAAE,EAAA,MAAAC,GAqB3B,OAAO,uCAIP,OAAO5D,OAAOiE,KAAK/E,KAAKmC,+CAGXK,GACb,OAAOxC,KAAKmC,QAAQK,IAAcxC,KAAKmC,QAAQK,GAAWT,QAAU,WAIxEnC,EAAOD,QAAUuC,iBCtHjB,SAAA8C,EAAAC,EAAAC,EAAAC,EAAAC,GA4DA,OA3DAtE,OAAAuE,iBAAArF,MAEAiF,YACAb,MAAAa,aACAhE,YAAA,GAEAqE,gBACAlB,MAAAa,EACAhE,YAAA,GAEAsE,QACAnB,MAAAa,EAAAM,OACAtE,YAAA,GAGAuE,IACApB,WAAApC,EACAf,YAAA,EACAwE,UAAA,GAEAN,SACAf,SACAqB,UAAA,EACAxE,YAAA,GAEAyE,SACAtB,WAAApC,EACAf,YAAA,EACAwE,UAAA,GAEAL,MACAhB,MAAAgB,MACAnE,YAAA,EACAwE,UAAA,MAKAN,GAAAD,GAAA,iBAAAA,IACAC,EAAAD,EACAA,EAAA,MAGAC,IACAA,EAAAQ,WACA3F,KAAA0F,QAAAP,EAAAQ,gBACAR,EAAAQ,UAEA3F,KAAA4F,WAAAT,GAAA,IAGAD,GACApE,OAAAC,eAAAf,KAAA,MACAoE,MAAAc,EACAjE,YAAA,IAKAjB,KAAAuF,OAAAM,SACA7F,KAAAuF,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,KAFA,2BAEAC,QAAAzF,MAKAX,KAQAgF,EAAAzD,UAAA8E,UAAA,WACA,IACAC,KAaA,OAXAtG,KAAAwF,KACAc,EAAAC,IAAAvG,KAAAwF,IAGAxF,KAAA0F,UACAY,EAAAX,SAAA3F,KAAA0F,SAGAY,EAAAE,KAAAxG,KAAAmF,QACAmB,EAAAlB,KAAApF,KAAAoF,KAEAkB,GAQAtB,EAAAzD,UAAAkF,SAAA,WACA,OAAAC,KAAAC,UAAA3G,KAAAqG,cAcArB,EAAAzD,UAAAqF,OAAA,SAAAC,EAAAC,GACA,IAAA/G,EAAAC,KAOA,GALA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,OAGA9G,EAAAyF,GACA,UAAA5C,MAAA,mEAGA5C,KAAAuF,OAAAwB,MAAA/G,KAAAsF,eAAA0B,eAAA,qBAAAhH,KAAAqG,YAAAQ,EAAAC,GAAA,SAAAxC,GACAwC,EAAAxC,SAAAtC,EAAAjC,EAAAyF,OAWAR,EAAAzD,UAAA0F,OAAA,SAAAJ,EAAAC,GAQA,GALAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,OAJA7G,KAOAwF,GACA,UAAA5C,MAAA,mFAGA5C,KAAAuF,OAAAwB,MAAA/G,KAAAsF,eAAA0B,eAAA,qBAAAhH,KAAAqG,YAAAQ,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,WAWAnC,EAAAzD,UAAA6F,QAAA,SAAAP,EAAAC,GACA,IAAA/G,EAAAC,KAOA,GALA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,OAGA9G,EAAAyF,GACA,UAAA5C,MAAA,2EAGA5C,KAAAuF,OAAA8B,iBAAA,mBAAAP,GAEA/G,EAAAwF,OAAAwB,MAAAhH,EAAAuF,eAAA0B,eAAA,mBAA4ET,IAAAxG,EAAAyF,IAAaqB,EAAA,SAAAS,EAAAJ,GACzF,IAAAK,EAEA,GAAAD,EACA,OAAAR,EAAAQ,IAGAC,EAAA,IAAAvC,EAAAjF,EAAAuF,eAAAvF,EAAAyF,GAAA0B,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,QACA/B,QAAAwB,EAAAC,OAAAxB,SAEAmB,EAAA,KAAAS,MAmBAvC,EAAAzD,UAAAmG,KAAA,SAAAb,EAAAC,GACA,IACAR,EAAAtG,KAAAqG,YACAtG,EAAAC,KAoBA,OAlBA6G,QAAA7E,IAAA8E,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAA/G,KAAAsF,eAAA0B,eAAA,8BAAAV,EAAAO,EAAA,SAAAS,EAAAJ,GACA,GAAAI,EACA,OAAAR,KAAAQ,GAGAvH,EAAAyF,GAAA0B,EAAAC,OAAAZ,IACAxG,EAAA2F,QAAAwB,EAAAC,OAAAxB,SAEAmB,GACAA,EAAA,KAAA/G,KAIAA,GAaAiF,EAAAzD,UAAAoG,QAAA,SAAAd,GACA,IAAAP,EAAAtG,KAAAqG,YAIA,OAFArG,KAAAuF,OAAAwB,MAAA/G,KAAAsF,eAAA0B,eAAA,sBAAAV,EAAAO,GAEA7G,MAUAgF,EAAAzD,UAAAqE,WAAA,SAAAU,EAAAsB,GACA,IAAA7H,EAAAC,KAWA,OATA4H,EACA5H,KAAAmF,QAAAmB,EAGAxF,OAAAiE,KAAAuB,GAAAuB,QAAA,SAAAC,GACA/H,EAAAoF,QAAA2C,GAAAxB,EAAAwB,KAIA9H,MAUAgF,EAAAzD,UAAAwG,UAAA,SAAAlB,EAAAC,GACA,IAAAkB,EASA,GAPAnB,IAAAC,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAA8B,iBAAA,qBAAAP,IAEA9G,KAAAwF,GACA,UAAA5C,MAAA,iFAKA,OAFAoF,GAAaC,KAAOC,QAAAlI,KAAAwF,MAEpBxF,KAAAsF,eAAAyC,UAAAC,EAAAnB,EAAAC,IAGAlH,EAAAD,QAAAqF,iBCnUA,SAAAmD,EAAAC,EAAA5C,EAAAL,EAAAC,GAEA,IAAAI,EACA,UAAA5C,MAAA,uCAmCA,GA/BA9B,OAAAuE,iBAAArF,MAEAuF,QACAnB,MAAAgE,EAAA7C,QAEA6C,UACAhE,MAAAgE,GAIA5C,IACApB,MAAAoB,EACAvE,YAAA,GAEAkE,SACAf,SACAqB,UAAA,EACAxE,YAAA,GAEAmE,MACAhB,MAAAgB,MACAK,UAAA,EACAxE,YAAA,KAIAkE,GACAnF,KAAA4F,WAAAT,GAAA,GAIAiD,EAAA7C,OAAAM,SACA,OAAAuC,EAAA7C,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,KAFA,mBAEAC,QAAAzF,MAaAwH,EAAA5G,UAAAqE,WAAA,SAAAU,GAEA,OADAtG,KAAAmF,QAAAmB,EACAtG,MAQAmI,EAAA5G,UAAA8E,UAAA,WACA,IACAC,KASA,OAPAtG,KAAAwF,KACAc,EAAAC,IAAAvG,KAAAwF,IAGAc,EAAAE,KAAAxG,KAAAmF,QACAmB,EAAAlB,KAAApF,KAAAoF,KAEAkB,GASA6B,EAAA5G,UAAAqF,OAAA,SAAAC,EAAAC,GAIAD,QAAA7E,IAAA8E,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAJA7G,KAOAuF,OAAAwB,MAAA/G,KAAAoI,SAAApB,eAAAhH,KAAAqI,mBAA0E9B,IAAAvG,KAAAwF,IAAaqB,EAAA,SAAAS,EAAAJ,GACvF,GAAAI,EACA,QAAAR,KAAAQ,GAGAR,GACAA,EAAA,KAAAI,EAAAC,OAAAZ,QAaA4B,EAAA5G,UAAA+G,OAAA,SAAAnD,EAAA0B,EAAAC,GACA,IACAR,KACAvG,EAAAC,KAEA,oBAAAmF,EACA,UAAAvC,MAAA,wCAuBA,OApBAiE,QAAA7E,IAAA8E,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGAP,EAAAC,IAAAxG,EAAAyF,GACAc,EAAAE,KAAArB,EAEApF,EAAAwF,OAAAwB,MAAA/G,KAAAoI,SAAApB,eAAAhH,KAAAuI,kBAAAjC,EAAAO,EAAA,SAAAS,EAAAkB,GACA,GAAAlB,EACA,QAAAR,KAAAQ,GAGAvH,EAAA6F,WAAA4C,EAAArB,OAAAK,SAEAV,GACAA,EAAA,KAAA/G,KAIAC,MAGAJ,EAAAD,QAAAwI,mBCnJA,IAAAM,EAAAvI,EAAA,GACAwI,EAAAxI,EAAA,GA2BAN,EAAAD,QAzBA,SAAAkH,EAAA8B,EAAAC,GACA,IAAAxI,EAAAuI,GAAAC,GAAA,EAEA,qBACAD,EAAA,UAAA9B,EAAA,IAAApD,MAAA,SACAoD,EAAA,MAIA,IAAAgC,GAFAhC,SAEAiC,SAAAjC,EAAA4B,UAOA,GAJAI,EAAA,MAAAA,EAAA,MACAA,EAAA,MAAAA,EAAA,OAGAF,EACA,QAAAI,EAAA,EAAoBA,EAAA,KAASA,EAC7BJ,EAAAvI,EAAA2I,GAAAF,EAAAE,GAIA,OAAAJ,GAAAD,EAAAG,qBCzBA,IACAG,EAAA9I,EAAA,GAQA,SAAA+I,EAAAb,EAAA5C,EAAAL,EAAAC,GAoBA,GAnBA4D,EAAAzI,KAAAP,KAAAoI,EAAA5C,EAAAL,EAAAC,GAGAtE,OAAAuE,iBAAArF,MAEAqI,kBACAjE,MAAA,cAEAmE,kBACAnE,MAAA,cAEA8E,aACA9E,SACAqB,UAAA,EACAxE,YAAA,KAKAmH,EAAA7C,OAAAM,SACA,OAAAuC,EAAA7C,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,KAFA,4DAEAC,QAAAzF,MAMAsI,EAAA1H,UAAAT,OAAAqI,OAAAH,EAAAzH,WACA6H,aACAhF,MAAA6E,KAUAA,EAAA1H,UAAA8H,YAAA,SAAAC,GACA,IAAA7F,MAAA8F,QAAAD,IAAA,iBAAAA,EAAA,GACA,UAAA1G,MAAA,sDAKA,OAFA5C,KAAAmF,QAAAmE,aAEAtJ,MAMAiJ,EAAA1H,UAAAiI,eAAA,SAAAN,GACA,oBAAAA,EACA,UAAAtG,MAAA,4CAKA,OAFA5C,KAAAkJ,cAEAlJ,MASAiJ,EAAA1H,UAAAkI,WAAA,SAAAC,GACA,oBAAAA,EACA,UAAA9G,MAAA,0CAWA,OARA5C,KAAAmF,QAAAmE,aACAtJ,KAAAmF,QAAAmE,gBAGA,IAAAtJ,KAAAmF,QAAAmE,WAAAlD,QAAAsD,IACA1J,KAAAmF,QAAAmE,WAAAxG,KAAA4G,GAGA1J,MAUAiJ,EAAA1H,UAAA4H,OAAA,SAAAtC,EAAAC,GACA,IACAR,EAAAtG,KAAA2J,oBACA5J,EAAAC,KAEA,IAAAA,KAAAmF,QAAAmE,WACA,UAAA1G,MAAA,yGAYA,OATAiE,QAAA7E,IAAA8E,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,MAAA/G,KAAAoI,SAAApB,eAAA,cAAAV,EAAA,KAAAQ,GAAA,SAAAxC,GACAwC,EAAAxC,SAAAtC,EAAAjC,KAGAC,MAWAiJ,EAAA1H,UAAAqG,QAAA,SAAAf,EAAAC,GACA,IACAR,EAAAtG,KAAAqG,YACAtG,EAAAC,KAEA,IAAAA,KAAAmF,QAAAmE,WACA,UAAA1G,MAAA,yGAaA,OAVAiE,QAAA7E,IAAA8E,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAIA7G,KAAAuF,OAAAwB,MAAA/G,KAAAoI,SAAApB,eAAA,eAAAV,EAAA,KAAAQ,GAAA,SAAAxC,GACAwC,EAAAxC,SAAAtC,EAAAjC,KAGAC,MAcAiJ,EAAA1H,UAAAqI,eAAA,SAAA/C,EAAAC,GACA,IACAR,EAAAtG,KAAAqG,YACAtG,EAAAC,KAWA,OATA6G,QAAA7E,IAAA8E,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAA/G,KAAAoI,SAAApB,eAAA,wBAAAV,EAAAO,EAAAC,GAAA,SAAAQ,GACAR,EAAAQ,SAAAtF,EAAAjC,KAGAA,GAQAkJ,EAAA1H,UAAA8E,UAAA,WACA,OAAUE,IAAAvG,KAAAwF,GAAAgB,KAAAxG,KAAAmF,QAAAC,KAAApF,KAAAoF,OAQV6D,EAAA1H,UAAAoI,kBAAA,WACA,OAAUpD,IAAAvG,KAAAwF,GAAAgB,MAAqBrB,QAAAnF,KAAAmF,QAAA+D,YAAAlJ,KAAAkJ,YAAA9D,KAAApF,KAAAoF,QAQ/B6D,EAAA1H,UAAAsI,cAAA,WACA,OAAA7J,KAAAmF,QAAAmE,gBASAL,EAAA1H,UAAAuI,YAAA,SAAAjD,EAAAC,GACA,IACA/G,EAAAC,KACA+J,KACAC,GAAA,EASA,GAPAnD,IAAAC,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAqI,SAAA7C,OAAA8B,iBAAA,mBAAAP,IAEA/G,EAAAoF,QAAAmE,WACA,OAAAxC,EAAA,KAAAiD,GAGAhK,EAAAoF,QAAAmE,WAAAzB,QAAA,SAAA6B,GACA3J,EAAAqI,SAAA6B,aAAAP,EAAA7C,EAAA,SAAAS,EAAA4C,GACA,GAAA5C,EAAA,CACA,GAAA0C,EACA,OAIA,OADAA,GAAA,EACAlD,EAAAQ,GAGAyC,EAAAjH,KAAAoH,GAEAH,EAAAhI,SAAAhC,EAAAoF,QAAAmE,WAAAvH,QACA+E,EAAA,KAAAiD,QAMAnK,EAAAD,QAAAsJ,qeC5PA,IACEkB,EAASjK,EAAQ,GACjBgC,EAAqBhC,EAAQ,GAEzBkK,cAEJ,SAAAA,EAAaC,EAAMxD,gGAAS5E,CAAAjC,KAAAoK,GAAA,IAAAE,mKAAAC,CAAAvK,MAAAoK,EAAAI,WAAA1J,OAAA2J,eAAAL,IAAA7J,KAAAP,OAAA,OAG1Bc,OAAOuE,iBAAPiF,GACE9E,IACEpB,MAAO+F,KAETE,MACEjG,MAAOiG,EACPpJ,YAAY,GAEdyJ,MACEtG,MAAQyC,GAAmC,iBAAjBA,EAAQ6D,KAAqB7D,EAAQ6D,KAAO,KACtEzJ,YAAY,GAEd0J,KACEvG,SAAQyC,GAA4C,kBAA1BA,EAAQ+D,gBAA+B/D,EAAQ+D,cACzE3J,YAAY,GAEd4J,SACEzG,OAAO,EACPqB,UAAU,GAEZqF,mBACE1G,MAAQyC,GAAgD,iBAA9BA,EAAQiE,kBAAkCjE,EAAQiE,kBAAoB,IAChG7J,YAAY,GAGd8J,eACE3G,OAAQyC,GAA4C,kBAA1BA,EAAQkE,eAA+BlE,EAAQkE,cACzE9J,YAAY,GAEd+J,WACE5G,OAAO,EACPnD,YAAY,EACZwE,UAAU,GAEZwF,YACE7G,OAAO,EACPnD,YAAY,EACZwE,UAAU,GAEZyF,OACE9G,MAAO,UACPnD,YAAY,EACZwE,UAAU,GAYZ0F,cACE/G,SACAnD,YAAY,EACZwE,UAAU,GAEZ2F,aACEhH,MAAO,KACPnD,YAAY,EACZwE,UAAU,GAEZ4F,cACEjH,MAAO,IACPnD,YAAY,EACZwE,UAAU,GAEZ6F,UACElH,MAAO,KACPnD,YAAY,EACZwE,UAAU,GAEZ8F,gBACEnH,MAAO,GACPnD,YAAY,EACZwE,UAAU,GAEZ+F,oBACEpH,MAAO,KACPnD,YAAY,EACZwE,UAAU,KAIVoB,IACF/F,OAAOiE,KAAK8B,GAASgB,QAAQ,SAAA4D,GACvBnB,EAAK9I,eAAeiK,IAAQ3K,OAAO4K,yBAAPpB,EAAsCmB,GAAKhG,WACzE6E,EAAKmB,GAAO5E,EAAQ4E,MAII,SAAxB5E,EAAQ8E,aAA0BrB,EAAKS,gBACzCT,EAAKU,UAAYV,EAAKW,YAAa,IAIvCX,EAAKsB,cAAe,EACpBtB,EAAKuB,uBAAwB,EAC7BvB,EAAKwB,UAAW,EAvGUxB,qUAFNpI,wCA6GpBlC,KAAKkL,MAAQ,aACTlL,KAAKgL,WACPhL,KAAK+L,yDAQP/L,KAAKkL,MAAQ,YACblL,KAAKgM,KAAKhM,KAAK4L,aAAgB,YAAe,WAC9C5L,KAAK4L,cAAe,EACpB5L,KAAK6L,uBAAwB,EAEzB7L,KAAKgL,WACPhL,KAAKiM,cAGHjM,KAAKiL,YACPjL,KAAKkM,yDAQPlM,KAAKkL,MAAQ,UACTlL,KAAKgL,WACPhL,KAAK+L,eAGP/L,KAAKgM,KAAK,yDAQO1E,GAAO,IAAA6E,EAAAnM,KACxBA,KAAKkL,MAAQ,UACTlL,KAAKgL,WACPhL,KAAK+L,eAGP/L,KAAKgM,KAAK,eAAgB1E,IACtBtH,KAAK+K,eAAkB/K,KAAK8L,UAAa9L,KAAK6L,sBAOhD7L,KAAKgM,KAAK,eANVhM,KAAK8L,UAAW,EAChBM,WAAW,WACTD,EAAKL,UAAW,EAChBK,EAAKE,QAAQF,EAAK9B,OACjBrK,KAAK8K,yDAUV9K,KAAKmL,oDAOc,cAAfnL,KAAKkL,QACPoB,EAAWtM,MA0IjB,SAAkBuM,GAChB,IACEC,KAYF,GAAID,EAAQf,mBAAoB,CAC9B,GAA0C,mBAA/Be,EAAQf,mBACjB,MAAM,IAAI5I,MAAM,2EAAAD,EAAoF4J,EAAQf,qBAG9G,IAAMiB,EAAkBF,EAAQf,qBAChC,IAAI/H,MAAM8F,QAAQkD,GAYhB,MAAM,IAAI7J,MAAM,8FAA6F6J,EAA7F,YAAA9J,EAA6F8J,KAX7GF,EAAQpB,aAAesB,EACpBzJ,OAAOuJ,EAAQpB,cACfnF,OAAO,SAAA0G,GAEN,IAAKA,EAAQ3F,YAAqC/E,IAA5B0K,EAAQ3F,MAAM4F,YAA4BD,EAAQ3F,MAAM6F,SAAWF,EAAQ3F,MAAM8F,WACrG,MAAM,IAAIjK,MAAM,iGAGlB,OAAO4J,EAAYhL,eAAekL,EAAQ3F,MAAM4F,aAAsBH,EAAYE,EAAQ3F,MAAM4F,YAAa,MA1BhG,SAAnBG,IACMP,EAAQpB,aAAapJ,OAAS,IAChCgL,EAAYR,EAASA,EAAQpB,aAAa,GAAGpE,MAAOwF,EAAQpB,aAAa,GAAGrE,IAC5EyF,EAAQP,KAAK,kBAAmBO,EAAQpB,aAAa6B,SAErDZ,WAAW,WACTU,KACCG,KAAKC,IAAI,EAAGX,EAAQhB,kBA0B7BuB,GA7KIK,CAAQnN,8CAQVA,KAAK6K,SAAU,wCAOf7K,KAAK6K,SAAU,oCAGPxJ,EAAQwF,EAASuG,EAAgBtG,GAAI,IAAAuG,EAAArN,KAC7C,GAAmB,cAAfA,KAAKkL,MACP,OAAOpE,EAAG,IAAIlE,MAAM,kBAEtB5C,KAAK+G,MAAM1F,EAAQwF,EAAS,SAACS,EAAOkB,GAClC,GAAIlB,EACF,OAAOR,EAAGQ,GAEZ+F,EAAKC,GAAG9E,EAASrB,OAAOoG,QAAS,SAAAjH,GAC/BA,EAAKkH,cAA6BxL,IAAlBsE,EAAKmH,UAA0BnH,EAAKmH,SAASC,gBAAkBL,EAAK7H,GACpF4H,EAAe9G,KAEjBQ,EAAG,KAAM0B,EAASrB,8CAIV9F,EAAQkM,EAASzG,GAC3B9G,KAAK2N,mBAAmBJ,GACxBvN,KAAK+G,MAAM1F,EAAQ,KAAM,SAACiD,EAAK4C,GACzBJ,GACFA,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,wCAK9B9F,EAAQwF,EAASC,GACrB,IAAI8G,EAAW/G,IAAiC,IAArBA,EAAQ+G,WAAuB,EAM1D,OAJI5N,KAAKoL,cACPwC,EAAWA,GAAY5N,KAAKoL,YAAY/J,IAGtCrB,KAAK6K,SAAW+C,GAClBtB,EAAWtM,MACXA,KAAKgM,KAAK,oBAAqBjF,MAAO1F,EAAQyF,GAAIA,IAC3C9G,KAAKmL,aAAarI,MAAM+K,GAAIC,KAAKC,MAAOhH,MAAO1F,EAAQyF,GAAIA,KAGjD,cAAf9G,KAAKkL,MACA6B,EAAY/M,KAAMqB,EAAQyF,GAsCvC,SAAwBzF,EAAQyF,GAC1BA,GACFA,EAAG,IAAIlE,MAAM,oFAAsF8D,KAAKC,UAAUtF,KArC3G2M,CAAe3M,EAAQyF,YAUlC,SAASiG,EAAaR,EAASG,EAAS5F,SAClB9E,IAAhB0K,EAAQuB,KAAqBnH,IAC/ByF,EAAQ1K,KAAK6K,EAAQC,UAAW,SAAAnE,GAC9B,IAAIlB,EAAQ,KAEW,WAAnBoF,EAAQE,QAAuBpE,EAASlB,OAAoC,kBAA3BkB,EAASlB,MAAM4G,SAClE3B,EAAQP,KAAK,eAAgBU,EAAS5F,GAGpC0B,EAASlB,QACXA,EAAQ,IAAI1E,MAAM4F,EAASlB,MAAM4G,SACjCpN,OAAOqN,OAAO7G,EAAOkB,EAASlB,OAC9BA,EAAM8G,OAAS5F,EAAS4F,OACxB7B,EAAQP,KAAK,aAAc1E,EAAOoF,EAAS5F,IAGzCA,GACFA,EAAGQ,EAAOkB,KAKhB+D,EAAQ8B,KAAK3B,GAaf,SAASJ,EAAYC,GACnB,IAAMwB,EAAMD,KAAKC,MACbO,GAAqB,EAErB/B,EAAQjB,SAAW,IACrBiB,EAAQpB,aAAatD,QAAQ,SAACd,EAAO5D,GAC/B4D,EAAM8G,GAAKE,EAAMxB,EAAQjB,WAC3BgD,EAAoBnL,MAIG,IAAvBmL,GACF/B,EAAQpB,aACL9H,OAAO,EAAGiL,EAAoB,GAC9BzG,QAAQ,SAAA0G,GACPhC,EAAQP,KAAK,kBAAmBuC,EAAexH,UAKnDwF,EAAQlB,aAAe,GAAKkB,EAAQpB,aAAapJ,OAASwK,EAAQlB,cACpEkB,EAAQpB,aACL9H,OAAO,EAAGkJ,EAAQpB,aAAapJ,OAASwK,EAAQlB,cAChDxD,QAAQ,SAAA0G,GACPhC,EAAQP,KAAK,kBAAmBuC,EAAexH,SA+CvDnH,EAAOD,QAAUyK,o4BC3WjB,IACED,EAASjK,EAAQ,GACjBgC,EAAqBhC,EAAQ,GAC7BsO,EAAatO,EAAQ,GACrB8E,EAAW9E,EAAQ,GACnBkI,EAAWlI,EAAQ,IACnBuO,EAAgBvO,EAAQ,IACxB+I,EAAO/I,EAAQ,GACfwO,EAAiBxO,EAAQ,IAkBrByO,cACJ,SAAAA,EAAYtE,EAAMxD,gGAAS5E,CAAAjC,KAAA2O,GAAA,IA6QNC,EA7QMtE,EAAAC,EAAAvK,MAAA2O,EAAAnE,WAAA1J,OAAA2J,eAAAkE,IAAApO,KAAAP,OAGzB,IAAKqK,GAAiB,KAATA,EACX,MAAM,IAAIzH,MAAM,yBAgDlB,GA7CA9B,OAAOuE,iBAAPiF,GAEEuE,cACEzK,OACE,YACA,YACA,eACA,eACA,eACA,mBACA,kBACA,aACA,cACA,iBAIJ0K,iBACE1K,OAAOyC,GAA8C,kBAA5BA,EAAQiI,iBAAgCjI,EAAQiI,gBACzE7N,YAAY,GAEd8N,cACE3K,MAAQyC,GAA2C,iBAAzBA,EAAQkI,aAA6BlI,EAAQkI,kBAAe/M,EACtFyD,UAAU,EACVxE,YAAY,GAEdgN,KACE7J,WAAOpC,EACPf,YAAY,EACZwE,UAAU,GAEZuJ,UACE5K,MAAQyC,GAAuC,iBAArBA,EAAQmI,SAAyBnI,EAAQmI,SAAW,YAC9E/N,YAAY,GAEdgO,YACE7K,MAAkF,UAEpFqJ,UACErJ,SACAnD,YAAY,EACZwE,UAAU,KAIVoB,EAAS,KAAAlD,GAAA,EAAAC,GAAA,EAAAC,OAAA7B,EAAA,IACX,QAAA8B,EAAAC,EAAkBjD,OAAOiE,KAAK8B,GAA9B7C,OAAAC,cAAAN,GAAAG,EAAAC,EAAAG,QAAAC,MAAAR,GAAA,EAAwC,KAA7B8H,EAA6B3H,EAAAM,MAClCkG,EAAK9I,eAAeiK,IAAQ3K,OAAO4K,yBAAPpB,EAAsCmB,GAAKhG,WACzE6E,EAAKmB,GAAO5E,EAAQ4E,KAHb,MAAAnH,GAAAV,GAAA,EAAAC,EAAAS,EAAA,aAAAX,GAAAI,EAAAQ,QAAAR,EAAAQ,SAAA,WAAAX,EAAA,MAAAC,IAyNb,OAhNA/C,OAAOC,eAAPuJ,EAA4B,aAC1BlG,MAAO,SAAS8K,EAAMC,EAAMC,GAAa,IAAAjD,EAAAnM,KAErCqB,GACEsL,UAAWxC,IACX0C,WAAY,WACZD,OAAQ,YACRzJ,MAAO+L,EAAKjK,WAAW9B,MACvB8B,WAAYiK,EAAKjK,WAAWA,WAC5BwI,SAAUzN,KAAKyN,SACfjH,KAAM0I,EAAKlH,QACXqH,MAAOH,EAAKG,MACZnE,MAAOgE,EAAKhE,MACZoE,MAAOJ,EAAKI,YAkBCtN,IAAbhC,KAAKiO,MACP5M,EAAO4M,IAAMjO,KAAKiO,KAGpBnN,OAAOqN,OAAO9M,EAAOoM,SAAUyB,EAAKzB,UAAWC,cAAe1N,KAAKuM,QAAQ/G,GAAIyJ,WAAYjP,KAAKiP,aAEhGjP,KAAKuM,QAAQxE,UAAU1G,EAAQ8N,EAtBZ,SAAA7I,GACf,GAAkB,iBAAdA,EAAKiJ,KAEP,OADApD,EAAKqD,WACErD,EAAKH,KAAK,gBAGnB,GAAkB,aAAd1F,EAAKiJ,KAAqB,CAC5B,IAAME,EAAO3O,OAAOqN,UAAW7H,GAG/B,OAFAmJ,EAAKC,SAAW,IAAI1K,EAASkK,EAAKjK,WAAYqB,EAAKa,OAAOZ,IAAKD,EAAKa,OAAOK,QAASlB,EAAKa,OAAOM,cACzFgI,EAAKtI,OACL+H,EAAKS,OAAOF,GAGrBP,EAAKS,OAAOrJ,IASqC8I,MAKzDtO,OAAOC,eAAPuJ,EAA4B,eAC1BlG,MAAO,SAAC8K,EAAMU,GACZ,IACEvO,GACEsL,UAAWxC,IACX0C,WAAY,WACZD,OAAQ,cACRa,SAAUnD,EAAKmD,SACfjH,MAAOqJ,OAAQX,EAAKW,cAGP7N,IAAbsI,EAAK2D,MACP5M,EAAO4M,IAAM3D,EAAK2D,KAGpBnN,OAAOqN,OAAO9M,EAAOoM,SAAUyB,EAAKzB,UAAWC,cAAepD,EAAKiC,QAAQ/G,GAAIyJ,WAAY3E,EAAK2E,aAEhG3E,EAAKiC,QAAQuD,YAAYzO,EAAQ6N,EAAK3B,QAASqC,MAQnD9O,OAAOC,eAAPuJ,EAA4B,oBAC1BlG,MAAO,SAAC2L,EAAoBC,GAC1B,IAAKA,GAAgC,mBAAbA,EACtB,MAAM,IAAIpN,MAASmN,EAAb,yDAQZjP,OAAOC,eAAPuJ,EAA4B,YAC1BlG,MAAO,IAAIgE,EAAJkC,GACPrJ,YAAY,IAGdH,OAAOC,eAAPuJ,EAA4B,iBAC1BlG,MAAO,IAAIqK,EAAJnE,GACPrJ,YAAY,IAGdH,OAAOC,eAAPuJ,EAA4B,eAC1BlG,SACAqB,UAAU,IAGZ3E,OAAOC,eAAPuJ,EAA4B,gBAC1BlG,MAAOyC,GAA2C,iBAAzBA,EAAQoJ,aAA4BpJ,EAAQoJ,aAAe,MAGtFnP,OAAOC,eAAPuJ,EAA4B,mBAC1BlG,OACE8L,WAAYC,QAAS7F,EAAK2F,cAC1B3I,OAAQ6I,QAAS7F,EAAK2F,cACtBG,cAAeD,QAAS7F,EAAK2F,cAC7BI,aAAcF,QAAS7F,EAAK2F,cAC5BK,cAAeH,QAAS7F,EAAK2F,cAC7BM,cAAeJ,QAAS7F,EAAK2F,iBAIjC3F,EAAKiC,QAAUmC,EAAepE,EAAK0E,SAAU3E,EAAMxD,GAMnD/F,OAAOuE,iBAAPiF,GACEU,WACE/J,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQvB,WACxBwF,IAAK,SAAApM,GACHqM,EAAkB,YAAa,UAAWrM,GAC1CkG,EAAKiC,QAAQvB,UAAY5G,IAG7B2G,eACE9J,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQxB,gBAE1BE,YACEhK,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQtB,YACxBuF,IAAK,SAAApM,GACHqM,EAAkB,aAAc,UAAWrM,GAC3CkG,EAAKiC,QAAQtB,WAAa7G,IAG9BiG,MACEpJ,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQlC,OAE1Bc,cACElK,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQpB,eAE1BK,oBACEvK,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQf,oBACxBgF,IAAK,SAAApM,GACW,OAAVA,GACFqM,EAAkB,qBAAsB,WAAYrM,GAEtDkG,EAAKiC,QAAQf,mBAAqBpH,IAGtCsG,MACEzJ,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQ7B,OAE1BU,aACEnK,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQnB,aACxBoF,IAAK,SAAApM,GACHqM,EAAkB,cAAe,WAAYrM,GAC7CkG,EAAKiC,QAAQnB,YAAchH,IAG/BiH,cACEpK,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQlB,cACxBmF,IAAK,SAAApM,GACHqM,EAAkB,eAAgB,SAAUrM,GAC5CkG,EAAKiC,QAAQlB,aAAejH,IAGhCkH,UACErK,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQjB,UACxBkF,IAAK,SAAApM,GACHqM,EAAkB,WAAY,SAAUrM,GACxCkG,EAAKiC,QAAQjB,SAAWlH,IAG5BmH,gBACEtK,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQhB,gBACxBiF,IAAK,SAAApM,GACHqM,EAAkB,iBAAkB,SAAUrM,GAC9CkG,EAAKiC,QAAQhB,eAAiBnH,IAGlC0G,mBACE7J,YAAY,EACZC,IAAK,kBAAMoJ,EAAKiC,QAAQzB,oBAE1BF,eACE8F,WAAW,EACXxP,IAAK,kBAAMoJ,EAAKiC,QAAQ5B,QAI5BL,EAAKiC,QAAQxJ,YAAY,mBAAoB,SAAAuD,GAAA,OAAQgE,EAAK0B,KAAK,mBAAoB1F,KACnFgE,EAAKiC,QAAQxJ,YAAY,kBAAmB,SAAAuD,GAAA,OAAQgE,EAAK0B,KAAK,kBAAmB1F,KACjFgE,EAAKiC,QAAQxJ,YAAY,aAAc,SAACuB,EAAKyC,GAAN,OAAgBuD,EAAK0B,KAAK,aAAc1H,EAAKyC,KAEpFuD,EAAKiC,QAAQxJ,YAAY,eAAgB,WACvCuH,EAAKkF,WACLlF,EAAK0B,KAAK,kBAGR1B,EAAKzE,UACP+I,EAAOtE,EAAKzE,SAASC,aAAdwE,GACLvE,OAAQ,UACRC,OAAQ,SAAUrF,EAAMsF,EAAMC,EAAQC,GAQpC,OAAOA,IAAuC,KAP3B,mBAAoB,gBAAiB,gBACtD,kBAAmB,cAAe,QAAS,SAAU,MAAO,QAC5D,aAAc,SAAU,aAAc,cAAe,mBACrD,sBAAuB,sBAAuB,sBAAuB,wBACrE,cAAe,eAAgB,iBAAkB,iBAAkB,WAG1CC,QAAQzF,MAVvC4J,EAAAD,EAAAsE,IA9QuBtE,qUADRpI,mCAmSbM,GAAuB,IAAAmO,EAEzB5C,EAAMD,KAAKC,MACX6C,EAAiB5Q,KAAK6Q,gBAAgBrO,GAExC,GAAIoO,EAAgB,CAClB,GAAIA,EAAeE,aAAeF,EAAeE,YAAc/C,EAAM6C,EAAeT,QAClF,OAAO,EAETS,EAAeE,YAAc/C,EATJ,QAAAxK,EAAAzB,UAAAC,OAATyB,EAASC,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAATF,EAASE,EAAA,GAAA5B,UAAA4B,IAY3BiN,EAAAI,EAAApC,EAAApN,UAAAiJ,WAAA1J,OAAA2J,eAAAkE,EAAApN,WAAA,OAAAvB,OAAAO,KAAA8D,MAAAsM,GAAA3Q,KAAWwC,GAAXQ,OAAyBQ,oCAQlBsD,GAAI,IAAAuG,EAAArN,KACgB,YAAvBA,KAAKuM,QAAQrB,OAOjBlL,KAAKuM,QAAQF,UAEbrM,KAAKuM,QAAQxJ,YAAY,UAAW,WAClCsK,EAAKrB,KAAK,aAENlF,GACFA,EAAG,KAAHuG,KAIJrN,KAAKuM,QAAQxJ,YAAY,eAAgB,SAAAuE,GACvC,IAAM0J,EAAkB,IAAIpO,MAAJ,+CAAyDyK,EAAKd,QAAQlC,KAAtE,IAA8EgD,EAAKd,QAAQ7B,MAEnHsG,EAAgBC,SAAW3J,EAC3B+F,EAAKrB,KAAK,eAAgBgF,GAEtBlK,GACFA,EAAGkK,KAIPhR,KAAKuM,QAAQxJ,YAAY,aAAc,WACrCsK,EAAK6D,aACL7D,EAAKrB,KAAK,kBAGZhM,KAAKuM,QAAQxJ,YAAY,YAAa,WAChCsK,EAAKY,IACPZ,EAAK8D,WAAW9D,EAAKY,IAAK,SAAC3J,EAAK4C,IAE1B5C,GAAQ4C,EAAIkK,OACd/D,EAAKmC,WAGPnC,EAAKrB,KAAK,iBAGZqB,EAAKrB,KAAK,iBAIdhM,KAAKuM,QAAQe,GAAG,YAAa,SAAAhH,GAAA,OAAQ+G,EAAKrB,KAAK,YAAa1F,MA/CtDQ,GACFA,EAAG,KAAM9G,qCAsDPqR,GACN,GAAqB,iBAAVA,EACTrR,KAAKiO,IAAMoD,MACN,IAAqB,iBAAjB,IAAOA,EAAP,YAAA1O,EAAO0O,IAahB,OADArR,KAAKgM,KAAK,gBAAiBsF,SAAS,EAAOhK,MAAO,2BAA6B+J,IACxErR,KAZP,IAAIqR,EAAMlK,SAAUkK,EAAMlK,OAAO8G,KAAmC,iBAArBoD,EAAMlK,OAAO8G,IAQ1D,OALAjO,KAAKgM,KAAK,gBACRsF,SAAS,EACThK,MAAO,oDAAsDZ,KAAKC,UAAU0K,KAGvErR,KAPPA,KAAKiO,IAAMoD,EAAMlK,OAAO8G,IAe5B,OADAjO,KAAKgM,KAAK,gBAAiBsF,SAAS,IAC7BtR,wCASP,OADAA,KAAKiO,SAAMjM,EACJhC,sCAQP,OAAOA,KAAKiO,kCAYPsD,GAAmB,IAAAC,EAAAxR,KACxB,IAAKuR,GAAgC,iBAAbA,EACtB,MAAM,IAAI3O,MAAM,mCAGlB,IACE8J,GACE6E,WACA/K,SAGAM,EAAK,MAGThF,UAAAC,QAAA,OAAAC,EAAAF,UAAA,MACyB,WAAnBa,EAAAb,UAAAC,QAAA,OAAAC,EAAAF,UAAA,IACF4K,EAAQlG,KAAR1E,UAAAC,QAAA,OAAAC,EAAAF,UAAA,GAC4B,iBAAnBA,UAAAC,QAAA,OAAAC,EAAAF,UAAA,KAAkD,iBAAnBA,UAAAC,QAAA,OAAAC,EAAAF,UAAA,IACxC4K,EAAQ+E,UAAR3P,UAAAC,QAAA,OAAAC,EAAAF,UAAA,GAC4B,mBAAnBA,UAAAC,QAAA,OAAAC,EAAAF,UAAA,MACTgF,6CAGJhF,UAAAC,QAAA,OAAAC,EAAAF,UAAA,MACyB,iBAAnBA,UAAAC,QAAA,OAAAC,EAAAF,UAAA,KAAkD,iBAAnBA,UAAAC,QAAA,OAAAC,EAAAF,UAAA,IACjC4K,EAAQ+E,UAAR3P,UAAAC,QAAA,OAAAC,EAAAF,UAAA,GAC4B,mBAAnBA,UAAAC,QAAA,OAAAC,EAAAF,UAAA,MACTgF,6CAGAhF,UAAAC,QAAA,OAAAC,EAAAF,UAAA,KAA8B,mBAAnBA,UAAAC,QAAA,OAAAC,EAAAF,UAAA,MACbgF,2CAGF9G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,SAAUF,GAAUkB,UAAU,GAAQ,SAACtG,EAAOkB,GAC/ElB,GAQHR,GAAMA,EAAGQ,GACTkK,EAAKxF,KAAK,gBAAiBsF,SAAS,EAAOhK,MAAOA,EAAM4G,YARpD1F,EAASrB,OAAO8G,KAClBuD,EAAKE,OAAOlJ,EAASrB,OAAO8G,KAG9BnH,GAAMA,EAAG,KAAM0B,EAASrB,uDAkBToK,EAAUrI,EAAarC,EAASC,GAYnD,OAXKA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,wBAAyB2E,WAAU/K,KAAM0C,GAAcrC,EAAS,SAACvC,EAAK4C,GAC1F,mBAAPJ,GACTA,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,OAAOK,WAIlCxH,iDAWYuR,EAAU1K,EAASC,GAYtC,OAXKA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,wBAAyB2E,YAAW1K,EAAS,SAACvC,EAAK4C,GACvE,mBAAPJ,GACTA,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,UAI3BnH,8CAUSuR,EAAU1K,EAASC,GAC9BA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,qBAAsB2E,YAAW1K,EAAS,SAACvC,EAAK4C,GACpE,mBAAPJ,GACTA,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,sDAcfoK,EAAUrI,EAAarC,EAASC,GAYnD,OAXKA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,wBAAyB2E,WAAU/K,KAAM0C,GAAcrC,EAAS,SAACvC,EAAK4C,GAC1F,mBAAPJ,GACTA,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,UAI3BnH,mDAWcuR,EAAUrI,EAAarC,EAASC,GAChDA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,0BAA2B2E,WAAU/K,KAAM0C,GAAcrC,EAAS,SAACvC,EAAK4C,GAC5F,mBAAPJ,GACTA,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,8CAavBhE,EAAO0D,EAASC,GAC3B,IAAK3D,EAAO,CACV,IAAKnD,KAAK+O,aACR,MAAM,IAAInM,MAAM,sCAElBO,EAAQnD,KAAK+O,aAcf,OAXKjI,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAK+G,OAAO8F,WAAY,QAASD,OAAQ,SAAUzJ,YAAY0D,EAAS,SAACvC,EAAK4C,GAC1D,mBAAPJ,GACTA,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,UAI3BnH,oCASD8G,GAAI,IAAA6K,EAAA3R,KAER0M,GACEE,OAAQ,SACRC,WAAY,OACZF,UAAWxC,IACX3D,SASJ,OANAxG,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,UAAWF,GAAUkB,UAAU,GAAQ,SAAAtG,GAC3D,mBAAPR,GACTA,EAAGQ,EAAHqK,KAIG3R,KAAKwP,8CAUF6B,EAAOvK,GACjB,IACE4F,GACElG,MACE6K,UAINrR,KAAKqH,iBAAiB,oBAAqBP,GAE3C9G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,cAAeF,GAAUkB,UAAU,GAAQ,SAACtJ,EAAK4C,GACvFJ,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,yCAU1BL,GAAI,IAAA8K,EAAA5R,KACVA,KAAKqH,iBAAiB,gBAAiBP,GAEvC9G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,wBAA2B,SAACtI,EAAK4C,GACvEJ,EAAGxC,EAAKA,OAAMtC,EAAY,IAAIiH,EAAK2I,EAAKC,SAAU3K,EAAIC,OAAOZ,IAAKW,EAAIC,OAAOK,QAASN,EAAIC,OAAOM,8CAUxFZ,EAASC,GACfA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAKqH,iBAAiB,qBAAsBP,GAE5C9G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAO,kBAAoB/F,EAAS,SAACvC,EAAK4C,GACxEJ,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,OAAO2K,2CAY7B3M,EAAS0B,EAASC,GAY5B,OAXKA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAK+G,OAAO8F,WAAY,OAAQD,OAAQ,eAAgBpG,KAAMrB,GAAU0B,EAAS,SAACvC,EAAK4C,GACnE,mBAAPJ,GACTA,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,UAI3BnH,yCAUI+R,EAAOxP,GAClB,IAA0C,IAAtCvC,KAAK6O,aAAazI,QAAQ2L,GAC5B,MAAM,IAAInP,MAAJ,IAAcmP,EAAd,yCAA4D/R,KAAK6O,aAAapI,YAGtF,OAAAsK,EAAApC,EAAApN,UAAAiJ,WAAA1J,OAAA2J,eAAAkE,EAAApN,WAAA,cAAAvB,MAAAO,KAAAP,KAAyB+R,EAAOxP,4CAUhBsE,EAASC,GACpBA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAKqH,iBAAiB,0BAA2BP,GAEjD9G,KAAK+G,OAAO8F,WAAW,SAAUD,OAAQ,kBAAoB/F,EAAS,SAACvC,EAAK4C,GAC1EJ,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,OAAO2K,gDAajB,IACtB,IACEE,SACAC,SACApL,SACAC,SALoBoL,EAAApQ,UAAAC,OAANoQ,EAAM1O,MAAAyO,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAND,EAAMC,GAAAtQ,UAAAsQ,GAOtB,OAAQD,EAAKpQ,QACX,KAAK,EACH+E,EAAKqL,EAAK,GACVH,EAAY,KACZC,EAAW,KACXpL,EAAU,KACV,MACF,KAAK,EACoB,WAAnBlE,EAAOwP,EAAK,KACbtL,EAAesL,EADe,GACrBrL,EAAMqL,EADe,KAG9BH,EAAiBG,EADb,GACOrL,EAAMqL,EADb,IAGP,MACF,KAAK,EACoB,WAAnBxP,EAAOwP,EAAK,KACbH,EAA0BG,EADI,GACnBtL,EAAesL,EADI,GACVrL,EAAMqL,EADI,KAG9BH,EAA2BG,EADvB,GACOF,EAAgBE,EADvB,GACiBrL,EAAMqL,EADvB,IAGP,MACF,KAAK,EACFH,EAAoCG,EADvC,GACcF,EAAyBE,EADvC,GACwBtL,EAAesL,EADvC,GACiCrL,EAAMqL,EADvC,GAEE,MACF,QACE,MAAM,IAAIvP,MAAM,iGAGpB5C,KAAKqH,iBAAiB,uBAAwBP,GAE9C,IAQIC,KACAiL,IACFjL,EAAQkL,GAAYD,YAAWC,aAAaD,cAG9ChS,KAAK+G,OAAO8F,WAAY,SAAUD,OAAQoF,EAAY,WAAa,gBAAiBjL,EAAOF,EAb3E,SAACvC,EAAK4C,GACpB,GAAI5C,EACF,OAAOwC,EAAGxC,GAGZwC,EAAG,KAAMkL,EAAY9K,EAAIC,OAAO2K,MAAQ5K,EAAIC,8CAmBpClC,EAAY9B,GACtB,IAAKA,EAAO,CACV,IAAKnD,KAAK+O,aACR,MAAM,IAAInM,MAAM,qEAGlBO,EAAQnD,KAAK+O,aAGf,GAAqB,iBAAV5L,GAA4C,iBAAf8B,EACtC,MAAM,IAAIrC,MAAM,yDAWlB,OARK5C,KAAKqS,YAAYlP,KACpBnD,KAAKqS,YAAYlP,OAGdnD,KAAKqS,YAAYlP,GAAO8B,KAC3BjF,KAAKqS,YAAYlP,GAAO8B,GAAc,IAAIuJ,EAAWxO,KAAMiF,EAAY9B,IAGlEnD,KAAKqS,YAAYlP,GAAO8B,wCAU/B,OADAjF,KAAKuM,QAAQ+F,aACNtS,+CAUiB,IACxB,IACEmD,SACA0D,SACAC,SAJsByL,EAAAzQ,UAAAC,OAANoQ,EAAM1O,MAAA8O,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANL,EAAMK,GAAA1Q,UAAA0Q,GAAA,IAAAhO,GAAA,EAAAC,GAAA,EAAAC,OAAA1C,EAAA,IAMxB,QAAA2C,EAAAC,EAAkBuN,EAAlBnO,OAAAC,cAAAO,GAAAG,EAAAC,EAAAV,QAAAC,MAAAK,GAAA,EAAwB,KAAbiO,EAAa9N,EAAAP,MACtB,gBAAeqO,EAAf,YAAA9P,EAAe8P,IACb,IAAK,SACHtP,EAAQsP,EACR,MACF,IAAK,SACH5L,EAAU4L,EACV,MACF,IAAK,WACH3L,EAAK2L,IAfa,MAAAnO,GAAAG,GAAA,EAAAC,EAAAJ,EAAA,aAAAE,GAAAI,EAAAL,QAAAK,EAAAL,SAAA,WAAAE,EAAA,MAAAC,GAoBxB,IAAKvB,EAAO,CACV,IAAKnD,KAAK+O,aACR,MAAM,IAAInM,MAAM,0CAGlBO,EAAQnD,KAAK+O,aAGf/O,KAAKqH,iBAAiB,yBAA0BP,GAEhD,IAAMC,GAASwI,KAAM1I,GAAWA,EAAQ0I,MAAQ,OAEhDvP,KAAK+G,OAAO5D,QAAO0J,WAAY,aAAcD,OAAQ,QAAS7F,EAAOF,EAAS,SAACvC,EAAK4C,GAClFJ,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,OAAOkL,mDAU5BxL,EAASC,GACfA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAKqH,iBAAiB,qBAAsBP,GAE5C9G,KAAK+G,OAAO8F,WAAY,QAASD,OAAQ,WAAa/F,EAAS,SAACvC,EAAK4C,GACnEJ,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,OAAOuL,gDAQvC1S,KAAKuM,QAAQoG,QADD,IAAAC,GAAA,EAAAC,GAAA,EAAAC,OAAA9Q,EAAA,IAGZ,QAAA+Q,EAAAC,EAAyBlS,OAAOiE,KAAK/E,KAAKqS,aAA1CrO,OAAAC,cAAA2O,GAAAG,EAAAC,EAAA9O,QAAAC,MAAAyO,GAAA,EAAwD,KAA7C3N,EAA6C8N,EAAA3O,aAC/CpE,KAAKqS,YAAYpN,IAJd,MAAAX,GAAAuO,GAAA,EAAAC,EAAAxO,EAAA,aAAAsO,GAAAI,EAAAzO,QAAAyO,EAAAzO,SAAA,WAAAsO,EAAA,MAAAC,0CAcCjM,EAASC,GACjBA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAKqH,iBAAiB,uBAAwBP,GAE9C9G,KAAK+G,OAAO8F,WAAY,SAAUD,OAAQ,WAAa/F,EAAS,SAACvC,EAAK4C,GACpEJ,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,OAAO8L,qDAYlB,IACrB,IACE9P,SACA0D,SACAC,SAJmBoM,EAAApR,UAAAC,OAANoQ,EAAM1O,MAAAyP,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANhB,EAAMgB,GAAArR,UAAAqR,GAAA,IAAAC,GAAA,EAAAC,GAAA,EAAAC,OAAAtR,EAAA,IAMrB,QAAAuR,EAAAC,EAAkBrB,EAAlBnO,OAAAC,cAAAmP,GAAAG,EAAAC,EAAAtP,QAAAC,MAAAiP,GAAA,EAAwB,KAAbX,EAAac,EAAAnP,MACtB,gBAAeqO,EAAf,YAAA9P,EAAe8P,IACb,IAAK,SACHtP,EAAQsP,EACR,MACF,IAAK,SACH5L,EAAU4L,EACV,MACF,IAAK,WACH3L,EAAK2L,IAfU,MAAAnO,GAAA+O,GAAA,EAAAC,EAAAhP,EAAA,aAAA8O,GAAAI,EAAAjP,QAAAiP,EAAAjP,SAAA,WAAA8O,EAAA,MAAAC,GAoBrB,IAAKnQ,EAAO,CACV,IAAKnD,KAAK+O,aACR,MAAM,IAAInM,MAAM,uCAElBO,EAAQnD,KAAK+O,aAKf,OAFA/O,KAAK+G,OAAO5D,QAAO0J,WAAY,QAASD,OAAQ,cAAgB/F,EAASC,GAElE9G,8CAUgB,IACvB,IACEmD,SACA0D,SACAC,SAJqB2M,EAAA3R,UAAAC,OAANoQ,EAAM1O,MAAAgQ,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANvB,EAAMuB,GAAA5R,UAAA4R,GAAA,IAAAC,GAAA,EAAAC,GAAA,EAAAC,OAAA7R,EAAA,IAMvB,QAAA8R,EAAAC,EAAkB5B,EAAlBnO,OAAAC,cAAA0P,GAAAG,EAAAC,EAAA7P,QAAAC,MAAAwP,GAAA,EAAwB,KAAblB,EAAaqB,EAAA1P,MACtB,gBAAeqO,EAAf,YAAA9P,EAAe8P,IACb,IAAK,SACHtP,EAAQsP,EACR,MACF,IAAK,SACH5L,EAAU4L,EACV,MACF,IAAK,WACH3L,EAAK2L,IAfY,MAAAnO,GAAAsP,GAAA,EAAAC,EAAAvP,EAAA,aAAAqP,GAAAI,EAAAxP,QAAAwP,EAAAxP,SAAA,WAAAqP,EAAA,MAAAC,GAoBvB,IAAK1Q,EAAO,CACV,IAAKnD,KAAK+O,aACR,MAAM,IAAInM,MAAM,yCAElBO,EAAQnD,KAAK+O,aAGf/O,KAAKqH,iBAAiB,wBAAyBP,GAC/C9G,KAAK+G,OAAO5D,QAAO0J,WAAY,QAASD,OAAQ,qBAAuB/F,EAASC,4CAYzD,IACvB,IACE3D,EACA6Q,EACAnN,EACAC,EALqBmN,EAAAnS,UAAAC,OAANoQ,EAAM1O,MAAAwQ,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAN/B,EAAM+B,GAAApS,UAAAoS,GAAA,IAAAC,GAAA,EAAAC,GAAA,EAAAC,OAAArS,EAAA,IAOvB,QAAAsS,EAAAC,EAAkBpC,EAAlBnO,OAAAC,cAAAkQ,GAAAG,EAAAC,EAAArQ,QAAAC,MAAAgQ,GAAA,EAAwB,KAAb1B,EAAa6B,EAAAlQ,MACtB,gBAAeqO,EAAf,YAAA9P,EAAe8P,IACb,IAAK,SACHtP,EAAQsP,EACR,MACF,IAAK,UACHuB,EAAcvB,EACd,MACF,IAAK,SACH5L,EAAU4L,EACV,MACF,IAAK,WACH3L,EAAK2L,IAnBY,MAAAnO,GAAA8P,GAAA,EAAAC,EAAA/P,EAAA,aAAA6P,GAAAI,EAAAhQ,QAAAgQ,EAAAhQ,SAAA,WAAA6P,EAAA,MAAAC,GAwBvB,IAAKlR,EAAO,CACV,IAAKnD,KAAK+O,aACR,MAAM,IAAInM,MAAM,yCAElBO,EAAQnD,KAAK+O,aAGf,QAAoB/M,IAAhBgS,EACF,MAAM,IAAIpR,MAAM,wDAKlB,OAFA5C,KAAK+G,OAAO5D,QAAO0J,WAAY,QAASD,OAAQ,mBAAoBpG,MAAOwN,gBAAenN,EAASC,GAE5F9G,iCAQJ6G,EAASC,GACPA,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGZ7G,KAAKqH,iBAAiB,aAAcP,GAEpC9G,KAAK+G,OAAO8F,WAAY,SAAUD,OAAQ,UAAY/F,EAAS,SAACvC,EAAK4C,GACnEJ,EAAGxC,EAAKA,OAAMtC,EAAYkF,EAAIC,OAAO4G,qCAiBlCyG,EAAWzN,EAAOF,EAASC,GAChC,IACEzF,GACEuL,OAAQ4H,EAAU5H,OAClBC,WAAY2H,EAAU3H,WACtBY,SAAUzN,KAAKyN,UAYnB,GATK3G,GAAyB,mBAAZD,EAGNC,GAAOD,GAA4B,mBAAVE,IACnCD,EAAKC,EACLA,KACAF,EAAU,OALVC,EAAKD,EACLA,EAAU,MAORA,EAAS,CACX,IADW,IAAA4N,GACS,UAAW,OAAQ,OAAQ,SAAU,YAAzDC,EAAA,EAAAA,EAAAD,EAAA1S,OAAA2S,IAAsE,CAAjE,IAAMC,YACa3S,IAAlB6E,EAAQ8N,KACVtT,EAAOsT,GAAQ9N,EAAQ8N,IAIvB9N,EAAQ4G,UAAwC,WAA5B9K,EAAOkE,EAAQ4G,WACrC3M,OAAOqN,OAAO9M,EAAOoM,SAAU5G,EAAQ4G,UAI3C,IAAK1G,GAA0B,iBAAjB,IAAOA,EAAP,YAAApE,EAAOoE,KAAsBtD,MAAM8F,QAAQxC,GACvD,MAAM,IAAInE,MAAM,4BAA8BmE,GAGhDjG,OAAOqN,OAAO9M,EAAOoM,SAAU1G,EAAM0G,UAAWC,cAAe1N,KAAKuM,QAAQ/G,GAAIyJ,WAAYjP,KAAKiP,aAjC7D,IAAA2F,GAAA,EAAAC,GAAA,EAAAC,OAAA9S,EAAA,IAmCpC,QAAA+S,EAAAC,EAAmBlU,OAAOiE,KAAKgC,GAA/B/C,OAAAC,cAAA2Q,GAAAG,EAAAC,EAAA9Q,QAAAC,MAAAyQ,GAAA,EAAuC,KAA5BK,EAA4BF,EAAA3Q,MACxB,aAAT6Q,IACF5T,EAAO4T,GAAQlO,EAAMkO,KArCW,MAAA3Q,GAAAuQ,GAAA,EAAAC,EAAAxQ,EAAA,aAAAsQ,GAAAI,EAAAzQ,QAAAyQ,EAAAzQ,SAAA,WAAAsQ,EAAA,MAAAC,GA+DpC,YAlBiB9S,IAAbhC,KAAKiO,KAA6C,SAAtB5M,EAAOwL,YAA2C,eAAlBxL,EAAOuL,SACrEvL,EAAO4M,IAAMjO,KAAKiO,KAGhBuG,EAAUvP,aACZ5D,EAAO4D,WAAauP,EAAUvP,YAG5BuP,EAAUrR,QACZ9B,EAAO8B,MAAQqR,EAAUrR,OAGtB9B,EAAOsL,YACVtL,EAAOsL,UAAYxC,KAGrBnK,KAAKuM,QAAQxF,MAAM1F,EAAQwF,EAASC,GAE7B9G,4CAQP,OADAA,KAAKuM,QAAQR,eACN/L,2CAQP,OADAA,KAAKuM,QAAQN,cACNjM,2CAQP,OAAOA,KAAKkM,gDAQZ,OADAlM,KAAKuM,QAAQL,YACNlM,6CASQmD,GACf,GAAqB,iBAAVA,EACT,MAAM,IAAIP,MAAJ,2BAAqCO,EAArC,iCAGR,GAAqB,IAAjBA,EAAMpB,OACR,MAAM,IAAIa,MAAM,kDAKlB,OAFA5C,KAAK+O,aAAe5L,EAEbnD,cAIX,SAASyQ,EAAkBkE,EAAMO,EAAS9Q,GAGxC,GAF8B,UAAZ8Q,GAAuBzR,MAAM8F,QAAQnF,SAAS,IAAOA,EAAP,YAAAzB,EAAOyB,MAAU8Q,EAG/E,MAAM,IAAItS,MAAJ,qBAA+BsS,EAA/B,uBAA6DP,EAA7D,KAIV/U,EAAOD,QAAUgP,mBCjuCjB,IAAAlG,EAEA0M,EAAAC,OAAAD,QAAAC,OAAAC,SACA,GAAAF,KAAAG,gBAAA,CAEA,IAAAC,EAAA,IAAAC,WAAA,IACA/M,EAAA,WAEA,OADA0M,EAAAG,gBAAAC,GACAA,GAIA,IAAA9M,EAAA,CAKA,IAAAI,EAAA,IAAApF,MAAA,IACAgF,EAAA,WACA,QAAAgN,EAAArV,EAAA,EAAsBA,EAAA,GAAQA,IAC9B,MAAAA,KAAAqV,EAAA,WAAAxI,KAAAnE,UACAD,EAAAzI,GAAAqV,MAAA,EAAArV,IAAA,OAGA,OAAAyI,GAIAjJ,EAAAD,QAAA8I,iBC3BA,IADA,IAAAiN,KACAtV,EAAA,EAAeA,EAAA,MAASA,EACxBsV,EAAAtV,MAAA,KAAAqG,SAAA,IAAAkP,OAAA,GAgBA/V,EAAAD,QAbA,SAAAgJ,EAAAC,GACA,IAAAxI,EAAAwI,GAAA,EACAgN,EAAAF,EACA,OAAAE,EAAAjN,EAAAvI,MAAAwV,EAAAjN,EAAAvI,MACAwV,EAAAjN,EAAAvI,MAAAwV,EAAAjN,EAAAvI,MAAA,IACAwV,EAAAjN,EAAAvI,MAAAwV,EAAAjN,EAAAvI,MAAA,IACAwV,EAAAjN,EAAAvI,MAAAwV,EAAAjN,EAAAvI,MAAA,IACAwV,EAAAjN,EAAAvI,MAAAwV,EAAAjN,EAAAvI,MAAA,IACAwV,EAAAjN,EAAAvI,MAAAwV,EAAAjN,EAAAvI,MACAwV,EAAAjN,EAAAvI,MAAAwV,EAAAjN,EAAAvI,MACAwV,EAAAjN,EAAAvI,MAAAwV,EAAAjN,EAAAvI,wBCnBA,IACAyV,EAAA3V,EAAA,IACA8E,EAAA9E,EAAA,GACA4V,EAAA5V,EAAA,IACA6V,EAAA7V,EAAA,IAuBA,SAAAsO,EAAAjJ,EAAAN,EAAA9B,GACA,IAAAA,IAAA8B,EACA,UAAArC,MAAA,+EA8BA,OA3BA9B,OAAAuE,iBAAArF,MAEAiF,YACAb,MAAAa,EACAhE,YAAA,GAEAkC,OACAiB,MAAAjB,EACAlC,YAAA,GAEAsE,QACAnB,MAAAmB,EACAtE,YAAA,KAIAH,OAAAC,eAAAf,KAAA,kBACAoE,MAAA,SAAAyI,EAAAD,GACA,OACAC,aACAD,SACA3H,WAAAjF,KAAAiF,WACA9B,MAAAnD,KAAAmD,UAKAnD,KAAAuF,OAAAM,SACA7F,KAAAuF,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,KAFA,aAEAC,QAAAzF,MAKAX,KAcAwO,EAAAjN,UAAAyU,MAAA,SAAAhO,EAAAnB,EAAAC,GACA,IAAAC,GAAeP,KAAAwB,GAEflB,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAA8B,iBAAA,mBAAAP,GAEA9G,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,oBAAAD,EAAAF,EAAA,SAAAvC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,OAAA6O,UAaAxH,EAAAjN,UAAA4H,OAAA,SAAAtC,EAAAC,GACA,IACA/G,EAAAC,KAWA,OATA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,0BAAAH,EAAA,SAAAvC,GACAwC,EAAAxC,SAAAtC,EAAAjC,KAGAC,MAoBAwO,EAAAjN,UAAA0U,eAAA,SAAAzQ,EAAAkK,EAAA7I,EAAAC,GACA,IACA/G,EAAAC,KACAsG,KACAsG,EAAA,SAoBA,GAlBApH,GAAA,iBAAAA,IACAsB,EAAAD,EACAA,EAAA6I,EACAA,EAAAlK,EACAA,EAAA,MAGAsB,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA6I,aAAA1K,EACAsB,EAAAoJ,EAAArJ,YAEAC,EAAAE,KAAAkJ,EAGA7I,KAAAqP,QACA,eAAArP,EAAAqP,QACAtJ,EAAA,uBAEA,aAAA/F,EAAAqP,QACA,UAAAtT,MAAA,2CAAAiE,EAAAqP,SAoBA,OAhBA1Q,IACAc,EAAAC,IAAAf,GAGAzF,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,WAAA4F,GAAAtG,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACA,IAAAiP,EAEA,GAAA7R,EACA,OAAAwC,EAAAxC,IAGA6R,EAAA,IAAAnR,EAAAjF,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,QACA/B,QAAAwB,EAAAC,OAAAxB,SACAmB,EAAA,KAAAqP,KAGAnW,MAmBAwO,EAAAjN,UAAA6U,eAAA,SAAA3D,EAAA5L,EAAAC,GACA,IACA8F,EACAtG,KAwBA,MAtBA,iBAAAmM,GACAnM,EAAAC,IAAAkM,EACA7F,EAAA,WAEAtG,EAAAE,MAAiBO,MAAA0L,GACjB7F,EAAA,iBAGA9F,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,WAAA4F,GAAAtG,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACA5C,EACAwC,EAAAxC,GAGAwC,EAAA,gBAAA8F,GAAA1F,EAAAC,OAAAZ,KAAAW,EAAAC,OAAAc,OAIAjI,MAUAwO,EAAAjN,UAAA8U,qBAAA,SAAAxP,EAAAC,GACA,IACAR,GAAYnD,MAAAnD,KAAAmD,MAAA8B,WAAAjF,KAAAiF,YAYZ,OATA6B,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAJA7G,KAOAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,qCAAAV,EAAAO,EAAA,SAAAvC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,UARAnH,MAqBAwO,EAAAjN,UAAA+U,eAAA,SAAApR,EAAA2B,EAAAC,GACA,IACAR,GAAYC,IAAArB,GAGZ4B,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAJA7G,KAOAuF,OAAA8B,iBAAA,4BAAAP,GAPA9G,KASAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,qBAAAV,EAAAO,EAAA,SAAAvC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,WAWAqH,EAAAjN,UAAAgV,cAAA,SAAArR,EAAA2B,EAAAC,GACA,IACAR,GAAYC,IAAArB,GACZnF,EAAAC,KAEA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAA8B,iBAAA,mBAAAP,GAEA/G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,kBAAAV,EAAAO,EAAA,SAAAvC,EAAA4C,GACA,IAAAwI,EAEA,GAAApL,EACA,OAAAwC,EAAAxC,IAGAoL,EAAA,IAAA1K,EAAAjF,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,QACA/B,QAAAwB,EAAAC,OAAAxB,SACAmB,EAAA,KAAA4I,MAUAlB,EAAAjN,UAAAiV,WAAA,SAAA3P,EAAAC,GAGAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAA8B,iBAAA,wBAAAP,GAEA,IAAAgP,EAAA9V,MACAoH,QAAAP,EAAAC,IAWA0H,EAAAjN,UAAAkV,gBAAA,SAAAC,EAAA7P,EAAAC,GACA,IAAAR,GACAE,SASA,OALAM,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGApD,MAAA8F,QAAAmN,IAPA1W,KAWAuF,OAAA8B,iBAAA,qBAAAP,GAEAR,EAAAE,KAAAkQ,YAAAjU,IAAA,SAAA0T,GACA,OAAAA,aAAAnR,EAAAmR,EAAA9P,YAAA8P,IAdAnW,KAiBAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,sBAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,EAAA4C,KAAAC,UAlBAnH,MAQA8G,EAAA,IAAAlE,MAAA,yGAwBA4L,EAAAjN,UAAAoV,yBAAA,SAAAD,EAAA7P,EAAAC,GACA,IAAAR,GACAE,SASA,OALAM,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGApD,MAAA8F,QAAAmN,IAPA1W,KAWAuF,OAAA8B,iBAAA,8BAAAP,GAEAR,EAAAE,KAAAkQ,YAAAjU,IAAA,SAAA0T,GACA,OAAAA,aAAAnR,EAAAmR,EAAA9P,YAAA8P,IAdAnW,KAiBAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,+BAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,EAAA4C,KAAAC,UAlBAnH,MAQA8G,EAAA,IAAAlE,MAAA,kHAwBA4L,EAAAjN,UAAAqV,gBAAA,SAAAC,EAAAhQ,EAAAC,GACA,IAAAR,GACAE,MACAyB,IAAA4O,IAUA,OALA/P,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGApD,MAAA8F,QAAAsN,IAPA7W,KAWAuF,OAAA8B,iBAAA,qBAAAP,GAXA9G,KAaAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,sBAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,EAAA4C,KAAAC,UAdAnH,MAQA8G,EAAA,IAAAlE,MAAA,qGAmBA4L,EAAAjN,UAAAuV,aAAA,SAAAD,EAAAhQ,EAAAC,GACA,IAAAR,GACAE,MACAyB,IAAA4O,IAUA,GALA/P,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,OAGApD,MAAA8F,QAAAsN,GACA,OAAA/P,EAAA,IAAAlE,MAAA,iGARA5C,KAWAuF,OAAA8B,iBAAA,kBAAAP,GAXA9G,KAaAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,mBAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,WAYAqH,EAAAjN,UAAAwV,iBAAA,SAAAL,EAAA7P,EAAAC,GACA,IAAAR,GACAE,SASA,OALAM,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGApD,MAAA8F,QAAAmN,IAPA1W,KAWAuF,OAAA8B,iBAAA,sBAAAP,GAEAR,EAAAE,KAAAkQ,YAAAjU,IAAA,SAAA0T,GACA,OAAAA,aAAAnR,EAAAmR,EAAA9P,YAAA8P,IAdAnW,KAiBAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,uBAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,UAlBAnH,MAQA8G,EAAA,IAAAlE,MAAA,0GAwBA4L,EAAAjN,UAAAyV,gBAAA,SAAAN,EAAA7P,EAAAC,GACA,IAAAR,GACAE,SASA,OALAM,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGApD,MAAA8F,QAAAmN,IAPA1W,KAWAuF,OAAA8B,iBAAA,qBAAAP,GAEAR,EAAAE,KAAAkQ,YAAAjU,IAAA,SAAA0T,GACA,OAAAA,aAAAnR,EAAAmR,EAAA9P,YAAA8P,IAdAnW,KAiBAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,sBAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,EAAA4C,KAAAC,UAlBAnH,MAQA8G,EAAA,IAAAlE,MAAA,yGAsBA4L,EAAAjN,UAAA0V,kBAAA,SAAApQ,EAAAC,GACA,IACAR,GAAYnD,MAAAnD,KAAAmD,MAAA8B,WAAAjF,KAAAiF,YAGZ6B,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAJA7G,KAOAuF,OAAA8B,iBAAA,+BAAAP,GAPA9G,KASAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,kCAAAV,EAAAO,EAAA,SAAAvC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,WAgBAqH,EAAAjN,UAAA2V,eAAA,SAAAxH,EAAA7I,EAAAC,GACA,IAAAR,KAUA,OARAoJ,aAAA1K,EACAsB,EAAAoJ,EAAArJ,YAEAC,EAAAE,KAAAkJ,EAGA1P,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,sBAAAV,EAAAO,EAAAC,GAEA9G,MAgBAwO,EAAAjN,UAAA4V,gBAAA,SAAAjS,EAAAC,EAAA0B,EAAAC,GACA,IACA/G,EAAAC,KACAsG,GACAC,IAAArB,EACAsB,KAAArB,GAoBA,OAjBA2B,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,8BAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACA,IAAAwI,EAEA,GAAApL,EACA,OAAAwC,EAAAxC,IAGAoL,EAAA,IAAA1K,EAAAjF,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,QACA/B,QAAAwB,EAAAC,OAAAxB,SACAmB,EAAA,KAAA4I,KAGA1P,MAeAwO,EAAAjN,UAAA6V,OAAA,SAAApP,EAAAnB,EAAAC,GACA,IACAC,GAAaP,KAAAwB,GACbjI,EAAAC,KAEA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,MAGA9G,EAAAwF,OAAA8B,iBAAA,oBAAAP,GAEA/G,EAAAwF,OAAAwB,MAAAhH,EAAAiH,eAAA,qBAAAD,EAAAF,EAAA,SAAAS,EAAAH,GACA,GAAAG,EACA,OAAAR,EAAAQ,GAGAR,EAAA,SAAA+O,EAAA9V,EAAAiI,EAAAnB,EAAAM,OAeAqH,EAAAjN,UAAA8V,OAAA,SAAAC,EAAAzQ,EAAAmB,EAAAlB,GACA,IACA4F,KACA3M,EAAAC,KAEA,IAAAsX,EACA,UAAA1U,MAAA,2CAGAkE,IACAA,EAAAkB,EACAA,EAAA,MAGAlB,GAAA,mBAAAD,IACAC,EAAAD,EACAA,MAGA7G,KAAAuF,OAAA8B,iBAAA,oBAAAP,GAEA4F,EAAA4K,WAEAtX,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,UAAyCF,EAAA7F,EAAA,SAAAS,EAAAH,GAC9D,GAAAG,EACA,OAAAR,EAAAQ,GAGAR,EAAA,SAAA+O,EAAA9V,EAAAiI,EAAAnB,EAAAM,OAWAqH,EAAAjN,UAAAgW,qBAAA,SAAAD,EAAAzQ,EAAAC,GACA,IACAR,GAAYgR,YAEZ,IAAAA,EACA,UAAA1U,MAAA,yDAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,MAGA7G,KAAAuF,OAAA8B,iBAAA,kCAAAP,GAEA9G,KAAAuF,OAAAwB,OACK8F,WAAA,aAAAD,OAAA,wBACLtG,EACAO,EACA,SAAAvC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,WAYAqH,EAAAjN,UAAAiW,qBAAA,SAAAxP,EAAAnB,EAAAC,GACA,IACAR,GAAYE,MAAQO,MAAAiB,IAGpBlB,GAAA,mBAAAD,IACAC,EAAAD,EACAA,MAJA7G,KAOAuF,OAAA8B,iBAAA,kCAAAP,GAPA9G,KASAuF,OAAAwB,OAAqB8F,WAAA,aAAAD,OAAA,wBAA2DtG,EAAAO,EAAA,SAAAvC,EAAA4C,GAChFJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,WAYAqH,EAAAjN,UAAA2N,KAAA,SAAAlH,EAAAnB,GACA,WAAAkP,EAAA/V,KAAAgI,EAAAnB,IAYA2H,EAAAjN,UAAAwG,UAAA,SAAAC,EAAAnB,EAAAuG,GACA,IACAqK,EACAvI,EAaA,OAXA9B,GAAA,mBAAAvG,IACAuG,EAAAvG,EACAA,EAAA,MAGA7G,KAAAuF,OAAA8B,iBAAA,uBAAA+F,GAEAqK,EAAA5Q,KAAAyI,OAAA,SAAAzI,EAAAyI,MAAA,mBACAJ,EAAA,IAAA6G,EAAA/V,KAAAgI,EAAAnB,IAEAkB,YAAAuF,GAAAmK,EAAArK,GACA8B,GAWAV,EAAAjN,UAAAmW,SAAA,SAAA7Q,EAAAC,GAUA,OAPAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,4BAAAH,EAAAC,GAEA9G,MAiBAwO,EAAAjN,UAAAoW,eAAA,SAAAzS,EAAAC,EAAA0B,EAAAC,GACA,IAAAR,GACAC,IAAArB,EACAsB,KAAArB,GAEApF,EAAAC,KAmBA,OAjBA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGAA,KAAA+Q,kBACAtR,EAAAsR,gBAAA/Q,EAAA+Q,iBAGA7X,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,qBAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACA,GAAA5C,EACA,OAAAwC,EAAAxC,GAGA,IAAAU,EAAAjF,EAAAmH,EAAAC,OAAAZ,KAAAa,QAAAN,KAGA/G,GAWAyO,EAAAjN,UAAAsW,qBAAA,SAAAC,EAAAjR,EAAAC,GACA,IACA7B,KACAqB,GAAYE,SAeZ,OAZAvB,EAAAjF,KAAAiF,YAAA6S,EACAxR,EAAAE,KAAAxG,KAAAmD,OAAA8B,EAEA6B,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAPA7G,KAUAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,qCAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,UAXAnH,MAwBAwO,EAAAjN,UAAAwW,uBAAA,SAAAD,EAAAjR,EAAAC,GACA,IACA7B,KACAqB,GAAYE,SAGZvB,EAAAjF,KAAAiF,YAAA6S,EACAxR,EAAAE,KAAAxG,KAAAmD,OAAA8B,EAEA6B,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAPA7G,KAUAuF,OAAA8B,iBAAA,oCAAAP,GAVA9G,KAYAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,uCAAAV,EAAAO,EAAA,SAAAvC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,OAAAiK,UAYA5C,EAAAjN,UAAAmO,SAAA,SAAAlK,EAAAL,GACA,WAAAH,EAAAhF,KAAAwF,EAAAL,IAUAqJ,EAAAjN,UAAAyW,kBAAA,SAAAC,GACA,WAAAnC,EAAA9V,KAAAiY,IAGArY,EAAAD,QAAA6O,yRCx7BA,IAAMxJ,EAAW9E,EAAQ,GAgBnBgY,aACJ,SAAAA,EAAajT,EAAY+C,EAASnB,EAASsR,GAgDzC,+FAhD8ClW,CAAAjC,KAAAkY,GAC9CpX,OAAOuE,iBAAiBrF,MAEtBiF,YACEb,MAAOa,EACPhE,YAAY,GAEdmX,OACEhU,MAAO+T,EAAIhR,OAAOiR,MAClBnX,YAAY,GAEdyV,WACEtS,MAAO+T,EAAIhR,OAAO2K,KAAKrP,IAAI,SAAA0T,GACzB,IAAMzV,EAAI,IAAIsE,EAASC,EAAYkR,EAAI5P,IAAK4P,EAAI3O,QAAS2O,EAAI1O,OAE7D,OADA/G,EAAEgF,QAAUyQ,EAAIxQ,SACTjF,IAETO,YAAY,GAEdoX,cACEjU,MAAO+T,EAAIhR,OAAOkR,iBAClBpX,YAAY,GAEd4F,SACEzC,OACEkU,KAAMzR,EAAQyR,KACdC,KAAM1R,EAAQ0R,KACdjB,SAAUa,EAAIhR,OAAOqR,YAEvBvX,YAAY,GAEd+G,SACE5D,MAAO4D,MACP/G,YAAY,GAGdwX,SACErU,MAAO+T,EAAIhR,OAAO2K,KAAK/P,OACvBd,YAAY,EACZwE,UAAU,KAId3E,OAAO4X,OAAO1Y,KAAKgI,SACnBlH,OAAO4X,OAAO1Y,KAAK6G,SACnB/F,OAAO4X,OAAO1Y,KAAKqY,cAGfrY,KAAKiF,WAAWM,OAAOM,SAAU,CACnC,IAAM8S,GAAa,aAEnB,OAAO3Y,KAAKiF,WAAWM,OAAOM,SAASC,aAAa9F,MAClD+F,OAAQ,UACRC,OAAQ,SAACrF,EAAMsF,EAAMC,EAAQC,GAArB,OAAgCA,GAAUwS,EAAUC,SAASjY,MAIzE,OAAOX,iDAME8G,GAAI,IAAAwD,EAAAtK,KACP6Y,EAAoB,SAACvR,EAAOH,GAChC,GAAIG,EACF,OAAOR,EAAGQ,GAGZH,EAAOsR,SAAWnO,EAAKmO,QACvB3R,EAAG,KAAMK,IAKX,GAFAnH,KAAKiF,WAAWM,OAAO8B,iBAAiB,yBAA0BP,GAE9D9G,KAAKyY,SAAWzY,KAAKoY,MACvB,OAAOtR,EAAG,KAAM,MAIlB,GAAI9G,KAAK6G,QAAQyQ,SACftX,KAAKiF,WAAWoS,OAAOrX,KAAK6G,QAAQyQ,SAAU,KAAMtX,KAAKgI,YAAe6Q,QAK1E,QAA0B7W,IAAtBhC,KAAK6G,QAAQ0R,MAAsBvY,KAAKgI,QAAQ8Q,KAApD,CACE,IACE9Q,EAAUlH,OAAOqN,UAAWnO,KAAKgI,SAAU+Q,kBAC3CC,EAAsBhZ,KAAK0W,UAAU1W,KAAK0W,UAAU3U,OAAS,GAAGoD,QAHVxB,GAAA,EAAAC,GAAA,EAAAC,OAAA7B,EAAA,IAKxD,QAAA8B,EAAAC,EAAuBiE,EAAQ8Q,KAA/B9U,OAAAC,cAAAN,GAAAG,EAAAC,EAAAG,QAAAC,MAAAR,GAAA,EAAqC,KAA1BsV,EAA0BnV,EAAAM,MACX,iBAAb6U,EACTjR,EAAQ+Q,aAAajW,KAAKkW,EAAoBC,IAE9CjR,EAAQ+Q,aAAajW,KAAKkW,EAAoBlY,OAAOiE,KAAKkU,GAAU,MAThB,MAAA3U,GAAAV,GAAA,EAAAC,EAAAS,EAAA,aAAAX,GAAAI,EAAAQ,QAAAR,EAAAQ,SAAA,WAAAX,EAAA,MAAAC,GAaxD7D,KAAKiF,WAAWmS,OAAOpP,GAAUuQ,KAAMvY,KAAK6G,QAAQ0R,MAAOM,OAb7D,CAkBA,QAA0B7W,IAAtBhC,KAAK6G,QAAQyR,WAA4CtW,IAAtBhC,KAAK6G,QAAQ0R,KAAoB,CAEtE,IAAMpJ,GACJmJ,KAAMtY,KAAK6G,QAAQyR,KAAOtY,KAAK6G,QAAQ0R,KACvCA,KAAMvY,KAAK6G,QAAQ0R,MAGrB,OAAIpJ,EAAKmJ,MAAQtY,KAAKoY,MACbtR,EAAG,KAAM,WAGlB9G,KAAKiF,WAAWmS,OAAOpX,KAAKgI,QAASmH,EAAM0J,GAI7C/R,EAAG,IAAIlE,MAAM,gGAIjBhD,EAAOD,QAAUuY,iBCvHjB,SAAApC,EAAA7Q,EAAAgT,GAmBA,OAlBAnX,OAAAuE,iBAAArF,MAEAiF,YACAb,MAAAa,EACAhE,YAAA,GAEAsE,QACAnB,MAAAa,EAAAM,OACAtE,YAAA,GAGAgX,SACA7T,MAAA6T,MACAhX,YAAA,EACAwE,UAAA,KAIAzF,KAAAuF,OAAAM,SACA7F,KAAAuF,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,KAFA,OAEAC,QAAAzF,MAKAX,KASA8V,EAAAvU,UAAA8C,MAAA,SAAAwC,EAAAC,GACA,IACA/G,EAAAC,KACAsG,GACAE,MACA0S,WAAAlZ,KAAAiY,UAiBA,OAbAnR,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAA/G,KAAAiF,WAAA+B,eAAA,8BAAAV,EAAAO,EAAA,SAAAvC,GACA,GAAAA,EACA,OAAAwC,KAAAxC,GAGAvE,EAAAqH,QAAAP,EAAAC,KAGA9G,MAYA8V,EAAAvU,UAAA6F,QAAA,SAAAP,EAAAC,GACA,IACA/G,EAAAC,KAiCA,OA9BA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,MAAA/G,KAAAiF,WAAA+B,eAAA,8BAAAH,EAAA,SAAAvC,EAAA4C,GACA,OAAA5C,IACAwC,KAAAxC,GAGA4C,EAAAC,OAAApH,EAAAkF,WAAA9B,OACA+D,EAAAC,OAAApH,EAAAkF,WAAA9B,OAAAgW,SAAApZ,EAAAkF,wBACAlF,EAAAkY,QAAA/Q,EAAAC,OAAApH,EAAAkF,WAAA9B,OAAAgW,SAAApZ,EAAAkF,uBAAAiU,gBAGAlX,IAAAjC,EAAAkY,UACAlY,EAAAkY,iBASAnR,GACAA,EAAA,KAAA/G,KAPA+G,KAAA,IAAAlE,MAAA,mCAAA7C,EAAAkF,wBAGA6B,KAAA,IAAAlE,MAAA,8BAAA7C,EAAAkF,WAAA9B,UAQAnD,MAaA8V,EAAAvU,UAAAiP,IAAA,SAAA4I,EAAAnB,GAGA,OAFAjY,KAAAiY,QAAAmB,GAAAnB,EAEAjY,MAGAJ,EAAAD,QAAAmW,4bClJA,IACE5T,EAAqBhC,EAAQ,GAYzB6V,cAOJ,SAAAA,EAAY9Q,EAAY+C,EAASnB,gGAAS5E,CAAAjC,KAAA+V,GAAA,IA+FdnH,EA/FctE,EAAAC,EAAAvK,MAAA+V,EAAAvL,WAAA1J,OAAA2J,eAAAsL,IAAAxV,KAAAP,OAGpCqZ,EAAU,KA4Fd,OAzFAvY,OAAOuE,iBAAPiF,GAEEgP,WAEElV,MAAO,WACPqB,UAAU,GAEZF,QACEnB,MAAOa,EAAWM,QAEpBgU,aACEnV,OAAO,EACPqB,UAAU,GAGZ+T,aACEpV,MAAO,WACLkG,EAAKgP,UAAY,WACjBhP,EAAKhD,MAAQ,KACbgD,EAAKvC,cAGT0R,YACErV,MAAO,WACLkG,EAAKgP,UAAY,aAGrBI,wBACEtV,MAAO,WACLkG,EAAKgP,UAAY,WAEbhP,EAAKwE,iBACPxE,EAAKvC,cAKXwF,SACEnJ,MAAO,KACPqB,UAAU,EACVxE,YAAY,GAEdoO,OACEjL,MAAOyC,GAAWA,EAAQwI,MAAQxI,EAAQwI,MAAQ,MAClDpO,YAAY,GAEdiK,OACE9G,MAAOyC,GAAWA,EAAQqE,MAAQrE,EAAQqE,MAAQ,OAClDjK,YAAY,GAEdqO,OACElL,MAAOyC,GAAWA,EAAQyI,MAAQzI,EAAQyI,MAAQ,OAClDrO,YAAY,GAGdgE,YACEb,MAAOa,EACPhE,YAAY,GAEd+G,SACE5D,MAAO4D,MACP/G,YAAY,GAEd4O,QACE5O,YAAY,EACZC,IAAK,kBAAMmY,GACX7I,IAAK,SAAApM,GACEiV,IACHA,EAAUjV,KAKhBqJ,UACErJ,MAAQyC,GAAWA,EAAQ4G,SAAY5G,EAAQ4G,YAC/CxM,YAAY,EACZwE,UAAU,GAEZkU,iBACEvV,OAAOyC,GAA8C,kBAA5BA,EAAQ8S,iBAAgC9S,EAAQ8S,gBACzE1Y,YAAY,EACZwE,UAAU,GAEZqJ,iBACE1K,MAAOyC,GAA8C,kBAA5BA,EAAQiI,gBAAgCjI,EAAQiI,gBAAkB7J,EAAWM,OAAOuJ,gBAC7G7N,YAAY,KAIZqJ,EAAK/E,OAAOM,UACd+I,EAAOtE,EAAK/E,OAAOM,SAASC,aAArBwE,GACLvE,OAAQ,UACRC,OAAQ,SAAUrF,EAAMsF,EAAMC,EAAQC,GAGpC,OAAOA,IAAuC,KAF3B,QAAS,YAAa,cAAe,UAE7BC,QAAQzF,MALvC4J,EAAAD,EAAAsE,IAhGsCtE,qUAPzBpI,oCAuHX4E,GACJ9G,KAAKuF,OAAO8B,iBAAiB,aAAcP,GAE3C,IAAMR,GAAQE,MAAOqJ,OAAQ7P,KAAK6P,SAElC,GAAuB,WAAnB7P,KAAKsZ,UACP,OAAOxS,EAAG,IAAIlE,MAAM,qDAGtB5C,KAAKuF,OAAOwB,MAAM/G,KAAKiF,WAAW+B,eAAe,WAAY,SAAUV,EAAM,SAAUhC,EAAK4C,GAC1FJ,EAAGxC,EAAK4C,GAAOA,EAAIC,OAAO6O,2CAYpBnP,EAASC,GAAI,IAAAqF,EAAAnM,KAWrB,OAVK8G,GAAyB,mBAAZD,IAChBC,EAAKD,EACLA,EAAU,MAGRC,GACF9G,KAAK4Z,OAAO9S,GAIS,WAAnB9G,KAAKsZ,WACPtZ,KAAKgM,KAAK,OAAQ,KAAMhM,MACjBA,MAIc,gBAAnBA,KAAKsZ,UACAtZ,MAITA,KAAKsH,MAAQ,KACbtH,KAAKsZ,UAAY,cAEjBtZ,KAAKuF,OAAOwC,UAAU/H,KAAM6G,EAAS,SAACS,EAAOH,GAC3C,GAAIG,EACF,MAAsB,kBAAlBA,EAAM4G,QACD/B,EAAK5G,OAAO1D,KAAK,YAAasK,EAAKqN,cAG5CrN,EAAKmN,UAAY,WACjBnN,EAAK7E,MAAQ,IAAI1E,MAAM,qCAAuC0E,EAAM4G,SACpE/B,EAAKH,KAAK,OAAQG,EAAK7E,OAChB,MAGT6E,EAAK0D,OAAS1I,EAAO0I,OACrB1D,EAAKoB,QAAUpG,EAAOoG,QACtBpB,EAAKmN,UAAY,SAEZnN,EAAKoN,cACRpN,EAAK5G,OAAOxC,YAAY,eAAgBoJ,EAAKsN,YAC7CtN,EAAK5G,OAAOxC,YAAY,eAAgBoJ,EAAKsN,YAC7CtN,EAAK5G,OAAOxC,YAAY,cAAeoJ,EAAKuN,wBAC5CvN,EAAKoN,aAAc,GAGrBpN,EAAKH,KAAK,OAAQ,KAAlBG,KAGKnM,0CAUG8G,GACV,MAAuB,gBAAnB9G,KAAKsZ,WACHxS,GACFA,EAAG,IAAIlE,MAAM,uEAGR5C,OAGLA,KAAKuZ,cACPvZ,KAAKuF,OAAOT,eAAe,eAAgB9E,KAAKyZ,YAChDzZ,KAAKuF,OAAOT,eAAe,eAAgB9E,KAAKyZ,YAChDzZ,KAAKuF,OAAOT,eAAe,cAAe9E,KAAK0Z,wBAC/C1Z,KAAKuZ,aAAc,GAGE,WAAnBvZ,KAAKsZ,UACPtZ,KAAKuF,OAAOuK,YAAY9P,KAAM8G,GAEvBA,GACPA,EAAG,KAAM9G,KAAK6P,QAGhB7P,KAAKsZ,UAAY,WAEVtZ,qCASFsG,GACL,QAAkBtE,IAAdsE,EAAKiJ,KACP,MAAM,IAAI3M,MAAM,4DAKlB,OAHK0D,EAAKkH,WAAYxN,KAAK2Z,iBACzB3Z,KAAKgM,KAAK1F,EAAKiJ,KAAMjJ,GAEhBtG,oCAOF8G,GACL,IAAKA,GAAoB,mBAAPA,EAChB,MAAM,IAAIlE,MAAM,iDAalB,OAVI5C,KAAKsH,MACPR,EAAG9G,KAAKsH,OAEkB,WAAnBtH,KAAKsZ,UACZxS,EAAG,KAAM9G,MAGTA,KAAK6B,KAAK,OAAQiF,GAGb9G,cAIXJ,EAAOD,QAAUoW,mBC5RjB,IACA8D,EAAA3Z,EAAA,IACA4Z,EAAA5Z,EAAA,IACA+I,EAAA/I,EAAA,GASA,SAAAkI,EAAA7C,GAeA,OAbAzE,OAAAC,eAAAf,KAAA,UACAoE,MAAAmB,IAGAzE,OAAAC,eAAAf,KAAA,kBACAoE,MAAA,SAAAwI,GACA,OACAC,WAAA,WACAD,aAKA5M,KAAAuF,OAAAM,SACA7F,KAAAuF,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,KAFA,2CAEAC,QAAAzF,MAKAX,KAWAoI,EAAA7G,UAAAwY,UAAA,SAAAvU,EAAAqB,EAAAC,GACA,IACAR,EACAvG,EAAAC,KAEA,IAAAwF,EACA,UAAA5C,MAAA,oDAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGAP,GAAUC,IAAAf,GAEVzF,EAAAwF,OAAA8B,iBAAA,qBAAAP,GAEA/G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,WAAAV,EAAAO,EAAA,SAAAvC,EAAAkE,GACA1B,EAAAxC,SAAAtC,EAAA,IAAA6X,EAAA9Z,EAAAyI,EAAArB,OAAAZ,IAAAiC,EAAArB,OAAAK,QAAAgB,EAAArB,OAAAM,WAgBAW,EAAA7G,UAAAyY,YAAA,SAAAhS,EAAAnB,EAAAC,GACA,IACA/G,EAAAC,KAEA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAA8B,iBAAA,uBAAAP,GAEA/G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,gBAAyDR,KAAAwB,GAAcnB,EAAA,SAAAS,EAAAH,GACvE,IAAAuP,EAEA,GAAApP,EACA,OAAAR,EAAAQ,GAGAoP,EAAAvP,SAAA2K,KAAArP,IAAA,SAAA0T,GACA,WAAA0D,EAAA9Z,EAAAoW,EAAA5P,IAAA4P,EAAA3O,QAAA2O,EAAA1O,SAGAX,EAAA,MAAcsR,MAAAjR,SAAAiR,MAAA6B,MAAAvD,OAiBdtO,EAAA7G,UAAA2Y,WAAA,SAAA1U,EAAAL,EAAA0B,EAAAC,GACA,IACA/G,EAAAC,KACAsG,KACAsG,EAAA,aAEA,IAAApH,GAAA,iBAAAA,EACA,UAAA5C,MAAA,+DAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGAP,EAAAC,IAAAf,EACAc,EAAAE,KAAArB,EAEA0B,IACA+F,EAAA/F,EAAAsT,eAAA,oCAGApa,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA4F,GAAAtG,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAA,IAAA6X,EAAA9Z,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,WAcAW,EAAA7G,UAAA6Y,WAAA,SAAA5U,EAAAL,EAAA0B,EAAAC,GACA,IACA/G,EAAAC,KACAsG,GAAYC,IAAAf,EAAAgB,KAAArB,GAGZ,IAAAK,GAAA,iBAAAA,EACA,UAAA5C,MAAA,+DAYA,OATAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAXA,cAWAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAA,IAAA6X,EAAA9Z,EAAAyF,EAAAL,EAAA+B,EAAAC,OAAAM,UAGAzH,MAgBAoI,EAAA7G,UAAA8Y,WAAA,SAAA7U,EAAAqB,EAAAC,GACA,IAAAR,GAAcC,IAAAf,GAWd,OATAsB,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,cAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,OAAAZ,OAGAvG,MAYAoI,EAAA7G,UAAA+Y,KAAA,SAAA9U,EAAAL,EAAAC,GACA,WAAAyU,EAAA7Z,KAAAwF,EAAAL,EAAAC,IAYAgD,EAAA7G,UAAA0I,aAAA,SAAAzE,EAAAqB,EAAAC,GACA,IACAR,EACAvG,EAAAC,KAOA,GALA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,OAGArB,GAAA,iBAAAA,EACA,UAAA5C,MAAA,uDAIA0D,GAAUC,IAAAf,GAEVzF,EAAAwF,OAAA8B,iBAAA,wBAAAP,GAEA/G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,cAAAV,EAAAO,EAAA,SAAAS,EAAAkB,GACA1B,EAAAQ,SAAAtF,EAAA,IAAA8X,EAAA/Z,EAAAyI,EAAArB,OAAAZ,IAAAiC,EAAArB,OAAAK,QAAAgB,EAAArB,OAAAM,WAgBAW,EAAA7G,UAAAgZ,eAAA,SAAAvS,EAAAnB,EAAAC,GACA,IACA/G,EAAAC,KAEA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAA8B,iBAAA,0BAAAP,GAEA/G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,mBAA4DR,KAAAwB,GAAcnB,EAAA,SAAAS,EAAAkB,GAC1E,IACAkO,EACAY,EAEA,GAAAhQ,EACA,OAAAR,EAAAQ,GAGAoP,EAAAlO,EAAArB,OAAA2K,KAAArP,IAAA,SAAA0T,GACA,WAAA2D,EAAA/Z,EAAAoW,EAAA5P,IAAA4P,EAAA3O,QAAA2O,EAAA1O,SAGAe,EAAArB,OAAAmQ,WACAA,EAAA9O,EAAArB,OAAAmQ,UAGAxQ,EAAA,MAAcsR,MAAA5P,EAAArB,OAAAiR,MAAAoC,SAAA9D,EAAAY,gBAiBdlP,EAAA7G,UAAAkZ,cAAA,SAAAjV,EAAAkV,EAAA7T,EAAAC,GACA,IACA/G,EAAAC,KACAsG,KACAsG,EAAA,gBAEA,IAAApH,GAAA,iBAAAA,EACA,UAAA5C,MAAA,wEAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGAP,EAAAC,IAAAf,EAEAkV,IACApU,EAAAE,MAAiBkU,aAGjB7T,IACA+F,EAAA/F,EAAAsT,eAAA,0CAGApa,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA4F,GAAAtG,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAA,IAAA8X,EAAA/Z,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,WAcAW,EAAA7G,UAAAoZ,cAAA,SAAAnV,EAAAkV,EAAA7T,EAAAC,GACA,IACA/G,EAAAC,KACAsG,KAGA,IAAAd,GAAA,iBAAAA,EACA,UAAA5C,MAAA,wEA4BA,OAzBAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGAP,EAAAC,IAAAf,EAEAkV,IACApU,EAAAE,MAAiBkU,aAGjB3a,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAjBA,iBAiBAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACA,IAAA0T,KAEA,GAAAtW,EACA,OAAAwC,EAAAxC,GAGAxD,OAAAiE,KAAAmC,EAAAC,OAAAK,SAAAK,QAAA,SAAAvG,GACAsZ,EAAAtZ,GAAA4F,EAAAC,OAAAK,QAAAlG,KAGAwF,EAAA,SAAAgT,EAAA/Z,EAAAmH,EAAAC,OAAAZ,IAAAqU,EAAA1T,EAAAC,OAAAM,UAGAzH,MAgBAoI,EAAA7G,UAAAsZ,cAAA,SAAArV,EAAAqB,EAAAC,GACA,IAAAR,GAAcC,IAAAf,GAWd,OATAsB,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,iBAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,OAAAZ,OAGAvG,MAQAoI,EAAA7G,UAAAuZ,eAAA,SAAAxD,EAAAzQ,EAAAC,GACA,IACA4F,KACA3M,EAAAC,KAEA,IAAAsX,EACA,UAAA1U,MAAA,iDAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,MAGA7G,KAAAuF,OAAA8B,iBAAA,0BAAAP,GAEA4F,EAAA4K,WAEAzQ,KAAAwQ,SACA3K,EAAA2K,OAAAxQ,EAAAwQ,QAGArX,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,kBAAiDF,EAAA7F,EAAA,SAAAS,EAAAH,GACtE,IAAAqT,KAEA,GAAAlT,EACA,OAAAR,EAAAQ,GAGAH,SAAA2K,KAAAjK,QAAA,SAAAqC,GACA,IAAA6Q,EAAA,IAAAjB,EAAA/Z,EAAAmK,EAAA3D,IAAA2D,EAAA1C,QAAA0C,EAAAzC,OAEAsT,EAAArV,QAAAwE,EAAAvE,SAEA6U,EAAA1X,KAAAiY,KAGAjU,EAAA,MACAsR,MAAAjR,SAAAiR,MACAoC,WACAlD,gBAcAlP,EAAA7G,UAAA2I,QAAA,SAAA1E,EAAAL,EAAAC,GACA,WAAA0U,EAAA9Z,KAAAwF,EAAAL,EAAAC,IAUAgD,EAAA7G,UAAAyZ,UAAA,SAAAxV,EAAAqB,EAAAC,GACA,IACAR,GAAYC,IAAAf,GACZzF,EAAAC,KAEA,IAAAwF,GAAA,iBAAAA,EACA,UAAA5C,MAAA,oDAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAA8B,iBAAA,qBAAAP,GAEA/G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,WAAAV,EAAAO,EAAA,SAAAvC,EAAAkE,GACA1B,EAAAxC,SAAAtC,EAAA,IAAAiH,EAAAlJ,EAAAyI,EAAArB,OAAAZ,IAAAiC,EAAArB,OAAAK,QAAAgB,EAAArB,OAAAM,WAeAW,EAAA7G,UAAA0Z,YAAA,SAAAjT,EAAAnB,EAAAC,GACA,IACA/G,EAAAC,KAEA8G,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAA8B,iBAAA,uBAAAP,GAEA/G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,gBAAyDR,KAAAwB,GAAcnB,EAAA,SAAAS,EAAAkB,GACvE,IACAkO,EACAY,EAAA,KAEA,GAAAhQ,EACA,OAAAR,EAAAQ,GAGAoP,EAAAlO,EAAArB,OAAA2K,KAAArP,IAAA,SAAA0T,GACA,WAAAlN,EAAAlJ,EAAAoW,EAAA5P,IAAA4P,EAAA3O,QAAA2O,EAAA1O,SAGAe,EAAArB,OAAAmQ,WACAA,EAAA9O,EAAArB,OAAAmQ,UAGAxQ,EAAA,MAAcsR,MAAA5P,EAAArB,OAAAiR,MAAA9I,MAAAoH,EAAAY,gBAYdlP,EAAA7G,UAAA2Z,WAAA,SAAA1V,EAAAL,EAAA0B,EAAAC,GACA,IACA/G,EAAAC,KACAsG,GAAYC,IAAAf,EAAAgB,KAAArB,GAEZ2B,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAAhH,EAAAiH,eAAA,cAAAV,EAAA,KAAAQ,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAA,IAAAiH,EAAAlJ,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,WAYAW,EAAA7G,UAAA4Z,YAAA,SAAA3V,EAAAL,EAAA0B,EAAAC,GACA,IACA/G,EAAAC,KACAsG,GAAYC,IAAAf,EAAAgB,KAAArB,GAEZ,IAAAK,GAAA,iBAAAA,EACA,UAAA5C,MAAA,iEAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,eAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAA,IAAAiH,EAAAlJ,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,WAeAW,EAAA7G,UAAA6Z,qBAAA,SAAA5V,EAAAL,EAAA0B,EAAAC,GACA,IACA/G,EAAAC,KACAsG,GAAYC,IAAAf,EAAAgB,KAAArB,GAEZ,GAAAA,EAAAmE,WACA,UAAA1G,MAAA,4DAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAAA,wBAAAV,EAAA,KAAAQ,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAA,IAAAiH,EAAAlJ,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,aAcAY,EAAA7G,UAAA8Z,WAAA,SAAA7V,EAAAL,EAAA0B,EAAAC,GACA,IACA/G,EAAAC,KACAsG,KAGA,IAAAd,GAAA,iBAAAA,EACA,UAAA5C,MAAA,iEAeA,OAZAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGAP,EAAAC,IAAAf,EACAc,EAAAE,KAAArB,EAEApF,EAAAwF,OAAAwB,MAAA/G,KAAAgH,eAdA,cAcAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAA,IAAAiH,EAAAlJ,EAAAmH,EAAAC,OAAAZ,IAAAW,EAAAC,OAAAK,QAAAN,EAAAC,OAAAM,UAGAzH,MAgBAoI,EAAA7G,UAAA+Z,WAAA,SAAA9V,EAAAqB,EAAAC,GACA,IAAAR,GAAcC,IAAAf,GAWd,OATAsB,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,cAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,OAAAZ,OAGAvG,MAQAoI,EAAA7G,UAAAga,YAAA,SAAAjE,EAAAzQ,EAAAC,GACA,IACA4F,KACA3M,EAAAC,KAEA,IAAAsX,EACA,UAAA1U,MAAA,8CAsCA,OAnCAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,MAGA7G,KAAAuF,OAAA8B,iBAAA,uBAAAP,GAEA4F,EAAA4K,WAEAzQ,KAAAwQ,SACA3K,EAAA2K,OAAAxQ,EAAAwQ,QAGArX,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,eAA8CF,EAAA7F,EAAA,SAAAS,EAAAH,GACnE,IAAAmI,KAEA,GAAAhI,EACA,OAAAR,EAAAQ,GAGAH,SAAA2K,KAAAjK,QAAA,SAAA2T,GACA,IAAAC,EAAA,IAAAxS,EAAAlJ,EAAAyb,EAAAjV,IAAAiV,EAAAhU,QAAAgU,EAAA/T,OAEAgU,EAAA/V,QAAA8V,EAAA7V,SAEA2J,EAAAxM,KAAA2Y,KAGA3U,EAAA,MACAsR,MAAAjR,SAAAiR,MACA9I,QACAgI,eAIAtX,MAYAoI,EAAA7G,UAAAia,KAAA,SAAAhW,EAAAL,EAAAC,GACA,WAAA6D,EAAAjJ,KAAAwF,EAAAL,EAAAC,IAmBAgD,EAAA7G,UAAAma,gBAAA,SAAAC,EAAA9O,EAAAD,EAAAzJ,EAAA8B,GACA,IAAA2W,EAEA,IAAAD,GAAA,iBAAAA,EACA,UAAA/Y,MAAA,8DAEA,IAAAiK,GAAA,iBAAAA,EACA,UAAAjK,MAAA,kEAEA,IAAAgK,GAAA,iBAAAA,EACA,UAAAhK,MAAA,8DAmBA,OAfAgZ,EAAAD,EACA3V,OAAA,SAAA6V,GACA,OAAAA,EAAAhP,gBAAA,MAAAgP,EAAAhP,aAEA7G,OAAA,SAAA6V,GACA,OAAAA,EAAAjP,YAAA,MAAAiP,EAAAjP,SAEA5G,OAAA,SAAA6V,GACA,OAAAA,EAAA1Y,WAAA,MAAA0Y,EAAA1Y,QAEA6C,OAAA,SAAA6V,GACA,OAAAA,EAAA5W,gBAAA,MAAA4W,EAAA5W,cAIA6W,KAAA,SAAAC,GAA2C,kBAAAA,EAAA3X,QAC3C,UAGAwX,EAAAE,KAAA,SAAAC,GAA2C,sBAAAA,EAAA3X,QAC3C,cAGA,UAWAgE,EAAA7G,UAAAya,cAAA,SAAAC,EAAApV,EAAAC,GACA,IACAR,GAAYC,IAAA0V,GAGZ,IAAAA,GAAA,iBAAAA,EACA,UAAArZ,MAAA,4DAGAkE,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MARA7G,KAWAuF,OAAA8B,iBAAA,uBAAAP,GAEA9G,KAAAuF,OAAAwB,MAAA/G,KAAAgH,eAAA,iBAAAV,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACAJ,EAAAxC,SAAAtC,EAAAkF,EAAAC,OAAA2K,SAcA1J,EAAA7G,UAAA2a,kBAAA,SAAA3K,EAAA4K,EAAAjT,EAAArC,EAAAC,GAcA,OAbAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,sBAAuDrG,IAAA4V,EAAA5K,WAAA/K,KAAA0C,GAAiDrC,EAAA,SAAAvC,EAAA4C,GAC7H5C,EAGAwC,KAAAxC,GAFAwC,KAAA,KAAAI,EAAAC,OAAAK,WAMAxH,MAYAoI,EAAA7G,UAAA6a,kBAAA,SAAA7K,EAAA4K,EAAAtV,EAAAC,GAcA,OAbAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,sBAAuD2E,WAAAhL,IAAA4V,GAA8BtV,EAAA,mBAAAC,EAAA,cAAAxC,EAAA4C,GAC1G5C,EAGAwC,KAAAxC,GAFAwC,KAAA,KAAAI,EAAAC,UAMAnH,MASAoI,EAAA7G,UAAA8a,uBAAA,SAAAxV,EAAAC,GACAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,6BAA6D/F,EAAA,mBAAAC,EAAA,cAAAxC,EAAA4C,GAClF5C,EAGAwC,KAAAxC,GAFAwC,KAAA,KAAAI,EAAAC,WAcAiB,EAAA7G,UAAA+a,oBAAA,SAAA/K,EAAA1K,EAAAC,GACAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,wBAAyD2E,YAAmB1K,EAAA,mBAAAC,EAAA,cAAAxC,EAAA4C,GACjG5C,EAGAwC,KAAAxC,GAFAwC,KAAA,KAAAI,EAAAC,WAeAiB,EAAA7G,UAAAgb,eAAA,SAAAhL,EAAA4K,EAAAtV,EAAAC,GACAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,mBAAoD2E,WAAAhL,IAAA4V,GAA8BtV,EAAA,mBAAAC,EAAA,cAAAxC,EAAA4C,GACvG5C,EAGAwC,KAAAxC,GAFAwC,KAAA,KAAAI,EAAAC,WAeAiB,EAAA7G,UAAAib,eAAA,SAAAjL,EAAA4K,EAAAtV,EAAAC,GACAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,mBAAoD2E,WAAAhL,IAAA4V,GAA8BtV,EAAA,mBAAAC,EAAA,cAAAxC,EAAA4C,GACvG5C,EAGAwC,KAAAxC,GAFAwC,KAAA,KAAAI,EAAAC,WAiBAiB,EAAA7G,UAAAkb,kBAAA,SAAAlL,EAAA4K,EAAAjT,EAAArC,EAAAC,GAcA,OAbAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,sBAAuD2E,WAAAhL,IAAA4V,EAAA3V,KAAA0C,GAAiDrC,EAAA,mBAAAC,EAAA,cAAAxC,EAAA4C,GAC7H5C,EAGAwC,KAAAxC,GAFAwC,KAAA,KAAAI,EAAAC,UAMAnH,MAYAoI,EAAA7G,UAAAmb,oBAAA,SAAAnL,EAAA4K,EAAAjT,EAAArC,EAAAC,GACAA,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA7G,KAAAuF,OAAAwB,OAAqB8F,WAAA,WAAAD,OAAA,wBAAyD2E,WAAAhL,IAAA4V,EAAA3V,KAAA0C,GAAiDrC,EAAA,mBAAAC,EAAA,cAAAxC,EAAA4C,GAC/H5C,EAGAwC,KAAAxC,GAFAwC,KAAA,KAAAI,EAAAC,WAOAvH,EAAAD,QAAAyI,mBC/gCA,IAAAD,EAAAjI,EAAA,GAEA,SAAA2Z,EAAAzR,EAAA5C,EAAAL,EAAAC,GAgBA,GAdA+C,EAAA5H,KAAAP,KAAAoI,EAAA5C,EAAAL,EAAAC,GAGAtE,OAAAuE,iBAAArF,MAEAqI,kBACAjE,MAAA,cAEAmE,kBACAnE,MAAA,gBAKAgE,EAAA7C,OAAAM,SACA,OAAAuC,EAAA7C,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,KAFA,QAEAC,QAAAzF,MAOAkZ,EAAAtY,UAAAT,OAAAqI,OAAAhB,EAAA5G,WACA6H,aACAhF,MAAAyV,KAeAA,EAAAtY,UAAAmG,KAAA,SAAAb,EAAAC,GACA,IACAR,EAAAtG,KAAAqG,YACAtG,EAAAC,KAWA,OATA6G,QAAA7E,IAAA8E,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGA9G,EAAAwF,OAAAwB,MAAA/G,KAAAoI,SAAApB,eAAA,uBAAAV,EAAAO,EAAAC,GAAA,SAAAQ,GACAR,EAAAQ,SAAAtF,EAAAjC,KAGAC,MAGAJ,EAAAD,QAAAka,mBCjEA,IAAA1R,EAAAjI,EAAA,GAEA,SAAA4Z,EAAA1R,EAAA5C,EAAAL,EAAAC,GAgBA,GAdA+C,EAAA5H,KAAAP,KAAAoI,EAAA5C,EAAAL,EAAAC,GAGAtE,OAAAuE,iBAAArF,MAEAqI,kBACAjE,MAAA,iBAEAmE,kBACAnE,MAAA,mBAKAgE,EAAA7C,OAAAM,SACA,OAAAuC,EAAA7C,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,KAFA,kBAEAC,QAAAzF,MAOAmZ,EAAAvY,UAAAT,OAAAqI,OAAAhB,EAAA5G,WACA6H,aACAhF,MAAA0V,KAWAA,EAAAvY,UAAAmG,KAAA,SAAAb,EAAAC,GACA,IACAR,EACAvG,EAAAC,KAEA,IAAAA,KAAAmF,QAAAuV,SACA,UAAA9X,MAAA,8FAcA,OAXAiE,QAAA7E,IAAA8E,GAAA,mBAAAD,IACAC,EAAAD,EACAA,EAAA,MAGAP,EAAAtG,KAAAqG,YAEAtG,EAAAwF,OAAAwB,MAAAhH,EAAAqI,SAAApB,eAAA,0BAAAV,EAAAO,EAAAC,GAAA,SAAAQ,GACAR,EAAAQ,SAAAtF,EAAAjC,KAGAA,GAUA+Z,EAAAvY,UAAAob,UAAA,SAAAC,GAEA,oBAAAA,GAAA,iBAAAA,EAAAC,OACA,UAAAja,MAAA,wGASA,OANA5C,KAAAmF,QAAAuV,WACA1a,KAAAmF,QAAAuV,aAGA1a,KAAAmF,QAAAuV,SAAA5X,KAAA8Z,GAEA5c,MASA8Z,EAAAvY,UAAAub,YAAA,SAAApC,GAEA,IAAAjX,MAAA8F,QAAAmR,GACA,UAAA9X,MAAA,iHAWA,OARA8X,EAAAjY,IAAA,SAAAma,GACA,oBAAAA,GAAA,iBAAAA,EAAAC,OACA,UAAAja,MAAA,mHAIA5C,KAAAmF,QAAAuV,WAEA1a,MAQA8Z,EAAAvY,UAAA8E,UAAA,WACA,IACAC,KASA,OAPAtG,KAAAwF,KACAc,EAAAC,IAAAvG,KAAAwF,IAGAc,EAAAE,KAAAxG,KAAAmF,QACAmB,EAAAlB,KAAApF,KAAAoF,KAEAkB,GASAwT,EAAAvY,UAAAwb,YAAA,WACA,OAAA/c,KAAAmF,QAAAuV,UAGA9a,EAAAD,QAAAma,iBC5IA,IACAkD,GAAWpc,QAAA,EAAAqc,UAAA,QACXC,GAAgBtc,QAAA,EAAAqc,UAAA,gBAChBE,GAAavc,QAAA,EAAAqc,UAAA,SACbG,GAAexc,QAAA,EAAAqc,UAAA,iBACfI,GACAzc,QAAA,EACAqc,UAAA,gBACA9N,MAAA,iBACAmO,WAAAC,GAEAC,GACA5c,QAAA,EACAqc,UAAA,sBACA9N,KAAAsO,EACAH,WAAAI,GAEAC,GACA/c,QAAA,EACAqc,UAAA,mBACA9N,KAAAsO,EACAH,WAAAI,GAEAE,GAAWX,UAAA,QACXY,GAAgBZ,UAAA,gBAIhBa,GACAC,OAAAF,EACAG,UAAepd,QAAA,EAAAqc,UAAA,OAAA9N,MAAA,gBACf8O,OAAYhB,UAAA,2BACZiB,QAAatd,QAAA,EAAAqc,UAAA,aAAA9N,MAAA,gBACbgP,QAAavd,QAAA,GACbwd,KAAAR,EACAS,OAAAR,EACAS,KAAUrB,UAAA,SACVhW,OAAAkW,EACAoB,QAAatB,UAAA,iBAAAK,WAAAjb,SACbmc,UAAevB,UAAA,mBAAAK,WAAAjb,SACfoc,SAAcnB,WAAAoB,GACdC,QAAa1B,UAAA,iBACb2B,SACAhe,QAAA,EACAqc,UAAA,2BACA9N,MAAA,QACAmO,WAAAuB,YAEAC,SAAcle,QAAA,EAAAqc,UAAA,kBACd8B,QAAane,QAAA,EAAAqc,UAAA,iBAAAK,WAmUb,SAAA0B,GACA,OAAAA,EAAAvc,IAAA,SAAAwc,GACA,OAAAA,EAAAxc,IAAA,SAAAyc,GACA,OAAAL,WAAAK,SArUAC,WACAve,QAAA,EACAqc,UAAA,qCACA9N,KAAAiQ,EACA9B,WAAA+B,GAEAC,mBACA1e,QAAA,EACAqc,UAAA,kCACA9N,KAAAiQ,EACA9B,WAAA+B,GAEAne,IAAA8b,EACAuC,QAAa3e,QAAA,EAAAqc,UAAA,iBACbuC,UAAe5e,QAAA,EAAAqc,UAAA,sBACfwC,OAAA5B,EACA6B,MAAWzC,UAAA,iBACX0C,SAAc/e,QAAA,EAAAqc,UAAA,eAAAK,WAAAjb,SACdud,KAAA1C,EACA2C,SAAcjf,QAAA,EAAAqc,UAAA,QACd6C,SAAc7C,UAAA,wBACd8C,cAAmB9C,UAAA,uBAAAK,WAAAuB,YACnBmB,MAAAhD,EACAiD,KAAAjD,EACAkD,OAAYtf,QAAA,EAAAqc,UAAA,iBACZkD,OAAYlD,UAAA,iBAAAK,WAAAoB,GACZ0B,MAAA/C,EACAgD,MAAWpD,UAAA,uBAAAK,WAAAjb,SACXie,QAAarD,UAAA,uBAAAK,WAAAjb,SACbke,QAAArD,EACAsD,MAAAxD,EACAyD,KAAA7C,EACA8C,OAAA7C,EACA8C,aAAkB1D,UAAA,eAAAK,WAAAuB,YAClB9Z,MAAWnE,QAAA,EAAAqc,UAAA,YACX2D,QAAahgB,QAAA,EAAAqc,UAAA,cACb4D,SAAc5D,UAAA,mCACd6D,KAAA9D,EACA+D,KAAAnD,EACAoD,OAAY/D,UAAA,iBACZgE,OAAApD,EACAqD,QAAatgB,QAAA,EAAAqc,UAAA,uBACbkE,MAAWlE,UAAA,wBACXmE,MAAWnE,UAAA,uBAAAK,WAAAoB,GACX2C,OAAYpE,UAAA,sBAAAK,WAAAoB,GACZ4C,KAAAnE,EACAoE,MAAWtE,UAAA,WAAAK,WAAAoB,GACX8C,QAAavE,UAAA,WAAAK,WAAAjb,SACbhB,QAAaT,QAAA,EAAAqc,UAAA,qBACbwE,SAAcxE,UAAA,OAAAK,WAAAjb,SACdqf,SAAczE,UAAA,sBAAAK,WAAAjb,SACdsf,WAAgB1E,UAAA,mBAAAK,WAAAjb,SAChBuf,OAAY3E,UAAA,kBAAAK,WAAAjb,SACZwf,QAAA1E,EACA2E,SAAc7E,UAAA,iBAAAK,WAAAoB,GACdqD,MAAWnhB,QAAA,GACXohB,QAAa/E,UAAA,8BAAAK,WAAAoB,GACbuD,KAAAjF,EACAkF,WAAgBthB,QAAA,GAChBuhB,QAAalF,UAAA,gBAAAK,WAAAoB,GACb0D,UAAenF,UAAA,gBAAAK,WAAAjb,SACfggB,KAAAzE,EACA0E,WAAgBrF,UAAA,yBAChBsF,OAAYtF,UAAA,iBACZuF,OAAA3E,EACA4E,MAAWxF,UAAA,kBACXyF,MAAW9hB,QAAA,EAAAqc,UAAA,UAAA9N,MAAA,iBAAAmO,WAAAC,GACXoF,MAAA3F,EACA4F,OAAYhiB,QAAA,EAAAqc,UAAA,eACZ4F,YAAiB5F,UAAA,6BACjBzM,KAAUyM,UAAA,eAAA9N,MAAA,qBAAAmO,WAAAoB,GACVoE,OAAY7F,UAAA,yBAAAK,WAAAoB,GACZqE,OAAY9F,UAAA,eAAAK,WAAAjb,SACZ2gB,OAAA7F,EACA8F,aAAkBhG,UAAA,uBAClBiG,WAAgBtiB,QAAA,EAAAqc,UAAA,gBAAAK,WAAAjb,SAChB8gB,SAAAnG,EACAoG,OAAYnG,UAAA,8BAAAK,WAAAjb,SACZyW,MAAWlY,QAAA,EAAAqc,UAAA,OAAA9N,MAAA,yCACXkU,MAAWpG,UAAA,OAAA9N,MAAA,SAAAmO,WAAAgG,GACXC,aAAkB3iB,QAAA,EAAAqc,UAAA,OAAA9N,MAAA,SAAAmO,WAAAgG,GAClBE,MAAWvG,UAAA,kBACXwG,MAAApG,EACAqG,OAAA1G,EACA2G,OAAAxG,EACAyG,aAAkB3G,UAAA,uBAClB4G,MAAWjjB,QAAA,EAAA0c,WAkTX,SAAA0B,GACA,OAAAA,EAAAvc,IAAA,SAAA2B,GACA,OAAA0f,SAAA1f,OAnTA2f,OAAY9G,UAAA,SACZ+G,IAAAhH,EACAzN,KAAAyN,EACAiH,MAAWhH,UAAA,kBAAA9N,MAAA,wBACX+U,MAAAlH,EACAmH,QAAavjB,QAAA,EAAAqc,UAAA,oBACbmH,SAAcnH,UAAA,yBACdoH,aAAkBpH,UAAA,cAAA9N,MAAA,wBAClBmV,WAAgB1jB,QAAA,EAAAqc,UAAA,oBAChBsH,OAAA/G,EACAgH,aAAkB5jB,QAAA,EAAAqc,UAAA,mBAAA9N,MAAA,UAClBsV,gBAAqB7jB,QAAA,EAAAqc,UAAA,mBAAA9N,MAAA,UACrBuV,cAAA/G,EACAgH,MAAAvH,EACAwH,MAAW3H,UAAA,kBACX4H,gBAAqB5H,UAAA,oBACrB6H,iBAAsB7H,UAAA,uBACtB8H,kBAAuB9H,UAAA,oBACvB+H,UAAAxH,EACAyH,iBAAAtH,EACAuH,SAAA9H,EACA+H,MAAA9H,EACA+H,QAAaxkB,QAAA,EAAAqc,UAAA,gBAAAK,WAAAuB,YACbwG,aAAkBpI,UAAA,cAAA9N,MAAA,yBA6BlB,SAAAV,EAAAlJ,GASA,OARAzE,OAAAuE,iBAAArF,MAEAuF,QACAnB,MAAAmB,EACAtE,YAAA,KAIAjB,KAAAuF,OAAAM,SACA7F,KAAAuF,OAAAM,SAAAC,aAAA9F,MACA+F,OAAA,UACAC,OAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GAGA,OAAAA,IAAA,OAAAC,QAAAzF,MAKAX,KA8FA,SAAAslB,EAAAhf,EAAA1F,EAAAD,EAAAyD,GACAxD,GAAA,QAAAD,EACA2F,EAAA3F,GAAAyD,EAGAkC,EAAAE,KAAA7F,GAAAyD,EAaA,SAAAgb,EAAA9Y,EAAAO,GACA,IAAA0e,KAEAzkB,OAAAiE,KAAA8B,GACAb,OAAA,SAAAyF,GACA,OAAA5E,EAAA4E,KAAA,4CAAArF,QAAAqF,KAEA5D,QAAA,SAAA4D,GACA,cAAAA,GAAA,aAAAA,GACA8Z,EAAAziB,KAAA2I,UACA5E,EAAA4E,IAEA,UAAAA,GAAA,SAAAA,IACA,UAAAA,GACA8Z,EAAAziB,KAAA,SAGAyiB,EAAAziB,KAAA+D,EAAA4E,YAGA5E,EAAA4E,KAGA8Z,EAAAxjB,OAAA,IACAuE,EAAAO,QAAA0e,GAYA,SAAA9H,EAAAnX,EAAAO,GACAP,EAAAO,SAAA,cAEAA,EAAA2e,QACAlf,EAAAkf,MAAA3e,EAAA2e,aACA3e,EAAA2e,OA+BA,SAAAnG,EAAAL,GAEA,OAAAvb,MAAA8F,QAAAyV,EAAA,IAMAA,EAAAvc,IAAA,SAAAgjB,GAEA,IAGArlB,EAHAqB,GACAd,KAAA8kB,EAAA,IAIA,IAAArlB,EAAA,EAAeA,EAAAqlB,EAAA1jB,OAAkB3B,IAEjCqD,MAAA8F,QAAAkc,EAAArlB,IACAqB,EAAAikB,YAAAD,EAAArlB,GAAAqC,IAAA,SAAAkjB,GACA,OAAA9G,WAAA8G,KAKAlkB,EAAAmkB,SAAA/G,WAAA4G,EAAArlB,IAIA,OAAAqB,IAzBAud,EAAAvc,IAAA,SAAAgjB,GACA,OAAc9kB,KAAA8kB,KAmCd,SAAAnC,EAAAtE,GACA,OAAAvb,MAAA8F,QAAAyV,SAmBA,SAAAN,KAuBA,SAAAhB,EAAAsB,GACA,IACA6G,EAAA,KACAC,KAYA,OAVA9G,EAAAnX,QAAA,SAAAzD,GACA,OAAAyhB,EACAA,EAAAzhB,GAGA0hB,EAAAhjB,MAAmBijB,OAAAF,EAAAG,MAAAnH,WAAAza,KACnByhB,EAAA,QAIAC,EA2BA,SAAAvI,EAAAyB,GACA,OACAiH,OAAAjH,EAAA,GACA9W,OAAA8W,EAAA,IAlTAle,OAAAiE,KAAA+Y,GAAAjW,QAAA,SAAAqe,GACAzX,EAAAlN,UAAA2kB,GAAA,WACA,IAGApf,EAFAqL,EAAA1O,MAAAlC,UAAA4kB,MAAA5lB,KAAAuB,WACA+E,EAAA,KAEAE,GACA8F,WAAA,KACAD,OAAAsZ,GAEA5f,KAwBA,GAtBA6L,EAAApQ,QAAA,mBAAAoQ,IAAApQ,OAAA,KACA+E,EAAAqL,EAAAiU,OAGAtI,EAAAoI,GAAAtlB,QAAAZ,KAAAuF,OAAA8B,iBAAA,iBAAA6e,EAAApf,GAEAgX,EAAAoI,GAAAtlB,SACA0F,EAAAE,SAGAsX,EAAAoI,GAAAjJ,UACAa,EAAAoI,GAAAjJ,SAAApV,QAAA,SAAAwe,GACA,IAAAjiB,EAAA+N,EAAAnF,QAEA,QAAAhL,IAAAoC,EACA,UAAAxB,MAAA,iBAAAsjB,EAAA,wBAAAG,EAAA,KAGAf,EAAAhf,EAAAwX,EAAAoI,GAAAtlB,OAAAylB,EAAAjiB,KAIA+N,EAAApQ,OAAA,EACA,UAAAa,MAAA,iBAAAsjB,EAAA,kCAGA,OAAA/T,EAAApQ,QAAA,iBAAAoQ,EAAA,IAAA1O,MAAA8F,QAAA4I,EAAA,IACA,UAAAvP,MAAA,iBAAAsjB,EAAA,qDAoCA,GAjCA/T,EAAApQ,SACA8E,EAAA/F,OAAAqN,UAAkCgE,EAAA,IAElC1O,MAAA8F,QAAAuU,EAAAoI,GAAA/W,OACA2O,EAAAoI,GAAA/W,KAAAtH,QAAA,SAAA4D,GACA,OAAA5E,EAAA4E,SAAAzJ,IAAA6E,EAAA4E,KACA6Z,EAAAhf,EAAAwX,EAAAoI,GAAAtlB,OAAA6K,EAAA5E,EAAA4E,WACA5E,EAAA4E,OAUA,mBAAAqS,EAAAoI,GAAA/W,MACA2O,EAAAoI,GAAA/W,KAAA7I,EAAAO,OAGA7G,KAAAuF,OAAAwB,QAAAT,EAAAO,EAAAC,GAAA,SAAAxC,EAAA4C,GACA,OAAA5C,EACAwC,EAAAxC,GAGAwZ,EAAAoI,GAAA5I,WACAxW,EAAA,KAAAgX,EAAAoI,GAAA5I,WAAApW,EAAAC,cAGAL,EAAA,KAAAI,EAAAC,WAGA2W,EAAAoI,GAAAtlB,OACA,OAAAZ,QA0OAJ,EAAAD,QAAA8O,mBCpfA7O,EAAAD,QAjBA,SAAAqP,EAAA3E,EAAAxD,GACA,OAAAmI,GACA,gBACA,uBAAAoG,QAAA,oBAAAkR,UACA,UAAA1jB,MAAA,4CAEA,WAAA1C,EAAA,KAAAmK,EAAAxD,GACA,eACA,IAAAuO,OAAAmR,GACA,UAAA3jB,MAAA,0CAEA,WAAA1C,EAAA,KAAAmK,EAAAxD,GACA,QACA,UAAAjE,MAAA,+BAAAoM,EAAA,+UCnBA,IACE5E,EAAYlK,EAAQ,GAElBsmB,SAEEC,cAEJ,SAAAA,EAAYpc,EAAMxD,gGAAS5E,CAAAjC,KAAAymB,GAAA,IAAAnc,mKAAAC,CAAAvK,MAAAymB,EAAAjc,WAAA1J,OAAA2J,eAAAgc,IAAAlmB,KAAAP,KACnBqK,EAAMxD,IADa,OAGzB2f,EAAuC,oBAAdF,UAA4BA,UAAYpmB,GAAQ,eAAAwmB,EAAA,IAAA9jB,MAAA,iCAAA8jB,EAAAC,KAAA,mBAAAD,EAAA,IACzEpc,EAAKsc,OAAS,KACdtc,EAAKuc,QAAU,KALUvc,qUAFRF,wCAaR,IAAA+B,EAAAnM,KAEP8mB,GAAO9mB,KAAK2K,IAAM,SAAW,SAAW3K,KAAKqK,KAAO,IAAMrK,KAAK0K,KAC/DyE,EAAyB,oBAAXiG,YAAyBpT,GAAa+kB,mBAAmB,8PAEzEhW,CAAA0V,EAAAllB,UAAAiJ,WAAA1J,OAAA2J,eAAAgc,EAAAllB,WAAA,UAAAvB,MAAAO,KAAAP,MAEI8mB,IAAQ9mB,KAAK6mB,UACf7mB,KAAK4L,cAAe,EACpB5L,KAAK6mB,QAAUC,GAGjB9mB,KAAK4mB,OAAS,IAAIJ,EAAgBM,EAAK3X,GAEvCnP,KAAK4mB,OAAOI,OAAS,WACnB7a,EAAK8a,mBAGPjnB,KAAK4mB,OAAOM,QAAU,SAACC,EAAYjZ,GACjC,IACEE,SACAgZ,EAASlZ,EAaX,GAX0B,iBAAfiZ,EACT/Y,EAAS+Y,GAGT/Y,EAAS+Y,EAAWR,KAEhBQ,EAAWC,SACbA,EAASD,EAAWC,SAIT,MAAXhZ,EACFjC,EAAKkb,0BAIF,GAAIlb,EAAKP,aAAc,CAC1B,IAAMtE,EAAQ,IAAI1E,MAAMwkB,GACxB9f,EAAM8G,OAASA,EAEfjC,EAAKmb,mBAAmBhgB,KAI5BtH,KAAK4mB,OAAOW,QAAU,SAAAjgB,GACpB,IAAMhD,EAAOgD,aAAiB1E,OAAU0E,GAAS,IAAI1E,MAAM0E,GAE3D6E,EAAKmb,mBAAmBhjB,IAG1BtE,KAAK4mB,OAAOY,UAAY,SAAAhkB,GACtB,IAAM8C,EAAOI,KAAK+gB,MAAMjkB,EAAQ8C,MAAQ9C,GAEpC8C,EAAK4I,KACP/C,EAAKH,KAAK1F,EAAK4I,KAAM5I,GAGrB6F,EAAKH,KAAK,YAAa1F,iCAUvB9C,GACAxD,KAAK4mB,QAAU5mB,KAAK4mB,OAAOc,aAAe1nB,KAAK4mB,OAAOe,MACxD3nB,KAAK4mB,OAAOvY,KAAK3H,KAAKC,UAAUnD,oCAQlCxD,KAAKkL,MAAQ,UACblL,KAAK2N,qBACL3N,KAAK4L,cAAe,EAChB5L,KAAK4mB,QACP5mB,KAAK4mB,OAAOjU,QAEd3S,KAAK4mB,OAAS,KACd5mB,KAAK6L,uBAAwB,WAIjCjM,EAAOD,QAAU8mB,qhBC7GjB,IACErc,EAAYlK,EAAQ,GAEhB0nB,cAEJ,SAAAA,EAAYvd,EAAMxD,gGAAS5E,CAAAjC,KAAA4nB,GAAA,IAAAtd,mKAAAC,CAAAvK,MAAA4nB,EAAApd,WAAA1J,OAAA2J,eAAAmd,IAAArnB,KAAAP,KACnBqK,EAAMxD,IADa,OAGzByD,EAAKud,OAAS,KACdvd,EAAKwd,iBAAkB,EACvBxd,EAAKyd,iBALoBzd,qUAFNF,wCAaX,IAAA+B,EAAAnM,KACR+Q,EAAA6W,EAAArmB,UAAAiJ,WAAA1J,OAAA2J,eAAAmd,EAAArmB,WAAA,UAAAvB,MAAAO,KAAAP,MAEAA,KAAK6nB,OAASzS,OAAOmR,IAAIvmB,KAAK2K,IAAM,WAAa,WAAa3K,KAAKqK,KAAO,IAAMrK,KAAK0K,MACnFsd,aAAchoB,KAAK+K,cACnBD,kBAAmB9K,KAAK8K,kBACxBmd,UAAU,IAGZjoB,KAAK6nB,OAAOva,GAAG,UAAW,kBAAMnB,EAAK8a,oBACrCjnB,KAAK6nB,OAAOva,GAAG,gBAAiB,SAAAhG,GAAA,OAAS6E,EAAKmb,mBAAmBhgB,KAEjEtH,KAAK6nB,OAAOva,GAAG,aAAc,WAC3B,GAAInB,EAAK2b,gBACP3b,EAAKkb,yBACA,CACL,IAAM/f,EAAQ,IAAI1E,MAAM,kDACxB0E,EAAM8G,OAAS,IAEfjC,EAAKmb,mBAAmBhgB,GAG1B6E,EAAK2b,iBAAkB,wCAUf/V,EAAO/B,GAAwB,IAAdnO,EAAcC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAIzC,OAHA9B,KAAKkoB,iBAAiBnW,EAAO/B,EAAUnO,GACvCkP,EAAA6W,EAAArmB,UAAAiJ,WAAA1J,OAAA2J,eAAAmd,EAAArmB,WAAA,cAAAvB,MAAAO,KAAAP,KAAkB+R,EAAO/B,EAAUnO,GAE5B7B,6CAGO+R,EAAO/B,GAAwB,IAAdnO,EAAcC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAE7C,OADA9B,KAAKkoB,iBAAiBnW,EAAO/B,EAAUnO,GACvCkP,EAAA6W,EAAArmB,UAAAiJ,WAAA1J,OAAA2J,eAAAmd,EAAArmB,WAAA,kBAAAvB,MAAAO,KAAAP,KAA6B+R,EAAO/B,EAAUnO,0CASjCkQ,EAAO/B,GAYpB,OAXIhQ,KAAK+nB,cAAchW,KACrB/R,KAAK+nB,cAAchW,GAAO3P,UAAUwE,OAAOoJ,GAEM,IAA7ChQ,KAAK+nB,cAAchW,GAAO3P,UAAUmW,OACtCvY,KAAK6nB,OAAOM,IAAIpW,EAAO/R,KAAK+nB,cAAchW,GAAOqW,gBAC1CpoB,KAAK+nB,cAAchW,IAG5BhB,EAAA6W,EAAArmB,UAAAiJ,WAAA1J,OAAA2J,eAAAmd,EAAArmB,WAAA,iBAAAvB,MAAAO,KAAAP,KAAqB+R,EAAO/B,IAGvBhQ,gDAQU+R,GACjB,QAAc/P,IAAV+P,GACF,QAAkC/P,IAA9BhC,KAAK+nB,cAAchW,GAAsB,KAAApO,GAAA,EAAAC,GAAA,EAAAC,OAAA7B,EAAA,IAC3C,QAAA8B,EAAAC,EAAuB/D,KAAK+nB,cAAchW,GAAO3P,UAAjD4B,OAAAC,cAAAN,GAAAG,EAAAC,EAAAG,QAAAC,MAAAR,GAAA,EAA4D,KAAjDpB,EAAiDuB,EAAAM,MAC1DpE,KAAK8E,eAAeiN,EAAOxP,IAFc,MAAA+B,GAAAV,GAAA,EAAAC,EAAAS,EAAA,aAAAX,GAAAI,EAAAQ,QAAAR,EAAAQ,SAAA,WAAAX,EAAA,MAAAC,SAKxC,KAAAW,GAAA,EAAAC,GAAA,EAAAC,OAAA1C,EAAA,IACL,QAAA2C,EAAAC,EAAqB9D,OAAOiE,KAAK/E,KAAK+nB,eAAtC/jB,OAAAC,cAAAO,GAAAG,EAAAC,EAAAV,QAAAC,MAAAK,GAAA,EAAsD,KAA3C6jB,EAA2C1jB,EAAAP,MACpDpE,KAAK2N,mBAAmB0a,IAFrB,MAAA/jB,GAAAG,GAAA,EAAAC,EAAAJ,EAAA,aAAAE,GAAAI,EAAAL,QAAAK,EAAAL,SAAA,WAAAE,EAAA,MAAAC,IAMP,OAAO1E,kCAQJwD,GACHxD,KAAK6nB,OAAO7b,KAAK,SAAUxI,mCAO3BxD,KAAK8nB,iBAAkB,EACvB9nB,KAAKkL,MAAQ,UACblL,KAAK6nB,OAAOlV,QACZ3S,KAAK6nB,OAAS,8CAGC9V,EAAO/B,GAAwB,IAAA3C,EAAArN,KAAd6B,EAAcC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAC9C,IAAK9B,KAAK+nB,cAAchW,GAAQ,CAC9B,IAAMqW,EAAU,mBAAA7kB,EAAAzB,UAAAC,OAAIoQ,EAAJ1O,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAIyO,EAAJzO,GAAA5B,UAAA4B,GAAA,OAAa2J,EAAKrB,KAAL3H,MAAAgJ,GAAU0E,GAAV/O,OAAoBmP,KAEjDnS,KAAK+nB,cAAchW,IACjBqW,UACAhmB,UAAW,IAAIkmB,MAGkD,KAA9D,UAAW,gBAAiB,cAAcliB,QAAQ2L,KACjDlQ,EACF7B,KAAK6nB,OAAOhmB,KAAKkQ,EAAOqW,GAExBpoB,KAAK6nB,OAAOva,GAAGyE,EAAOqW,IAK5BpoB,KAAK+nB,cAAchW,GAAO3P,UAAUmmB,IAAIvY,YAI5CpQ,EAAOD,QAAUioB","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9e5605a1d579c69f67e7","class Listener {\n  constructor(fn, once = false) {\n    this.fn = fn;\n    this.once = once;\n  }\n}\n\nclass KuzzleEventEmitter {\n  constructor() {\n    this._events = {};\n  }\n\n  _exists (listeners, fn) {\n    return Boolean(listeners.find(listener => listener.fn === fn));\n  }\n\n  listeners (eventName) {\n    if (this._events[eventName] === undefined) {\n      return [];\n    }\n\n    return this._events[eventName].map(listener => listener.fn);\n  }\n\n  addListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    const listenerType = typeof listener;\n\n    if (listenerType !== 'function') {\n      throw new Error(`Invalid listener type: expected a function, got a ${listenerType}`);\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName].push(new Listener(listener, once));\n    }\n\n    return this;\n  }\n\n  on (eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  prependListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n    }\n\n    return this;\n  }\n\n  addOnceListener (eventName, listener) {\n    return this.addListener(eventName, listener, true);\n  }\n\n  once (eventName, listener) {\n    return this.addOnceListener(eventName, listener);\n  }\n\n  prependOnceListener (eventName, listener) {\n    return this.prependListener(eventName, listener, true);\n  }\n\n  removeListener (eventName, listener) {\n    const listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n\n    const index = listeners.findIndex(l => l.fn === listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    return this;\n  }\n\n  removeAllListeners (eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  }\n\n  emit (eventName, ...payload) {\n    const listeners = this._events[eventName];\n\n    if (listeners === undefined) {\n      return false;\n    }\n\n    const onceListeners = [];\n\n    for (const listener of listeners) {\n      listener.fn(...payload);\n\n      if (listener.once) {\n        onceListeners.push(listener.fn);\n      }\n    }\n\n    for (const toDelete of onceListeners) {\n      this.removeListener(eventName, toDelete);\n    }\n\n    return true;\n  }\n\n  eventNames () {\n    return Object.keys(this._events);\n  }\n\n  listenerCount (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  }\n}\n\nmodule.exports = KuzzleEventEmitter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/eventEmitter/index.js","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * Document is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {Collection} collection - an instanciated Collection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @param {object} [meta] - Initializes this document with the provided meta\n * @constructor\n */\nfunction Document(collection, documentId, content, meta) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: collection,\n      enumerable: false\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: false\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    meta: {\n      value: meta || {},\n      enumerable: true,\n      writable: false\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  if (this.version) {\n    data._version = this.version;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.delete: cannot delete a document without a document ID');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n    cb(err, err ? undefined : self.id);\n  });\n};\n\n/**\n * Checks if this document exists in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.exists = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('Document.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n    if (error) {\n      return cb && cb(error);\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function won’t be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\nmodule.exports = Document;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Document.js\n// module id = 1\n// module chunks = 0","function SecurityDocument(Security, id, content, meta) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: Security.kuzzle\n    },\n    Security: {\n      value: Security\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    meta: {\n      value: meta || {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function won’t be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {SecurityDocument} this\n */\nSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {SecurityDocument} this\n */\nSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = SecurityDocument;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/SecurityDocument.js\n// module id = 2\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/uuid/v4.js\n// module id = 3\n// module chunks = 0","var\n  KuzzleSecurityDocument = require('./SecurityDocument');\n\n/**\n * @param {Security} Security\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction User(Security, id, content, meta) {\n  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    },\n    credentials: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: User\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {User} this\n */\nUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * @param {object} credentials\n */\nUser.prototype.setCredentials = function (credentials) {\n  if (typeof credentials !== 'object') {\n    throw new Error('Parameter \"credentials\" must be a object');\n  }\n\n  this.credentials = credentials;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {User} this\n */\nUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Creates this user into Kuzzle\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.create = function (options, cb) {\n  var\n    data = this.creationSerialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n\n/**\n * Replaces the latest version of this user in Kuzzle by the current content of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.replace = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n\n  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content, meta: this.meta};\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.creationSerialize = function () {\n  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array.<string>} the associated profiles IDs\n */\nUser.prototype.getProfileIds = function () {\n  return this.content.profileIds || [];\n};\n\n/**\n * Return the associated Profile objects\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nUser.prototype.getProfiles = function (options, cb) {\n  var \n    self = this,\n    fetchedProfiles = [],\n    errored = false;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\n  if (!self.content.profileIds) {\n    return cb(null, fetchedProfiles);\n  }\n\n  self.content.profileIds.forEach(function (profileId) {\n    self.Security.fetchProfile(profileId, options, function (error, profile) {\n      if (error) {\n        if (errored) {\n          return;\n        }\n\n        errored = true; // prevents multiple callback resolutions\n        return cb(error);\n      }\n\n      fetchedProfiles.push(profile);\n\n      if (fetchedProfiles.length === self.content.profileIds.length) {\n        cb(null, fetchedProfiles);\n      }\n    });\n  });\n};\n\nmodule.exports = User;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/User.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nconst\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('../../../eventEmitter');\n\nclass RTWrapper extends KuzzleEventEmitter {\n\n  constructor (host, options) {\n    super();\n\n    Object.defineProperties(this, {\n      id: {\n        value: uuidv4()\n      },\n      host: {\n        value: host,\n        enumerable: true\n      },\n      port: {\n        value: (options && typeof options.port === 'number') ? options.port : 7512,\n        enumerable: true\n      },\n      ssl: {\n        value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n        enumerable: true\n      },\n      queuing: {\n        value: false,\n        writable: true\n      },\n      reconnectionDelay: {\n        value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n        enumerable: true\n      },\n      // configuration properties\n      autoReconnect: {\n        value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n        enumerable: true\n      },\n      autoQueue: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      autoReplay: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      state: {\n        value: 'offline',\n        enumerable: true,\n        writable: true\n      },\n      /*\n        Offline queue use the following format:\n              [\n                {\n                  ts: <query timestamp>,\n                  query: 'query',\n                  cb: callbackFunction\n                }\n              ]\n       */\n      offlineQueue: {\n        value: [],\n        enumerable: true,\n        writable: true\n      },\n      queueFilter: {\n        value: null,\n        enumerable: true,\n        writable: true\n      },\n      queueMaxSize: {\n        value: 500,\n        enumerable: true,\n        writable: true\n      },\n      queueTTL: {\n        value: 120000,\n        enumerable: true,\n        writable: true\n      },\n      replayInterval: {\n        value: 10,\n        enumerable: true,\n        writable: true\n      },\n      offlineQueueLoader: {\n        value: null,\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      Object.keys(options).forEach(opt => {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      });\n\n      if (options.offlineMode === 'auto' && this.autoReconnect) {\n        this.autoQueue = this.autoReplay = true;\n      }\n    }\n\n    this.wasConnected = false;\n    this.stopRetryingToConnect = false;\n    this.retrying = false;\n  }\n\n  connect() {\n    this.state = 'connecting';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected() {\n    this.state = 'connected';\n    this.emit(this.wasConnected && 'reconnect' || 'connect');\n    this.wasConnected = true;\n    this.stopRetryingToConnect = false;\n\n    if (this.autoQueue) {\n      this.stopQueuing();\n    }\n\n    if (this.autoReplay) {\n      this.playQueue();\n    }\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  clientDisconnected() {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.emit('disconnect');\n  }\n\n  /**\n   * Called when the client's connection is closed with an error state\n   *\n   * @param {Error} error\n   */\n  clientNetworkError(error) {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.emit('networkError', error);\n    if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n      this.retrying = true;\n      setTimeout(() => {\n        this.retrying = false;\n        this.connect(this.host);\n      }, this.reconnectionDelay);\n    } else {\n      this.emit('disconnect');\n    }\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   */\n  flushQueue() {\n    this.offlineQueue = [];\n  }\n\n  /**\n   * Replays the requests queued during offline mode.\n   */\n  playQueue() {\n    if (this.state === 'connected') {\n      cleanQueue(this);\n      dequeue(this);\n    }\n  }\n\n  /**\n   * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  startQueuing() {\n    this.queuing = true;\n  }\n\n  /**\n   * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  stopQueuing() {\n    this.queuing = false;\n  }\n\n  subscribe(object, options, notificationCB, cb) {\n    if (this.state !== 'connected') {\n      return cb(new Error('Not Connected'));\n    }\n    this.query(object, options, (error, response) => {\n      if (error) {\n        return cb(error);\n      }\n      this.on(response.result.channel, data => {\n        data.fromSelf = data.volatile !== undefined && data.volatile.sdkInstanceId === this.id;\n        notificationCB(data);\n      });\n      cb(null, response.result);\n    });\n  }\n\n  unsubscribe(object, channel, cb) {\n    this.removeAllListeners(channel);\n    this.query(object, null, (err, res) => {\n      if (cb) {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  query(object, options, cb) {\n    let queuable = options && (options.queuable !== false) || true;\n\n    if (this.queueFilter) {\n      queuable = queuable && this.queueFilter(object);\n    }\n\n    if (this.queuing && queuable) {\n      cleanQueue(this, object, cb);\n      this.emit('offlineQueuePush', {query: object, cb: cb});\n      return this.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n    }\n\n    if (this.state === 'connected') {\n      return emitRequest(this, object, cb);\n    }\n\n    return discardRequest(object, cb);\n  }\n}\n/**\n * Emit a request to Kuzzle\n *\n * @param {RTWrapper} network\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (network, request, cb) {\n  if (request.jwt !== undefined || cb) {\n    network.once(request.requestId, response => {\n      let error = null;\n\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        network.emit('tokenExpired', request, cb);\n      }\n\n      if (response.error) {\n        error = new Error(response.error.message);\n        Object.assign(error, response.error);\n        error.status = response.status;\n        network.emit('queryError', error, request, cb);\n      }\n\n      if (cb) {\n        cb(error, response);\n      }\n    });\n  }\n  // Track requests made to allow Room.subscribeToSelf to work\n  network.send(request);\n}\n\nfunction discardRequest(object, cb) {\n  if (cb) {\n    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n  }\n}\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n * @param {RTWrapper} network\n */\nfunction cleanQueue (network) {\n  const now = Date.now();\n  let lastDocumentIndex = -1;\n\n  if (network.queueTTL > 0) {\n    network.offlineQueue.forEach((query, index) => {\n      if (query.ts < now - network.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      network.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(droppedRequest => {\n          network.emit('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (network.queueMaxSize > 0 && network.offlineQueue.length > network.queueMaxSize) {\n    network.offlineQueue\n      .splice(0, network.offlineQueue.length - network.queueMaxSize)\n      .forEach(droppedRequest => {\n        network.emit('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue (network) {\n  const\n    uniqueQueue = {},\n    dequeuingProcess = () => {\n      if (network.offlineQueue.length > 0) {\n        emitRequest(network, network.offlineQueue[0].query, network.offlineQueue[0].cb);\n        network.emit('offlineQueuePop', network.offlineQueue.shift());\n\n        setTimeout(() => {\n          dequeuingProcess();\n        }, Math.max(0, network.replayInterval));\n      }\n    };\n\n  if (network.offlineQueueLoader) {\n    if (typeof network.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof network.offlineQueueLoader);\n    }\n\n    const additionalQueue = network.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      network.offlineQueue = additionalQueue\n        .concat(network.offlineQueue)\n        .filter(request => {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\nmodule.exports = RTWrapper;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/abstract/realtime.js","const\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('./eventEmitter'),\n  Collection = require('./Collection.js'),\n  Document = require('./Document.js'),\n  Security = require('./security/Security'),\n  MemoryStorage = require('./MemoryStorage'),\n  User = require('./security/User'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n */\nclass Kuzzle extends KuzzleEventEmitter {\n  constructor(host, options) {\n    super();\n\n    if (!host || host === '') {\n      throw new Error('host argument missing');\n    }\n\n    Object.defineProperties(this, {\n      // 'private' properties\n      eventActions: {\n        value: [\n          'connected',\n          'discarded',\n          'disconnected',\n          'loginAttempt',\n          'networkError',\n          'offlineQueuePush',\n          'offlineQueuePop',\n          'queryError',\n          'reconnected',\n          'tokenExpired'\n        ]\n      },\n      // configuration properties\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true,\n        enumerable: true\n      },\n      defaultIndex: {\n        value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n        writable: true,\n        enumerable: true\n      },\n      jwt: {\n        value: undefined,\n        enumerable: true,\n        writable: true\n      },\n      protocol: {\n        value: (options && typeof options.protocol === 'string') ? options.protocol : 'websocket',\n        enumerable: true\n      },\n      sdkVersion: {\n        value: (typeof SDKVERSION === 'undefined') ? require('../package.json').version : SDKVERSION\n      },\n      volatile: {\n        value: {},\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      for (const opt of Object.keys(options)) {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      }\n    }\n\n    // Forward the subscribe query to the network wrapper\n    Object.defineProperty(this, 'subscribe', {\n      value: function(room, opts, subscribeCB) {\n        const\n          object = {\n            requestId: uuidv4(),\n            controller: 'realtime',\n            action: 'subscribe',\n            index: room.collection.index,\n            collection: room.collection.collection,\n            volatile: this.volatile,\n            body: room.filters,\n            scope: room.scope,\n            state: room.state,\n            users: room.users\n          },\n          notificationCB = data => {\n            if (data.type === 'TokenExpired') {\n              this.unsetJwt();\n              return this.emit('tokenExpired');\n            }\n\n            if (data.type === 'document') {\n              const copy = Object.assign({}, data);\n              copy.document = new Document(room.collection, data.result._id, data.result._source, data.result._meta);\n              delete copy.result;\n              return room.notify(copy);\n            }\n\n            room.notify(data);\n          };\n\n        if (this.jwt !== undefined) {\n          object.jwt = this.jwt;\n        }\n\n        Object.assign(object.volatile, room.volatile, {sdkInstanceId: this.network.id, sdkVersion: this.sdkVersion});\n\n        this.network.subscribe(object, opts, notificationCB, subscribeCB);\n      }\n    });\n\n    // Forward the unsubscribe query to the network wrapper\n    Object.defineProperty(this, 'unsubscribe', {\n      value: (room, unsubscribeCB) => {\n        const\n          object = {\n            requestId: uuidv4(),\n            controller: 'realtime',\n            action: 'unsubscribe',\n            volatile: this.volatile,\n            body: {roomId: room.roomId}\n          };\n\n        if (this.jwt !== undefined) {\n          object.jwt = this.jwt;\n        }\n\n        Object.assign(object.volatile, room.volatile, {sdkInstanceId: this.network.id, sdkVersion: this.sdkVersion});\n\n        this.network.unsubscribe(object, room.channel, unsubscribeCB);\n      }\n    });\n\n    /**\n     * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n     * and is called by these methods\n     */\n    Object.defineProperty(this, 'callbackRequired', {\n      value: (errorMessagePrefix, callback) => {\n        if (!callback || typeof callback !== 'function') {\n          throw new Error(`${errorMessagePrefix}: a callback argument is required for read queries`);\n        }\n      }\n    });\n\n    /**\n     * Create an attribute security that embed all methods to manage Role, Profile and User\n     */\n    Object.defineProperty(this, 'security', {\n      value: new Security(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'memoryStorage', {\n      value: new MemoryStorage(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'collections',{\n      value: {},\n      writable: true\n    });\n\n    Object.defineProperty(this, 'eventTimeout',{\n      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200\n    });\n\n    Object.defineProperty(this, 'protectedEvents', {\n      value: {\n        connected: {timeout: this.eventTimeout},\n        error: {timeout: this.eventTimeout},\n        disconnected: {timeout: this.eventTimeout},\n        reconnected: {timeout: this.eventTimeout},\n        tokenExpired: {timeout: this.eventTimeout},\n        loginAttempt: {timeout: this.eventTimeout}\n      }\n    });\n\n    this.network = networkWrapper(this.protocol, host, options);\n\n    // Properties related to the network layer\n    // Accessing a property irrelevant for a given protocol\n    // (e.g. \"autoReconnect\" for the HTTP layer) should\n    // throw an exception\n    Object.defineProperties(this, {\n      autoQueue: {\n        enumerable: true,\n        get: () => this.network.autoQueue,\n        set: value => {\n          checkPropertyType('autoQueue', 'boolean', value);\n          this.network.autoQueue = value;\n        }\n      },\n      autoReconnect: {\n        enumerable: true,\n        get: () => this.network.autoReconnect\n      },\n      autoReplay: {\n        enumerable: true,\n        get: () => this.network.autoReplay,\n        set: value => {\n          checkPropertyType('autoReplay', 'boolean', value);\n          this.network.autoReplay = value;\n        }\n      },\n      host: {\n        enumerable: true,\n        get: () => this.network.host\n      },\n      offlineQueue: {\n        enumerable: true,\n        get: () => this.network.offlineQueue\n      },\n      offlineQueueLoader: {\n        enumerable: true,\n        get: () => this.network.offlineQueueLoader,\n        set: value => {\n          if (value !== null) {\n            checkPropertyType('offlineQueueLoader', 'function', value);\n          }\n          this.network.offlineQueueLoader = value;\n        }\n      },\n      port: {\n        enumerable: true,\n        get: () => this.network.port\n      },\n      queueFilter: {\n        enumerable: true,\n        get: () => this.network.queueFilter,\n        set: value => {\n          checkPropertyType('queueFilter', 'function', value);\n          this.network.queueFilter = value;\n        }\n      },\n      queueMaxSize: {\n        enumerable: true,\n        get: () => this.network.queueMaxSize,\n        set: value => {\n          checkPropertyType('queueMaxSize', 'number', value);\n          this.network.queueMaxSize = value;\n        }\n      },\n      queueTTL: {\n        enumerable: true,\n        get: () => this.network.queueTTL,\n        set: value => {\n          checkPropertyType('queueTTL', 'number', value);\n          this.network.queueTTL = value;\n        }\n      },\n      replayInterval: {\n        enumerable: true,\n        get: () => this.network.replayInterval,\n        set: value => {\n          checkPropertyType('replayInterval', 'number', value);\n          this.network.replayInterval = value;\n        }\n      },\n      reconnectionDelay: {\n        enumerable: true,\n        get: () => this.network.reconnectionDelay\n      },\n      sslConnection: {\n        eumerable: true,\n        get: () => this.network.ssl\n      }\n    });\n\n    this.network.addListener('offlineQueuePush', data => this.emit('offlineQueuePush', data));\n    this.network.addListener('offlineQueuePop', data => this.emit('offlineQueuePop', data));\n    this.network.addListener('queryError', (err, query) => this.emit('queryError', err, query));\n\n    this.network.addListener('tokenExpired', () => {\n      this.unsetJwt();\n      this.emit('tokenExpired');\n    });\n\n    if (this.bluebird) {\n      return this.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: function (name, func, target, passes) {\n          const whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n            'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n            'checkToken', 'whoAmI', 'updateSelf', 'getMyRights', 'getMyCredentials',\n            'createMyCredentials', 'deleteMyCredentials', 'updateMyCredentials', 'validateMyCredentials',\n            'createIndex', 'refreshIndex', 'getAutoRefresh', 'setAutoRefresh', 'connect'\n          ];\n\n          return passes && whitelist.indexOf(name) !== -1;\n        }\n      });\n    }\n  }\n\n  /**\n  * Emit an event to all registered listeners\n  * An event cannot be emitted multiple times before a timeout has been reached.\n  */\n  emit (eventName, ...payload) {\n    const\n      now = Date.now(),\n      protectedEvent = this.protectedEvents[eventName];\n\n    if (protectedEvent) {\n      if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n        return false;\n      }\n      protectedEvent.lastEmitted = now;\n    }\n\n    super.emit(eventName, ...payload);\n  }\n\n\n  /**\n   * Connects to a Kuzzle instance using the provided host name\n   * @param {function} [cb] Connection callback\n   */\n  connect (cb) {\n    if (this.network.state !== 'offline') {\n      if (cb) {\n        cb(null, this);\n      }\n      return;\n    }\n\n    this.network.connect();\n\n    this.network.addListener('connect', () => {\n      this.emit('connected');\n\n      if (cb) {\n        cb(null, this);\n      }\n    });\n\n    this.network.addListener('networkError', error => {\n      const connectionError = new Error(`Unable to connect to kuzzle proxy server at ${this.network.host}:${this.network.port}`);\n\n      connectionError.internal = error;\n      this.emit('networkError', connectionError);\n\n      if (cb) {\n        cb(connectionError);\n      }\n    });\n\n    this.network.addListener('disconnect', () => {\n      this.disconnect();\n      this.emit('disconnected');\n    });\n\n    this.network.addListener('reconnect', () => {\n      if (this.jwt) {\n        this.checkToken(this.jwt, (err, res) => {\n          // shouldn't obtain an error but let's invalidate the token anyway\n          if (err || !res.valid) {\n            this.unsetJwt();\n          }\n\n          this.emit('reconnected');\n        });\n      } else {\n        this.emit('reconnected');\n      }\n    });\n\n    this.network.on('discarded', data => this.emit('discarded', data));\n  }\n\n  /**\n   * Set the jwt used to query kuzzle\n   * @param token\n   * @returns {Kuzzle}\n   */\n  setJwt (token) {\n    if (typeof token === 'string') {\n      this.jwt = token;\n    } else if (typeof token === 'object') {\n      if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n        this.jwt = token.result.jwt;\n      } else {\n        this.emit('loginAttempt', {\n          success: false,\n          error: 'Cannot find a valid JWT in the following object: ' + JSON.stringify(token)\n        });\n\n        return this;\n      }\n    } else {\n      this.emit('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n      return this;\n    }\n\n    this.emit('loginAttempt', {success: true});\n    return this;\n  }\n\n  /**\n   * Unset the jwt used to query kuzzle\n   * @returns {Kuzzle}\n   */\n  unsetJwt () {\n    this.jwt = undefined;\n    return this;\n  }\n\n  /**\n   * Get the jwt used by kuzzle\n   * @returns {Kuzzle}\n   */\n  getJwt () {\n    return this.jwt;\n  }\n\n  /**\n   * Send login request to kuzzle with credentials\n   * If login success, store the jwt into kuzzle object\n   *\n   * @param strategy\n   * @param credentials\n   * @param expiresIn\n   * @param cb\n   */\n  login (strategy, ...args) {\n    if (!strategy || typeof strategy !== 'string') {\n      throw new Error('Kuzzle.login: strategy required');\n    }\n\n    const \n      request = {\n        strategy,\n        body: {}\n      };\n\n    let cb = null;\n\n    // Handle arguments (credentials, expiresIn, cb)\n    if (args[0]) {\n      if (typeof args[0] === 'object') {\n        request.body = args[0];\n      } else if (typeof args[0] === 'number' || typeof args[0] === 'string') {\n        request.expiresIn = args[0];\n      } else if (typeof args[0] === 'function') {\n        cb = args[0];\n      }\n    }\n    if (args[1]) {\n      if (typeof args[1] === 'number' || typeof args[1] === 'string') {\n        request.expiresIn = args[1];\n      } else if (typeof args[1] === 'function') {\n        cb = args[1];\n      }\n    }\n    if (args[2] && typeof args[2] === 'function') {\n      cb = args[2];\n    }\n\n    this.query({controller: 'auth', action: 'login'}, request, {queuable: false}, (error, response) => {\n      if (!error) {\n        if (response.result.jwt) {\n          this.setJwt(response.result.jwt);\n        }\n\n        cb && cb(null, response.result);\n      }\n      else {\n        cb && cb(error);\n        this.emit('loginAttempt', {success: false, error: error.message});\n      }\n    });\n  }\n\n  /**\n   * Create credentials of the specified <strategy> for the current user.\n   *\n   * @param credentials\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  createMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'createMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result._source);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Delete credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  deleteMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'deleteMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Get credential information of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   */\n  getMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'getMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Update credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentals\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  updateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Validate credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentials\n   * @param options\n   * @param cb\n   */\n  validateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'validateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Create a kuzzle index\n   *\n   * @param {string} index\n   * @param {object} [options]\n   * @param {responseCallback} cb\n   * @returns {Kuzzle}\n   */\n  createIndex (index, options, cb) {\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.createIndex: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'index', action: 'create', index}, {}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Send logout request to kuzzle with jwt.\n   *\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  logout (cb) {\n    const\n      request = {\n        action: 'logout',\n        controller: 'auth',\n        requestId: uuidv4(),\n        body: {}\n      };\n\n    this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, error => {\n      if (typeof cb === 'function') {\n        cb(error, this);\n      }\n    });\n\n    return this.unsetJwt();\n  }\n\n  /**\n   * Checks whether a given jwt token still represents a valid session in Kuzzle.\n   *\n   * @param  {string}   token     The jwt token to check\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  checkToken (token, cb) {\n    const\n      request = {\n        body: {\n          token\n        }\n      };\n\n    this.callbackRequired('Kuzzle.checkToken', cb);\n\n    this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, (err, res) => {\n      cb(err, err ? undefined : res.result);\n    });\n  }\n\n  /**\n   * Fetches the current user.\n   *\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  whoAmI (cb) {\n    this.callbackRequired('Kuzzle.whoAmI', cb);\n\n    this.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, (err, res) => {\n      cb(err, err ? undefined : new User(this.security, res.result._id, res.result._source, res.result._meta));\n    });\n  }\n\n  /**\n   * Gets the rights array of the currently logged user.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param  {function} cb The callback containing the normalized array of rights.\n   */\n  getMyRights (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getMyRights', cb);\n\n    this.query({controller: 'auth', action:'getMyRights'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Update current user in Kuzzle.\n   *\n   * @param {object} content - a plain javascript object representing the user's modification\n   * @param {object} [options] - (optional) arguments\n   * @param {responseCallback} [cb] - (optional) Handles the query response\n   * @returns {Kuzzle} this object\n   */\n  updateSelf (content, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateSelf'}, {body: content}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n   * insertion.\n   *\n   * @param {string} event - name of the global event to subscribe to\n   * @param {function} listener - callback to invoke each time an event is fired\n   */\n  addListener (event, listener) {\n    if (this.eventActions.indexOf(event) === -1) {\n      throw new Error(`[${event}] is not a known event. Known events: ${this.eventActions.toString()}`);\n    }\n\n    return super.addListener(event, listener);\n  }\n\n  /**\n   * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n   * This method returns all available statistics from Kuzzle.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getAllStatistics (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n    this.query({controller:'server', action: 'getAllStats'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n   * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n   *\n   * @param {number} startTime -  Epoch time. Starting time from which the frames are to be retrieved\n   * @param {number} stopTime -  Epoch time. End time from which the frames are to be retrieved\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getStatistics (...args) {\n    let\n      startTime,\n      stopTime,\n      options,\n      cb;\n\n    switch (args.length) {\n      case 1:\n        cb = args[0];\n        startTime = null;\n        stopTime = null;\n        options = null;\n        break;\n      case 2:\n        if (typeof args[0] === 'object') {\n          [options, cb] = args;\n        } else {\n          [startTime, cb] = args;\n        }\n        break;\n      case 3:\n        if (typeof args[1] === 'object') {\n          [startTime, options, cb] = args;\n        } else {\n          [startTime, stopTime, cb] = args;\n        }\n        break;\n      case 4:\n        [startTime, stopTime, options, cb] = args;\n        break;\n      default:\n        throw new Error('Bad arguments list. Usage: kuzzle.getStatistics([startTime,] [stopTime,] [options,] callback)');\n    }\n\n    this.callbackRequired('Kuzzle.getStatistics', cb);\n\n    const queryCB = (err, res) => {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, startTime ? res.result.hits : [res.result]);\n    };\n\n    let query = {};\n    if (startTime) {\n      query = stopTime ? {startTime, stopTime} : {startTime};\n    }\n\n    this.query({controller: 'server', action: startTime ? 'getStats' : 'getLastStats'}, query, options, queryCB);\n  }\n\n  /**\n   * Create a new instance of a Collection object.\n   * If no index is specified, takes the default index.\n   *\n   * @param {string} collection - The name of the data collection you want to manipulate\n   * @param {string} [index] - The name of the data index containing the data collection\n   * @returns {Collection} A Collection instance\n   */\n  collection (collection, index) {\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Unable to create a new data collection object: no index specified');\n      }\n\n      index = this.defaultIndex;\n    }\n\n    if (typeof index !== 'string' || typeof collection !== 'string') {\n      throw new Error('Invalid index or collection argument: string expected');\n    }\n\n    if (!this.collections[index]) {\n      this.collections[index] = {};\n    }\n\n    if (!this.collections[index][collection]) {\n      this.collections[index][collection] = new Collection(this, collection, index);\n    }\n\n    return this.collections[index][collection];\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   *\n   * @returns {Kuzzle}\n   */\n  flushQueue () {\n    this.network.flushQueue();\n    return this;\n  }\n\n  /**\n   * Returns the list of known persisted data collections.\n   *\n   * @param {string} [index] - Index containing collections to be listed\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  listCollections (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.listCollections: index required');\n      }\n\n      index = this.defaultIndex;\n    }\n\n    this.callbackRequired('Kuzzle.listCollections', cb);\n\n    const query = {type: options && options.type || 'all'};\n\n    this.query({index, controller: 'collection', action: 'list'}, query, options, (err, res) => {\n      cb(err, err ? undefined : res.result.collections);\n    });\n  }\n\n  /**\n   * Returns the list of existing indexes in Kuzzle\n   *\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  listIndexes (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.listIndexes', cb);\n\n    this.query({controller: 'index', action: 'list'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.indexes);\n    });\n  }\n\n  /**\n   * Disconnects from Kuzzle and invalidate this instance.\n   */\n  disconnect () {\n    this.network.close();\n\n    for (const collection of Object.keys(this.collections)) {\n      delete this.collections[collection];\n    }\n  }\n\n  /**\n   * Returns the server informations\n   *\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getServerInfo (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n    this.query({controller: 'server', action: 'info'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.serverInfo);\n    });\n  }\n\n  /**\n   * Forces an index refresh\n   *\n   * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n   * @param {object} options - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   * @returns {Kuzzle}\n   */\n  refreshIndex (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.refreshIndex: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    this.query({index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Returns de current autoRefresh status for the given index\n   *\n   * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n   * @param {object} options - Optinal arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getAutoRefresh (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.getAutoRefresh: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n    this.query({index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n  }\n\n  /**\n   * (Un)Sets the autoRefresh flag on the given index\n   *\n   * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n   * @param {boolean} autoRefresh - The autoRefresh value to set\n   * @param {object} options - Optional arguments\n   * @param {responseCallback} cb - Handles the query result\n   * @returns {object} this\n   */\n  setAutoRefresh (...args) {\n    var\n      index,\n      autoRefresh,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'boolean':\n          autoRefresh = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.setAutoRefresh: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    if (autoRefresh === undefined) {\n      throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n    }\n\n    this.query({index, controller: 'index', action: 'setAutoRefresh'}, {body: {autoRefresh}}, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Return the current Kuzzle's UTC Epoch time, in milliseconds\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  now (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.now', cb);\n\n    this.query({controller: 'server', action: 'now'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.now);\n    });\n  }\n\n  /**\n   * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n   * Base method used to send read queries to Kuzzle\n   *\n   * Takes an optional argument object with the following properties:\n   *    - volatile (object, default: null):\n   *        Additional information passed to notifications to other users\n   *\n   * @param {object} queryArgs - Query configuration\n   * @param {object} query - The query data\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} [cb] - Handles the query response\n   */\n  query (queryArgs, query, options, cb) {\n    const\n      object = {\n        action: queryArgs.action,\n        controller: queryArgs.controller,\n        volatile: this.volatile\n      };\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    } else if (!cb && !options && typeof query === 'function') {\n      cb = query;\n      query = {};\n      options = null;\n    }\n\n    if (options) {\n      for (const prop of ['refresh', 'from', 'size', 'scroll', 'scrollId']) {\n        if (options[prop] !== undefined) {\n          object[prop] = options[prop];\n        }\n      }\n\n      if (options.volatile && typeof options.volatile === 'object') {\n        Object.assign(object.volatile, options.volatile);\n      }\n    }\n\n    if (!query || typeof query !== 'object' || Array.isArray(query)) {\n      throw new Error('Invalid query parameter: ' + query);\n    }\n\n    Object.assign(object.volatile, query.volatile, {sdkInstanceId: this.network.id, sdkVersion: this.sdkVersion});\n\n    for (const attr of Object.keys(query)) {\n      if (attr !== 'volatile') {\n        object[attr] = query[attr];\n      }\n    }\n\n    /*\n     * Do not add the token for the checkToken route, to avoid getting a token error when\n     * a developer simply wish to verify his token\n     */\n    if (this.jwt !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n      object.jwt = this.jwt;\n    }\n\n    if (queryArgs.collection) {\n      object.collection = queryArgs.collection;\n    }\n\n    if (queryArgs.index) {\n      object.index = queryArgs.index;\n    }\n\n    if (!object.requestId) {\n      object.requestId = uuidv4();\n    }\n\n    this.network.query(object, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Starts the requests queuing.\n   */\n  startQueuing () {\n    this.network.startQueuing();\n    return this;\n  }\n\n  /**\n   * Stops the requests queuing.\n   */\n  stopQueuing () {\n    this.network.stopQueuing();\n    return this;\n  }\n\n  /**\n   * @DEPRECATED\n   * See Kuzzle.prototype.playQueue();\n   */\n  replayQueue () {\n    return this.playQueue();\n  }\n\n  /**\n   * Plays the requests queued during offline mode.\n   */\n  playQueue () {\n    this.network.playQueue();\n    return this;\n  }\n\n  /**\n   * Sets the default Kuzzle index\n   *\n   * @param index\n   * @returns this\n   */\n  setDefaultIndex (index) {\n    if (typeof index !== 'string') {\n      throw new Error(`Invalid default index: [${index}] (an index name is expected)`);\n    }\n\n    if (index.length === 0) {\n      throw new Error('Cannot set an empty index as the default index');\n    }\n\n    this.defaultIndex = index;\n\n    return this;\n  }\n}\n\nfunction checkPropertyType(prop, typestr, value) {\n  const wrongType = typestr === 'array' ? !Array.isArray(value) : typeof value !== typestr;\n\n  if (wrongType) {\n    throw new Error(`Can only assign a ${typestr} value to property \"${prop}\"`);\n  }\n}\n\nmodule.exports = Kuzzle;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kuzzle.js","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/uuid/lib/rng-browser.js\n// module id = 7\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/uuid/lib/bytesToUuid.js\n// module id = 8\n// module chunks = 0","var\n  KuzzleSearchResult = require('./SearchResult'),\n  Document = require('./Document'),\n  CollectionMapping = require('./CollectionMapping'),\n  Room = require('./Room');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n *\n * @property {string} collection\n * @property {string} index\n * @property {Kuzzle} kuzzle\n * @property {Array.<string>} collection\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} collection - name of the data collection to handle\n * @param {string} index - Index containing the data collection\n * @constructor\n */\nfunction Collection(kuzzle, collection, index) {\n  if (!index || !collection) {\n    throw new Error('The Collection object constructor needs an index and a collection arguments');\n  }\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.count = function (filters, options, cb) {\n  var query = {body: filters};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.count', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n    cb(err, err ? undefined : res.result.count);\n  });\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.create = function (options, cb) {\n  var data = {},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n *        If the same document already exists:\n *          - resolves with an error if set to \"error\".\n *          - replaces the existing document if set to \"replace\"\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a Document object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options && options.ifExist) {\n    if (options.ifExist === 'replace') {\n      action = 'createOrReplace';\n    }\n    else if (options.ifExist !== 'error') {\n      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n    }\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    var doc;\n\n    if (err) {\n      return cb(err);\n    }\n\n    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n    doc.version = res.result._version;\n    cb(null, doc);\n  });\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Collection} this\n */\nCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = {query: arg};\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    if (err) {\n      cb(err);\n    }\n    else {\n      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n    }\n  });\n\n  return this;\n};\n\n/**\n * Deletes the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.deleteSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Returns a boolean indicating whether or not a document with provided ID exists.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} options [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.documentExists = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.fetch', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n};\n\n/**\n * Instantiates a CollectionMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\n  kuzzleMapping = new CollectionMapping(this);\n  kuzzleMapping.refresh(options, cb);\n};\n\n/**\n * Create the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Create or replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create or replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Delete specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to delete\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Get specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Update the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to update\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Retrieves the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.getSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a Document instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\n\nCollection.prototype.search = function (filters, options, cb) {\n  var\n    query = {body: filters},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.search', cb);\n\n  self.kuzzle.query(self.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n    if (error) {\n      return cb(error);\n    }\n\n    cb(null, new KuzzleSearchResult(self, filters, options, result));\n  });\n};\n\n/**\n * A \"scroll\" option can be passed to search queries, creating persistent\n * paginated results.\n * This method can be used to manually get the next page of a search result,\n * instead of using KuzzleSearchResult.next()\n *\n * @param {string} scrollId\n * @param {object} [options]\n * @param {object} [filters]\n * @param {responseCallback} cb\n */\nCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Collection.scroll: scrollId is required');\n  }\n\n  if (!cb) {\n    cb = filters;\n    filters = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\n  request.scrollId = scrollId;\n\n  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n    if (error) {\n      return cb(error);\n    }\n\n    cb(null, new KuzzleSearchResult(self, filters, options, result));\n  });\n};\n\n/**\n * Retrieves next result of a search with scroll query.\n *\n * @param {string} scrollId\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n  var\n    data = { scrollId: scrollId };\n\n  if (!scrollId) {\n    throw new Error('Collection.scrollSpecifications: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\n  this.kuzzle.query(\n    { controller: 'collection', action: 'scrollSpecifications'},\n    data,\n    options,\n    function (err, res) {\n      cb (err, err ? undefined : res.result);\n    }\n  );\n};\n\n/**\n * Searches specifications across indexes/collections according to the provided filters\n *\n * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.searchSpecifications = function (filters, options, cb) {\n  var\n    data = { body: { query: filters } },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\n  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Create a subscription room to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @returns {*} KuzzleRoom object\n */\nCollection.prototype.room = function (filters, options) {\n  return new Room(this, filters, options);\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} notificationCB - called for each new notification\n * @returns {*} KuzzleRoom object\n */\nCollection.prototype.subscribe = function (filters, options, notificationCB) {\n  var\n    evtName,\n    room;\n\n  if (!notificationCB && typeof options === 'function') {\n    notificationCB = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.subscribe', notificationCB);\n\n  evtName = (options && options.users && options.users !== 'none') ? 'user' : 'document';\n  room = new Room(this, filters, options);\n\n  room.subscribe().on(evtName, notificationCB);\n  return room;\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options && options.retryOnConflict) {\n    data.retryOnConflict = options.retryOnConflict;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    (new Document(self, res.result._id)).refresh(cb);\n  });\n\n  return self;\n};\n\n/**\n * Updates the current specifications of this collection\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Validates the provided specifications\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result.valid);\n  });\n};\n\n/**\n * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nCollection.prototype.document = function (id, content) {\n  return new Document(this, id, content);\n};\n\n/**\n * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n * @constructor\n */\nCollection.prototype.collectionMapping = function (mapping) {\n  return new CollectionMapping(this, mapping);\n};\n\nmodule.exports = Collection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Collection.js\n// module id = 9\n// module chunks = 0","const Document = require('./Document');\n\n/**\n * @param {Collection} collection\n * @param {object} filters\n * @param {object} options\n * @param {object} raw \n * @property {Collection} collection\n * @property {number} total\n * @property {Document[]} documents\n * @property {object} aggregations\n * @property {object} options\n * @property {object} filters\n * @property {number} fetched\n * @constructor\n */\nclass SearchResult {\n  constructor (collection, filters, options, raw) {\n    Object.defineProperties(this, {\n      // read-only properties\n      collection: {\n        value: collection,\n        enumerable: true\n      },\n      total: {\n        value: raw.result.total,\n        enumerable: true\n      },\n      documents: {\n        value: raw.result.hits.map(doc => {\n          const d = new Document(collection, doc._id, doc._source, doc._meta);\n          d.version = doc._version;\n          return d;\n        }),\n        enumerable: true\n      },\n      aggregations: {\n        value: raw.result.aggregations || {},\n        enumerable: true\n      },\n      options: {\n        value: {\n          from: options.from,\n          size: options.size,\n          scrollId: raw.result._scroll_id\n        },\n        enumerable: true\n      },\n      filters: {\n        value: filters || {},\n        enumerable: true\n      },\n      // writable properties\n      fetched: {\n        value: raw.result.hits.length,\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    Object.freeze(this.filters);\n    Object.freeze(this.options);\n    Object.freeze(this.aggregations);\n\n    // promisifying\n    if (this.collection.kuzzle.bluebird) {\n      const whitelist = ['fetchNext'];\n\n      return this.collection.kuzzle.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: (name, func, target, passes) => passes && whitelist.includes(name)\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {function} cb\n   */\n  fetchNext (cb) {\n    const updateAfterSearch = (error, result) => {\n      if (error) {\n        return cb(error);\n      }\n\n      result.fetched += this.fetched;\n      cb(null, result);\n    };\n    \n    this.collection.kuzzle.callbackRequired('SearchResult.fetchNext', cb);\n\n    if (this.fetched >= this.total) {\n      return cb(null, null);\n    }\n\n    // retrieve next results with scroll if original search use it\n    if (this.options.scrollId) {\n      this.collection.scroll(this.options.scrollId, null, this.filters || {}, updateAfterSearch);\n      return;\n    }\n\n    // retrieve next results using ES's search_after\n    if (this.options.size !== undefined && this.filters.sort) {\n      const \n        filters = Object.assign({}, this.filters, {search_after: []}),\n        lastDocumentContent = this.documents[this.documents.length - 1].content;\n\n      for (const sortRule of filters.sort) {\n        if (typeof sortRule === 'string') {\n          filters.search_after.push(lastDocumentContent[sortRule]);\n        } else {\n          filters.search_after.push(lastDocumentContent[Object.keys(sortRule)[0]]);\n        }\n      }\n\n      this.collection.search(filters, {size: this.options.size}, updateAfterSearch);\n      return;\n    }\n\n    // retrieve next results with from/size if original search use it\n    if (this.options.from !== undefined && this.options.size !== undefined) {\n      // check if we need to do next request to fetch all matching documents\n      const opts = {\n        from: this.options.from + this.options.size,\n        size: this.options.size\n      };\n\n      if (opts.from >= this.total) {\n        return cb(null, null);\n      }\n\n      this.collection.search(this.filters, opts, updateAfterSearch);\n      return;\n    }\n\n    cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n  }\n}\n\nmodule.exports = SearchResult;\n\n\n\n// WEBPACK FOOTER //\n// ./src/SearchResult.js","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you won’t be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} collection - Instance of the inherited Collection object\n * @param {object} [mapping] - mappings\n * @constructor\n */\nfunction CollectionMapping(collection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nCollectionMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = {\n      body: {\n        properties: this.mapping\n      }\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the “apply” function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nCollectionMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n      }\n    } else {\n      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function won’t be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {CollectionMapping}\n */\nCollectionMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\nmodule.exports = CollectionMapping;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CollectionMapping.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nconst\n  KuzzleEventEmitter = require('./eventEmitter');\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you don’t exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then you’ll receive a notification about it.\n *\n */\nclass Room extends KuzzleEventEmitter {\n  /*\n   * @constructor\n   * @param {object} collection - an instantiated and valid kuzzle object\n   * @param {object} [filters] - Filters in Kuzzle DSL format\n   * @param {object} [options] - subscription optional configuration\n   */\n  constructor(collection, filters, options) {\n    super();\n\n    let _roomId = null;\n\n    // Define properties\n    Object.defineProperties(this, {\n      // private properties\n      roomstate: {\n        // Values can be: inactive, subscribing, active\n        value: 'inactive',\n        writable: true\n      },\n      kuzzle: {\n        value: collection.kuzzle\n      },\n      isListening: {\n        value: false,\n        writable: true\n      },\n      //listeners\n      resubscribe: {\n        value: () => {\n          this.roomstate = 'inactive';\n          this.error = null;\n          this.subscribe();\n        }\n      },\n      deactivate: {\n        value: () => {\n          this.roomstate = 'inactive';\n        }\n      },\n      resubscribeConditional: {\n        value: () => {\n          this.roomstate = 'inactive';\n          \n          if (this.autoResubscribe) {\n            this.subscribe();\n          }\n        }\n      },\n      //enumerables\n      channel: {\n        value: null,\n        writable: true,\n        enumerable: true\n      },\n      scope: {\n        value: options && options.scope ? options.scope : 'all',\n        enumerable: true\n      },\n      state: {\n        value: options && options.state ? options.state : 'done',\n        enumerable: true\n      },\n      users: {\n        value: options && options.users ? options.users : 'none',\n        enumerable: true\n      },\n      // read-only properties\n      collection: {\n        value: collection,\n        enumerable: true\n      },\n      filters: {\n        value: filters ? filters : {},\n        enumerable: true,\n      },\n      roomId: {\n        enumerable: true,\n        get: () => _roomId,\n        set: value => {\n          if (!_roomId) {\n            _roomId = value;\n          }\n        }\n      },\n      // writable properties\n      volatile: {\n        value: (options && options.volatile) ? options.volatile : {},\n        enumerable: true,\n        writable: true\n      },\n      subscribeToSelf: {\n        value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n        enumerable: true,\n        writable: true\n      },\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : collection.kuzzle.autoResubscribe,\n        enumerable: true\n      }\n    });\n\n    if (this.kuzzle.bluebird) {\n      return this.kuzzle.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: function (name, func, target, passes) {\n          const whitelist = ['count', 'subscribe', 'unsubscribe', 'onDone'];\n\n          return passes && whitelist.indexOf(name) !== -1;\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the number of other subscriptions on that room.\n   *\n   * @param {responseCallback} cb - Handles the query response\n   */\n  count(cb) {\n    this.kuzzle.callbackRequired('Room.count', cb);\n\n    const data = {body: {roomId: this.roomId}};\n\n    if (this.roomstate !== 'active') {\n      return cb(new Error('Cannot count subscriptions on an non-active room'));\n    }\n\n    this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n      cb(err, res && res.result.count);\n    });\n  }\n\n  /**\n   * Subscribes to Kuzzle \n   * (do nothing if a subscription is active or underway)\n   * \n   * @param options\n   * @param {responseCallback} cb - called when the subscription is ready.\n   * @return {*} this\n   */\n  subscribe(options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    if (cb) {\n      this.onDone(cb);\n    }\n\n    // If the room subscription is active, just call the callback.\n    if (this.roomstate === 'active') {\n      this.emit('done', null, this);\n      return this;\n    }\n\n    // If the room is already subscribing, wait for its activation.\n    if (this.roomstate === 'subscribing') {\n      return this;\n    }\n\n    // If the room is still inactive, start the subscription.\n    this.error = null;\n    this.roomstate = 'subscribing';\n\n    this.kuzzle.subscribe(this, options, (error, result) => {\n      if (error) {\n        if (error.message === 'Not Connected') {\n          return this.kuzzle.once('connected', this.resubscribe);\n        }\n\n        this.roomstate = 'inactive';\n        this.error = new Error('Error during Kuzzle subscription: ' + error.message);\n        this.emit('done', this.error);\n        return null;\n      }\n\n      this.roomId = result.roomId;\n      this.channel = result.channel;\n      this.roomstate = 'active';\n\n      if (!this.isListening) {\n        this.kuzzle.addListener('disconnected', this.deactivate);\n        this.kuzzle.addListener('tokenExpired', this.deactivate);\n        this.kuzzle.addListener('reconnected', this.resubscribeConditional);\n        this.isListening = true;\n      }\n\n      this.emit('done', null, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Unsubscribes from Kuzzle.\n   *\n   * Stop listening immediately.\n   * @param {responseCallback} cb - Handles the query response\n   * @return {*} this\n   */\n  unsubscribe(cb) {\n    if (this.roomstate === 'subscribing') {\n      if (cb) {\n        cb(new Error('Cannot unsubscribe a room while a subscription attempt is underway'));\n      }\n\n      return this;\n    }\n\n    if (this.isListening) {\n      this.kuzzle.removeListener('disconnected', this.deactivate);\n      this.kuzzle.removeListener('tokenExpired', this.deactivate);\n      this.kuzzle.removeListener('reconnected', this.resubscribeConditional);\n      this.isListening = false;\n    }\n\n    if (this.roomstate === 'active') {\n      this.kuzzle.unsubscribe(this, cb);\n    }\n    else if (cb) {\n      cb(null, this.roomId);\n    }\n\n    this.roomstate = 'inactive';\n\n    return this;\n  }\n\n  /**\n   * Notify listeners\n   *\n   * @param {Object} data - data to send. Must contain `data.type` as eventName.\n   * @return {*} this\n   */\n  notify(data) {\n    if (data.type === undefined) {\n      throw new Error('Room.notify: argument must match {type: <document|user>}');\n    }\n    if (!data.fromSelf || this.subscribeToSelf) {\n      this.emit(data.type, data);\n    }\n    return this;\n  }\n\n  /**\n   * Registers a callback to be called with a subscription result\n   * @param {Function} cb\n   */\n  onDone(cb) {\n    if (!cb || typeof cb !== 'function') {\n      throw new Error('Room.onDone: a callback argument is required.');\n    }\n\n    if (this.error) {\n      cb(this.error);\n    }\n    else if (this.roomstate === 'active') {\n      cb(null, this);\n    }\n    else {\n      this.once('done', cb);\n    }\n\n    return this;\n  }\n}\n\nmodule.exports = Room;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Room.js","var\n  Role = require('./Role'),\n  Profile = require('./Profile'),\n  User = require('./User');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {Security}\n * @constructor\n */\nfunction Security(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.fetchRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for fetchRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new Role(self, doc._id, doc._source, doc._meta);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @param {object} meta - role metadata\n * @constructor\n */\nSecurity.prototype.role = function(id, content, meta) {\n  return new Role(this, id, content, meta);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new Profile(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {array} policies - list of policies to attach to the new profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = { policies: policies };\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {array} policies - the list of policies to apply to this profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = {policies: policies};\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollProfiles: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n    var profiles = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (profile) {\n      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\n      newProfile.version = profile._version;\n\n      profiles.push(newProfile);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      profiles: profiles,\n      scrollId: scrollId\n    });\n  });\n};\n\n/**\n * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @param {object} meta - profile metadata\n * @constructor\n */\nSecurity.prototype.profile = function(id, content, meta) {\n  return new Profile(this, id, content, meta);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId = null;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new User(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Replace an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.replaceUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (content.profileIds) {\n    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollUsers: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n    var users = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (user) {\n      var newUser = new User(self, user._id, user._source, user._meta);\n\n      newUser.version = user._version;\n\n      users.push(newUser);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      users: users,\n      scrollId: scrollId\n    });\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @param {object} meta - user metadata\n * @constructor\n */\nSecurity.prototype.user = function(id, content, meta) {\n  return new User(this, id, content, meta);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the user <kuid> .\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a list of accepted fields per authentication strategy.\n *\n * @param options\n * @param cb\n */\nSecurity.prototype.getAllCredentialFields = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Retrieve the list of accepted field names by the specified <strategy>.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Get credential information of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Check the existence of the specified <strategy>’s credentials for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Updates credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n */\nSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\nmodule.exports = Security;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Security.js\n// module id = 13\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Role(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nRole.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Role\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Role} this object\n */\nRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = Role;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Role.js\n// module id = 14\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Profile(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nProfile.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Profile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Profile} this\n */\nProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {Profile} this\n */\nProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {Profile} this\n */\nProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = Profile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Profile.js\n// module id = 15\n// module chunks = 0","// Parameter mutualization\nvar\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true, \n    required: ['_id', 'cursor'], \n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']};\n\n// Redis commands\nvar\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    flushdb: {mapResults: mapNoResult},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: {required: ['_id', 'field', 'value']},\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n    hscan: getxScan,\n    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n    mget: getKeys,\n    mset: {required: ['entries'], mapResults: mapNoResult},\n    msetnx: {required: ['entries'], mapResults: Boolean},\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: {required: ['_id'], mapResults: Boolean},\n    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction MemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = [];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\n(function () {\n  Object.keys(commands).forEach(function (command) {\n    MemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (args.length && typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\n      if (!commands[command].getter) {\n        data.body = {};\n      }\n\n      if (commands[command].required) {\n        commands[command].required.forEach(function (param) {\n          var value = args.shift();\n\n          if (value === undefined) {\n            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n          }\n\n          assignParameter(data, commands[command].getter, param, value);\n        });\n      }\n\n      if (args.length > 1) {\n        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n      }\n\n      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n      }\n\n      if (args.length) {\n        options = Object.assign({}, args[0]);\n\n        if (Array.isArray(commands[command].opts)) {\n          commands[command].opts.forEach(function (opt) {\n            if (options[opt] !== null && options[opt] !== undefined) {\n              assignParameter(data, commands[command].getter, opt, options[opt]);\n              delete options[opt];\n            }\n          });\n        }\n      }\n\n      /*\n       Options function mapper does not necessarily need\n       options to be passed by clients.\n       */\n      if (typeof commands[command].opts === 'function') {\n        commands[command].opts(data, options || {});\n      }\n\n      this.kuzzle.query(query, data, options, cb && function (err, res) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (commands[command].mapResults) {\n          return cb(null, commands[command].mapResults(res.result));\n        }\n\n        cb(null, res.result);\n      });\n\n      if (!commands[command].getter) {\n        return this;\n      }\n    };\n  });\n})();\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  var parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions(data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults(results) {\n  return results.map(function (coords) {\n    return coords.map(function (latlon) {\n      return parseFloat(latlon);\n    });\n  });\n}\n\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    var p = {\n        name: point[0]\n      },\n      i;\n\n    for (i = 1; i < point.length; i++) {\n      // withcoord result are in an array...\n      if (Array.isArray(point[i])) {\n        p.coordinates = point[i].map(function (coord) {\n          return parseFloat(coord);\n        });\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(point[i]);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray(results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt(results) {\n  return results.map(function (value) {\n    return parseInt(value);\n  });\n}\n\n/**\n * Disable results for routes like flushdb\n * @return {undefined}\n */\nfunction mapNoResult() {\n  return undefined;\n}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults(results) {\n  var\n    buffer = null,\n    mapped = [];\n\n  results.forEach(function (value) {\n    if (buffer === null) {\n      buffer = value;\n    }\n    else {\n      mapped.push({member: buffer, score: parseFloat(value)});\n      buffer = null;\n    }\n  });\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\", \n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n * \n * @param  {array.<string|array>} results \n * @return {object}\n */\nfunction mapScanResults(results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/MemoryStorage.js\n// module id = 16\n// module chunks = 0","/**\n *\n * @param protocol\n * @param host\n * @param options\n * @returns {Object} Instantiated WebSocket/Socket.IO object\n */\n\nfunction network(protocol, host, options) {\n  switch (protocol) {\n    case 'websocket':\n      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n        throw new Error('Aborting: no websocket support detected.');\n      }\n      return new (require('./protocols/websocket'))(host, options);\n    case 'socketio':\n      if (!window.io) {\n        throw new Error('Aborting: no socket.io library loaded.');\n      }\n      return new (require('./protocols/socketio'))(host, options);\n    default:\n      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n  }\n}\n\nmodule.exports = network;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/index.js\n// module id = 17\n// module chunks = 0","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nlet WebSocketClient;\n\nclass WSNode extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : require('ws');\n    this.client = null;\n    this.lasturl = null;\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    const\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      opts = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    super.connect();\n\n    if (url !== this.lasturl) {\n      this.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new WebSocketClient(url, opts);\n\n    this.client.onopen = () => {\n      this.clientConnected();\n    };\n\n    this.client.onclose = (closeEvent, message) => {\n      let\n        status,\n        reason = message;\n\n      if (typeof closeEvent === 'number') {\n        status = closeEvent;\n      }\n      else {\n        status = closeEvent.code;\n\n        if (closeEvent.reason) {\n          reason = closeEvent.reason;\n        }\n      }\n\n      if (status === 1000) {\n        this.clientDisconnected();\n      }\n      // do not forward a connection close error if no \n      // connection has been previously established\n      else if (this.wasConnected) {\n        const error = new Error(reason);\n        error.status = status;\n\n        this.clientNetworkError(error);\n      }\n    };\n\n    this.client.onerror = error => {\n      const err = (error instanceof Error) && error || new Error(error);\n\n      this.clientNetworkError(err);\n    };\n\n    this.client.onmessage = payload => {\n      const data = JSON.parse(payload.data || payload);\n\n      if (data.room) {\n        this.emit(data.room, data);\n      }\n      else {\n        this.emit('discarded', data);\n      }\n    };\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.state = 'offline';\n    this.removeAllListeners();\n    this.wasConnected = false;\n    if (this.client) {\n      this.client.close();\n    }\n    this.client = null;\n    this.stopRetryingToConnect = true;\n  }\n}\n\nmodule.exports = WSNode;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/websocket.js","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nclass SocketIO extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    this.socket = null;\n    this.forceDisconnect = false;\n    this.eventsWrapper = {};\n  }\n\n  /**\n   * Connect to the SocketIO server\n   */\n  connect() {\n    super.connect();\n\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: this.autoReconnect,\n      reconnectionDelay: this.reconnectionDelay,\n      forceNew: true\n    });\n\n    this.socket.on('connect', () => this.clientConnected());\n    this.socket.on('connect_error', error => this.clientNetworkError(error));\n\n    this.socket.on('disconnect', () => {\n      if (this.forceDisconnect) {\n        this.clientDisconnected();\n      } else {\n        const error = new Error('An error occurred, kuzzle may not be ready yet');\n        error.status = 500;\n\n        this.clientNetworkError(error);\n      }\n\n      this.forceDisconnect = false;\n    });\n  }\n\n  /**\n   * Registers a callback on an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  addListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    super.addListener(event, callback, once);\n\n    return this;\n  }\n\n  prependListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    return super.prependListener(event, callback, once);\n  }\n\n  /**\n   * Unregisters a callback from an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  removeListener(event, callback) {\n    if (this.eventsWrapper[event]) {\n      this.eventsWrapper[event].listeners.delete(callback);\n\n      if (this.eventsWrapper[event].listeners.size === 0) {\n        this.socket.off(event, this.eventsWrapper[event].wrapper);\n        delete this.eventsWrapper[event];\n      }\n\n      super.removeListener(event, callback);\n    }\n\n    return this;\n  }\n\n  /**\n   * Unregisters all listeners either from an event, or from all events\n   *\n   * @param {string} [event]\n   */\n  removeAllListeners(event) {\n    if (event !== undefined) {\n      if (this.eventsWrapper[event] !== undefined) {\n        for (const listener of this.eventsWrapper[event].listeners) {\n          this.removeListener(event, listener);\n        }\n      }\n    } else {\n      for (const _event of Object.keys(this.eventsWrapper)) {\n        this.removeAllListeners(_event);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send(payload) {\n    this.socket.emit('kuzzle', payload);\n  }\n\n  /**\n   * Closes the connection\n   */\n  close() {\n    this.forceDisconnect = true;\n    this.state = 'offline';\n    this.socket.close();\n    this.socket = null;\n  }\n\n  _addEventWrapper(event, callback, once = false) {\n    if (!this.eventsWrapper[event]) {\n      const wrapper = (...args) => this.emit(event, ...args);\n\n      this.eventsWrapper[event] = {\n        wrapper,\n        listeners: new Set()\n      };\n\n      if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n        if (once) {\n          this.socket.once(event, wrapper);\n        } else {\n          this.socket.on(event, wrapper);\n        }\n      }\n    }\n\n    this.eventsWrapper[event].listeners.add(callback);\n  }\n}\n\nmodule.exports = SocketIO;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/socketio.js"],"sourceRoot":""}