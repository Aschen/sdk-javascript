{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kuzzle.js","webpack:///webpack/bootstrap 46aa11891e581c379c84","webpack:///./src/Kuzzle.js","webpack:///./src/eventEmitter/index.js","webpack:///./src/Document.js","webpack:///./src/security/SecurityDocument.js","webpack:///./src/networkWrapper/protocols/abstract/realtime.js","webpack:///./src/security/User.js","webpack:///./~/uuid/v4.js","webpack:///./src/Room.js","webpack:///./src/SearchResult.js","webpack:///./src/networkWrapper/protocols/socketio.js","webpack:///./src/networkWrapper/protocols/websocket.js","webpack:///./src/Collection.js","webpack:///./src/CollectionMapping.js","webpack:///./src/MemoryStorage.js","webpack:///./src/networkWrapper/index.js","webpack:///./src/security/Profile.js","webpack:///./src/security/Role.js","webpack:///./src/security/Security.js","webpack:///./~/uuid/lib/bytesToUuid.js","webpack:///./~/uuid/lib/rng-browser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","checkPropertyType","prop","typestr","wrongType","Array","isArray","_typeof","Error","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","uuidv4","KuzzleEventEmitter","Collection","Document","Security","MemoryStorage","User","networkWrapper","Kuzzle","_KuzzleEventEmitter","host","options","_this","eventActions","autoResubscribe","defaultIndex","jwt","protocol","sdkVersion","volatile","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","keys","next","done","opt","hasOwnProperty","err","return","room","opts","subscribeCB","_this2","requestId","controller","action","index","collection","body","filters","scope","state","users","notificationCB","data","type","unsetJwt","emit","copy","assign","document","result","_id","_source","_meta","notify","sdkInstanceId","network","subscribe","unsubscribeCB","roomId","unsubscribe","channel","errorMessagePrefix","callback","eventTimeout","connected","timeout","error","disconnected","reconnected","tokenExpired","loginAttempt","autoQueue","set","autoReconnect","autoReplay","offlineQueue","offlineQueueLoader","port","queueFilter","queueMaxSize","queueTTL","replayInterval","reconnectionDelay","sslConnection","eumerable","ssl","addListener","query","bluebird","_ret","promisifyAll","suffix","filter","name","func","passes","whitelist","indexOf","eventName","_get2","now","Date","protectedEvent","protectedEvents","lastEmitted","_len","arguments","payload","_key","apply","concat","cb","_this3","connect","connectionError","internal","disconnect","checkToken","res","valid","on","token","success","JSON","stringify","strategy","_this4","request","expiresIn","queuable","response","message","setJwt","credentials","_this5","callbackRequired","_this6","security","hits","content","event","listener","toString","startTime","stopTime","_len2","args","_key2","queryCB","collections","flushQueue","_len3","_key3","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","arg","indexes","close","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","serverInfo","_len4","_key4","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_len5","_key5","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","autoRefresh","_len6","_key6","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","queryArgs","_arr","_i","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","attr","startQueuing","stopQueuing","playQueue","Listener","fn","once","_events","listeners","Boolean","find","map","listenerType","_exists","push","addOnceListener","prependListener","findIndex","l","splice","onceListeners","toDelete","removeListener","documentId","meta","dataCollection","kuzzle","version","_version","setContent","serialize","delete","buildQueryArgs","exists","refresh","newDocument","save","publish","replace","forEach","ids","values","SecurityDocument","deleteActionName","update","updateActionName","emitRequest","status","send","discardRequest","cleanQueue","lastDocumentIndex","ts","droppedRequest","dequeue","uniqueQueue","dequeuingProcess","shift","setTimeout","Math","max","additionalQueue","RTWrapper","queuing","offlineMode","wasConnected","stopRetryingToConnect","retrying","fromSelf","removeAllListeners","KuzzleSecurityDocument","setProfiles","profileIds","setCredentials","addProfile","profileId","creationSerialize","saveRestricted","getProfileIds","getProfiles","fetchedProfiles","errored","fetchProfile","profile","v4","buf","offset","rnds","random","rng","ii","bytesToUuid","Room","_roomId","roomstate","isListening","resubscribe","deactivate","resubscribeConditional","subscribeToSelf","count","onDone","SearchResult","raw","total","documents","doc","d","aggregations","from","size","scrollId","_scroll_id","fetched","freeze","includes","updateAfterSearch","scroll","sort","search_after","lastDocumentContent","sortRule","search","SocketIO","_RTWrapper","socket","forceDisconnect","eventsWrapper","window","io","reconnection","forceNew","clientConnected","clientNetworkError","clientDisconnected","_addEventWrapper","off","wrapper","_event","Set","add","WebSocketClient","WSNode","WebSocket","e","code","client","lasturl","url","perMessageDeflate","onopen","onclose","closeEvent","reason","onerror","onmessage","parse","readyState","OPEN","blacklist","KuzzleSearchResult","CollectionMapping","createDocument","ifExist","deleteDocument","deleteSpecifications","documentExists","fetchDocument","getMapping","kuzzleMapping","mCreateDocument","mCreateOrReplaceDocument","mDeleteDocument","documentIds","mGetDocument","mReplaceDocument","mUpdateDocument","getSpecifications","publishMessage","replaceDocument","scrollSpecifications","searchSpecifications","evtName","truncate","updateDocument","retryOnConflict","updateSpecifications","specifications","validateSpecifications","collectionMapping","mapping","properties","mappings","field","assignParameter","assignGeoRadiusOptions","parsed","assignZrangeOptions","limit","mapGeoposResults","results","coords","latlon","parseFloat","mapGeoRadiusResults","point","coordinates","coord","distance","mapStringToArray","mapArrayStringToArrayInt","parseInt","mapNoResult","mapZrangeResults","buffer","mapped","member","score","mapScanResults","cursor","getId","required","getIdField","getKeys","getMember","getxScan","mapResults","getZrange","getZrangeBy","setId","setIdValue","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","geoadd","geodist","geohash","geopos","georadius","georadiusbymember","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","setex","setnx","sinter","sinterstore","sismember","smembers","smove","spop","srandmember","srem","sscan","strlen","sunion","sunionstore","time","touch","ttl","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","command","slice","pop","param","Profile","policies","addPolicy","policy","roleId","setPolicies","getPolicies","Role","fetchRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","role","searchProfiles","profiles","createProfile","updateProfile","updatedContent","deleteProfile","scrollProfiles","newProfile","fetchUser","searchUsers","createUser","replaceUser","createRestrictedUser","updateUser","deleteUser","scrollUsers","user","newUser","isActionAllowed","rights","filteredRights","right","some","item","getUserRights","userId","createCredentials","kuid","deleteCredentials","getAllCredentialFields","getCredentialFields","getCredentials","hasCredentials","updateCredentials","validateCredentials","bth","byteToHex","substr","crypto","msCrypto","getRandomValues","rnds8","Uint8Array","r"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! Kuzzle javascript SDK version 5.0.11 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar uuidv4 = __webpack_require__(6),\n\t    KuzzleEventEmitter = __webpack_require__(1),\n\t    Collection = __webpack_require__(11),\n\t    Document = __webpack_require__(2),\n\t    Security = __webpack_require__(17),\n\t    MemoryStorage = __webpack_require__(13),\n\t    User = __webpack_require__(5),\n\t    networkWrapper = __webpack_require__(14);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle object constructor.\n\t *\n\t * @constructor\n\t * @param host - Server name or IP Address to the Kuzzle instance\n\t * @param [options] - Connection options\n\t * @param {responseCallback} [cb] - Handles connection response\n\t */\n\t\n\tvar Kuzzle = function (_KuzzleEventEmitter) {\n\t  _inherits(Kuzzle, _KuzzleEventEmitter);\n\t\n\t  function Kuzzle(host, options) {\n\t    _classCallCheck(this, Kuzzle);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Kuzzle.__proto__ || Object.getPrototypeOf(Kuzzle)).call(this));\n\t\n\t    if (!host || host === '') {\n\t      throw new Error('host argument missing');\n\t    }\n\t\n\t    Object.defineProperties(_this, {\n\t      // 'private' properties\n\t      eventActions: {\n\t        value: ['connected', 'discarded', 'disconnected', 'loginAttempt', 'networkError', 'offlineQueuePush', 'offlineQueuePop', 'queryError', 'reconnected', 'tokenExpired']\n\t      },\n\t      // configuration properties\n\t      autoResubscribe: {\n\t        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true,\n\t        enumerable: true\n\t      },\n\t      defaultIndex: {\n\t        value: options && typeof options.defaultIndex === 'string' ? options.defaultIndex : undefined,\n\t        writable: true,\n\t        enumerable: true\n\t      },\n\t      jwt: {\n\t        value: undefined,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      protocol: {\n\t        value: options && typeof options.protocol === 'string' ? options.protocol : 'websocket',\n\t        enumerable: true\n\t      },\n\t      sdkVersion: {\n\t        value:  false ? require('../package.json').version : (\"5.0.11\")\n\t      },\n\t      volatile: {\n\t        value: {},\n\t        enumerable: true,\n\t        writable: true\n\t      }\n\t    });\n\t\n\t    if (options) {\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = Object.keys(options)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var opt = _step.value;\n\t\n\t          if (_this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(_this, opt).writable) {\n\t            _this[opt] = options[opt];\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Forward the subscribe query to the network wrapper\n\t    Object.defineProperty(_this, 'subscribe', {\n\t      value: function value(room, opts, subscribeCB) {\n\t        var _this2 = this;\n\t\n\t        var object = {\n\t          requestId: uuidv4(),\n\t          controller: 'realtime',\n\t          action: 'subscribe',\n\t          index: room.collection.index,\n\t          collection: room.collection.collection,\n\t          volatile: this.volatile,\n\t          body: room.filters,\n\t          scope: room.scope,\n\t          state: room.state,\n\t          users: room.users\n\t        },\n\t            notificationCB = function notificationCB(data) {\n\t          if (data.type === 'TokenExpired') {\n\t            _this2.unsetJwt();\n\t            return _this2.emit('tokenExpired');\n\t          }\n\t\n\t          if (data.type === 'document') {\n\t            var copy = Object.assign({}, data);\n\t            copy.document = new Document(room.collection, data.result._id, data.result._source, data.result._meta);\n\t            delete copy.result;\n\t            return room.notify(copy);\n\t          }\n\t\n\t          room.notify(data);\n\t        };\n\t\n\t        if (this.jwt !== undefined) {\n\t          object.jwt = this.jwt;\n\t        }\n\t\n\t        Object.assign(object.volatile, room.volatile, { sdkInstanceId: this.network.id, sdkVersion: this.sdkVersion });\n\t\n\t        this.network.subscribe(object, opts, notificationCB, subscribeCB);\n\t      }\n\t    });\n\t\n\t    // Forward the unsubscribe query to the network wrapper\n\t    Object.defineProperty(_this, 'unsubscribe', {\n\t      value: function value(room, unsubscribeCB) {\n\t        var object = {\n\t          requestId: uuidv4(),\n\t          controller: 'realtime',\n\t          action: 'unsubscribe',\n\t          volatile: _this.volatile,\n\t          body: { roomId: room.roomId }\n\t        };\n\t\n\t        if (_this.jwt !== undefined) {\n\t          object.jwt = _this.jwt;\n\t        }\n\t\n\t        Object.assign(object.volatile, room.volatile, { sdkInstanceId: _this.network.id, sdkVersion: _this.sdkVersion });\n\t\n\t        _this.network.unsubscribe(object, room.channel, unsubscribeCB);\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n\t     * and is called by these methods\n\t     */\n\t    Object.defineProperty(_this, 'callbackRequired', {\n\t      value: function value(errorMessagePrefix, callback) {\n\t        if (!callback || typeof callback !== 'function') {\n\t          throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n\t        }\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Create an attribute security that embed all methods to manage Role, Profile and User\n\t     */\n\t    Object.defineProperty(_this, 'security', {\n\t      value: new Security(_this),\n\t      enumerable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'memoryStorage', {\n\t      value: new MemoryStorage(_this),\n\t      enumerable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'collections', {\n\t      value: {},\n\t      writable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'eventTimeout', {\n\t      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200\n\t    });\n\t\n\t    Object.defineProperty(_this, 'protectedEvents', {\n\t      value: {\n\t        connected: { timeout: _this.eventTimeout },\n\t        error: { timeout: _this.eventTimeout },\n\t        disconnected: { timeout: _this.eventTimeout },\n\t        reconnected: { timeout: _this.eventTimeout },\n\t        tokenExpired: { timeout: _this.eventTimeout },\n\t        loginAttempt: { timeout: _this.eventTimeout }\n\t      }\n\t    });\n\t\n\t    _this.network = networkWrapper(_this.protocol, host, options);\n\t\n\t    // Properties related to the network layer\n\t    // Accessing a property irrelevant for a given protocol\n\t    // (e.g. \"autoReconnect\" for the HTTP layer) should\n\t    // throw an exception\n\t    Object.defineProperties(_this, {\n\t      autoQueue: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoQueue;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('autoQueue', 'boolean', value);\n\t          _this.network.autoQueue = value;\n\t        }\n\t      },\n\t      autoReconnect: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoReconnect;\n\t        }\n\t      },\n\t      autoReplay: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoReplay;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('autoReplay', 'boolean', value);\n\t          _this.network.autoReplay = value;\n\t        }\n\t      },\n\t      host: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.host;\n\t        }\n\t      },\n\t      offlineQueue: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.offlineQueue;\n\t        }\n\t      },\n\t      offlineQueueLoader: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.offlineQueueLoader;\n\t        },\n\t        set: function set(value) {\n\t          if (value !== null) {\n\t            checkPropertyType('offlineQueueLoader', 'function', value);\n\t          }\n\t          _this.network.offlineQueueLoader = value;\n\t        }\n\t      },\n\t      port: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.port;\n\t        }\n\t      },\n\t      queueFilter: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueFilter;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueFilter', 'function', value);\n\t          _this.network.queueFilter = value;\n\t        }\n\t      },\n\t      queueMaxSize: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueMaxSize;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueMaxSize', 'number', value);\n\t          _this.network.queueMaxSize = value;\n\t        }\n\t      },\n\t      queueTTL: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueTTL;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueTTL', 'number', value);\n\t          _this.network.queueTTL = value;\n\t        }\n\t      },\n\t      replayInterval: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.replayInterval;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('replayInterval', 'number', value);\n\t          _this.network.replayInterval = value;\n\t        }\n\t      },\n\t      reconnectionDelay: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.reconnectionDelay;\n\t        }\n\t      },\n\t      sslConnection: {\n\t        eumerable: true,\n\t        get: function get() {\n\t          return _this.network.ssl;\n\t        }\n\t      }\n\t    });\n\t\n\t    _this.network.addListener('offlineQueuePush', function (data) {\n\t      return _this.emit('offlineQueuePush', data);\n\t    });\n\t    _this.network.addListener('offlineQueuePop', function (data) {\n\t      return _this.emit('offlineQueuePop', data);\n\t    });\n\t    _this.network.addListener('queryError', function (err, query) {\n\t      return _this.emit('queryError', err, query);\n\t    });\n\t\n\t    _this.network.addListener('tokenExpired', function () {\n\t      _this.unsetJwt();\n\t      _this.emit('tokenExpired');\n\t    });\n\t\n\t    if (_this.bluebird) {\n\t      var _ret;\n\t\n\t      return _ret = _this.bluebird.promisifyAll(_this, {\n\t        suffix: 'Promise',\n\t        filter: function filter(name, func, target, passes) {\n\t          var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics', 'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query', 'checkToken', 'whoAmI', 'updateSelf', 'getMyRights', 'getMyCredentials', 'createMyCredentials', 'deleteMyCredentials', 'updateMyCredentials', 'validateMyCredentials', 'createIndex', 'refreshIndex', 'getAutoRefresh', 'setAutoRefresh', 'connect'];\n\t\n\t          return passes && whitelist.indexOf(name) !== -1;\n\t        }\n\t      }), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t  * Emit an event to all registered listeners\n\t  * An event cannot be emitted multiple times before a timeout has been reached.\n\t  */\n\t\n\t\n\t  _createClass(Kuzzle, [{\n\t    key: 'emit',\n\t    value: function emit(eventName) {\n\t      var _get2;\n\t\n\t      var now = Date.now(),\n\t          protectedEvent = this.protectedEvents[eventName];\n\t\n\t      if (protectedEvent) {\n\t        if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n\t          return false;\n\t        }\n\t        protectedEvent.lastEmitted = now;\n\t      }\n\t\n\t      for (var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        payload[_key - 1] = arguments[_key];\n\t      }\n\t\n\t      (_get2 = _get(Kuzzle.prototype.__proto__ || Object.getPrototypeOf(Kuzzle.prototype), 'emit', this)).call.apply(_get2, [this, eventName].concat(payload));\n\t    }\n\t\n\t    /**\n\t     * Connects to a Kuzzle instance using the provided host name\n\t     * @param {function} [cb] Connection callback\n\t     */\n\t\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect(cb) {\n\t      var _this3 = this;\n\t\n\t      if (this.network.state !== 'offline') {\n\t        if (cb) {\n\t          cb(null, this);\n\t        }\n\t        return;\n\t      }\n\t\n\t      this.network.connect();\n\t\n\t      this.network.addListener('connect', function () {\n\t        _this3.emit('connected');\n\t\n\t        if (cb) {\n\t          cb(null, _this3);\n\t        }\n\t      });\n\t\n\t      this.network.addListener('networkError', function (error) {\n\t        var connectionError = new Error('Unable to connect to kuzzle proxy server at ' + _this3.network.host + ':' + _this3.network.port);\n\t\n\t        connectionError.internal = error;\n\t        _this3.emit('networkError', connectionError);\n\t\n\t        if (cb) {\n\t          cb(connectionError);\n\t        }\n\t      });\n\t\n\t      this.network.addListener('disconnect', function () {\n\t        _this3.disconnect();\n\t        _this3.emit('disconnected');\n\t      });\n\t\n\t      this.network.addListener('reconnect', function () {\n\t        if (_this3.jwt) {\n\t          _this3.checkToken(_this3.jwt, function (err, res) {\n\t            // shouldn't obtain an error but let's invalidate the token anyway\n\t            if (err || !res.valid) {\n\t              _this3.unsetJwt();\n\t            }\n\t\n\t            _this3.emit('reconnected');\n\t          });\n\t        } else {\n\t          _this3.emit('reconnected');\n\t        }\n\t      });\n\t\n\t      this.network.on('discarded', function (data) {\n\t        return _this3.emit('discarded', data);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Set the jwt used to query kuzzle\n\t     * @param token\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'setJwt',\n\t    value: function setJwt(token) {\n\t      if (typeof token === 'string') {\n\t        this.jwt = token;\n\t      } else if ((typeof token === 'undefined' ? 'undefined' : _typeof(token)) === 'object') {\n\t        if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n\t          this.jwt = token.result.jwt;\n\t        } else {\n\t          this.emit('loginAttempt', {\n\t            success: false,\n\t            error: 'Cannot find a valid JWT in the following object: ' + JSON.stringify(token)\n\t          });\n\t\n\t          return this;\n\t        }\n\t      } else {\n\t        this.emit('loginAttempt', { success: false, error: 'Invalid token argument: ' + token });\n\t        return this;\n\t      }\n\t\n\t      this.emit('loginAttempt', { success: true });\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unset the jwt used to query kuzzle\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'unsetJwt',\n\t    value: function unsetJwt() {\n\t      this.jwt = undefined;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Get the jwt used by kuzzle\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'getJwt',\n\t    value: function getJwt() {\n\t      return this.jwt;\n\t    }\n\t\n\t    /**\n\t     * Send login request to kuzzle with credentials\n\t     * If login success, store the jwt into kuzzle object\n\t     *\n\t     * @param strategy\n\t     * @param credentials\n\t     * @param expiresIn\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'login',\n\t    value: function login(strategy) {\n\t      var _this4 = this;\n\t\n\t      if (!strategy || typeof strategy !== 'string') {\n\t        throw new Error('Kuzzle.login: strategy required');\n\t      }\n\t\n\t      var request = {\n\t        strategy: strategy,\n\t        body: {}\n\t      };\n\t\n\t      var cb = null;\n\t\n\t      // Handle arguments (credentials, expiresIn, cb)\n\t      if (arguments.length <= 1 ? undefined : arguments[1]) {\n\t        if (_typeof(arguments.length <= 1 ? undefined : arguments[1]) === 'object') {\n\t          request.body = arguments.length <= 1 ? undefined : arguments[1];\n\t        } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'number' || typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'string') {\n\t          request.expiresIn = arguments.length <= 1 ? undefined : arguments[1];\n\t        } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\n\t          cb = arguments.length <= 1 ? undefined : arguments[1];\n\t        }\n\t      }\n\t      if (arguments.length <= 2 ? undefined : arguments[2]) {\n\t        if (typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'number' || typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'string') {\n\t          request.expiresIn = arguments.length <= 2 ? undefined : arguments[2];\n\t        } else if (typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'function') {\n\t          cb = arguments.length <= 2 ? undefined : arguments[2];\n\t        }\n\t      }\n\t      if ((arguments.length <= 3 ? undefined : arguments[3]) && typeof (arguments.length <= 3 ? undefined : arguments[3]) === 'function') {\n\t        cb = arguments.length <= 3 ? undefined : arguments[3];\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'login' }, request, { queuable: false }, function (error, response) {\n\t        if (!error) {\n\t          if (response.result.jwt) {\n\t            _this4.setJwt(response.result.jwt);\n\t          }\n\t\n\t          cb && cb(null, response.result);\n\t        } else {\n\t          cb && cb(error);\n\t          _this4.emit('loginAttempt', { success: false, error: error.message });\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param credentials\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'createMyCredentials',\n\t    value: function createMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'createMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result._source);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Delete credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'deleteMyCredentials',\n\t    value: function deleteMyCredentials(strategy, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'deleteMyCredentials' }, { strategy: strategy }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Get credential information of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'getMyCredentials',\n\t    value: function getMyCredentials(strategy, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'getMyCredentials' }, { strategy: strategy }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Update credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param credentals\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'updateMyCredentials',\n\t    value: function updateMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'updateMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Validate credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param credentials\n\t     * @param options\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'validateMyCredentials',\n\t    value: function validateMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'validateMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create a kuzzle index\n\t     *\n\t     * @param {string} index\n\t     * @param {object} [options]\n\t     * @param {responseCallback} cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'createIndex',\n\t    value: function createIndex(index, options, cb) {\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.createIndex: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'index', action: 'create', index: index }, {}, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Send logout request to kuzzle with jwt.\n\t     *\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'logout',\n\t    value: function logout(cb) {\n\t      var _this5 = this;\n\t\n\t      var request = {\n\t        action: 'logout',\n\t        controller: 'auth',\n\t        requestId: uuidv4(),\n\t        body: {}\n\t      };\n\t\n\t      this.query({ controller: 'auth', action: 'logout' }, request, { queuable: false }, function (error) {\n\t        if (typeof cb === 'function') {\n\t          cb(error, _this5);\n\t        }\n\t      });\n\t\n\t      return this.unsetJwt();\n\t    }\n\t\n\t    /**\n\t     * Checks whether a given jwt token still represents a valid session in Kuzzle.\n\t     *\n\t     * @param  {string}   token     The jwt token to check\n\t     * @param  {function} cb  The callback to be called when the response is\n\t     *                              available. The signature is `function(error, response)`.\n\t     */\n\t\n\t  }, {\n\t    key: 'checkToken',\n\t    value: function checkToken(token, cb) {\n\t      var request = {\n\t        body: {\n\t          token: token\n\t        }\n\t      };\n\t\n\t      this.callbackRequired('Kuzzle.checkToken', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'checkToken' }, request, { queuable: false }, function (err, res) {\n\t        cb(err, err ? undefined : res.result);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Fetches the current user.\n\t     *\n\t     * @param  {function} cb  The callback to be called when the response is\n\t     *                              available. The signature is `function(error, response)`.\n\t     */\n\t\n\t  }, {\n\t    key: 'whoAmI',\n\t    value: function whoAmI(cb) {\n\t      var _this6 = this;\n\t\n\t      this.callbackRequired('Kuzzle.whoAmI', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'getCurrentUser' }, {}, {}, function (err, res) {\n\t        cb(err, err ? undefined : new User(_this6.security, res.result._id, res.result._source, res.result._meta));\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets the rights array of the currently logged user.\n\t     *\n\t     * @param {object} [options] - Optional parameters\n\t     * @param  {function} cb The callback containing the normalized array of rights.\n\t     */\n\t\n\t  }, {\n\t    key: 'getMyRights',\n\t    value: function getMyRights(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getMyRights', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'getMyRights' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.hits);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Update current user in Kuzzle.\n\t     *\n\t     * @param {object} content - a plain javascript object representing the user's modification\n\t     * @param {object} [options] - (optional) arguments\n\t     * @param {responseCallback} [cb] - (optional) Handles the query response\n\t     * @returns {Kuzzle} this object\n\t     */\n\t\n\t  }, {\n\t    key: 'updateSelf',\n\t    value: function updateSelf(content, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'updateSelf' }, { body: content }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n\t     * insertion.\n\t     *\n\t     * @param {string} event - name of the global event to subscribe to\n\t     * @param {function} listener - callback to invoke each time an event is fired\n\t     */\n\t\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(event, listener) {\n\t      if (this.eventActions.indexOf(event) === -1) {\n\t        throw new Error('[' + event + '] is not a known event. Known events: ' + this.eventActions.toString());\n\t      }\n\t\n\t      return _get(Kuzzle.prototype.__proto__ || Object.getPrototypeOf(Kuzzle.prototype), 'addListener', this).call(this, event, listener);\n\t    }\n\t\n\t    /**\n\t     * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t     * This method returns all available statistics from Kuzzle.\n\t     *\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getAllStatistics',\n\t    value: function getAllStatistics(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\t\n\t      this.query({ controller: 'server', action: 'getAllStats' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.hits);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t     * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n\t     *\n\t     * @param {number} startTime -  Epoch time. Starting time from which the frames are to be retrieved\n\t     * @param {number} stopTime -  Epoch time. End time from which the frames are to be retrieved\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getStatistics',\n\t    value: function getStatistics() {\n\t      var startTime = void 0,\n\t          stopTime = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t        args[_key2] = arguments[_key2];\n\t      }\n\t\n\t      switch (args.length) {\n\t        case 1:\n\t          cb = args[0];\n\t          startTime = null;\n\t          stopTime = null;\n\t          options = null;\n\t          break;\n\t        case 2:\n\t          if (_typeof(args[0]) === 'object') {\n\t            options = args[0];\n\t            cb = args[1];\n\t          } else {\n\t            startTime = args[0];\n\t            cb = args[1];\n\t          }\n\t          break;\n\t        case 3:\n\t          if (_typeof(args[1]) === 'object') {\n\t            startTime = args[0];\n\t            options = args[1];\n\t            cb = args[2];\n\t          } else {\n\t            startTime = args[0];\n\t            stopTime = args[1];\n\t            cb = args[2];\n\t          }\n\t          break;\n\t        case 4:\n\t          startTime = args[0];\n\t          stopTime = args[1];\n\t          options = args[2];\n\t          cb = args[3];\n\t\n\t          break;\n\t        default:\n\t          throw new Error('Bad arguments list. Usage: kuzzle.getStatistics([startTime,] [stopTime,] [options,] callback)');\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getStatistics', cb);\n\t\n\t      var queryCB = function queryCB(err, res) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t\n\t        cb(null, startTime ? res.result.hits : [res.result]);\n\t      };\n\t\n\t      var query = {};\n\t      if (startTime) {\n\t        query = stopTime ? { startTime: startTime, stopTime: stopTime } : { startTime: startTime };\n\t      }\n\t\n\t      this.query({ controller: 'server', action: startTime ? 'getStats' : 'getLastStats' }, query, options, queryCB);\n\t    }\n\t\n\t    /**\n\t     * Create a new instance of a Collection object.\n\t     * If no index is specified, takes the default index.\n\t     *\n\t     * @param {string} collection - The name of the data collection you want to manipulate\n\t     * @param {string} [index] - The name of the data index containing the data collection\n\t     * @returns {Collection} A Collection instance\n\t     */\n\t\n\t  }, {\n\t    key: 'collection',\n\t    value: function collection(_collection, index) {\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Unable to create a new data collection object: no index specified');\n\t        }\n\t\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (typeof index !== 'string' || typeof _collection !== 'string') {\n\t        throw new Error('Invalid index or collection argument: string expected');\n\t      }\n\t\n\t      if (!this.collections[index]) {\n\t        this.collections[index] = {};\n\t      }\n\t\n\t      if (!this.collections[index][_collection]) {\n\t        this.collections[index][_collection] = new Collection(this, _collection, index);\n\t      }\n\t\n\t      return this.collections[index][_collection];\n\t    }\n\t\n\t    /**\n\t     * Empties the offline queue without replaying it.\n\t     *\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'flushQueue',\n\t    value: function flushQueue() {\n\t      this.network.flushQueue();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Returns the list of known persisted data collections.\n\t     *\n\t     * @param {string} [index] - Index containing collections to be listed\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'listCollections',\n\t    value: function listCollections() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n\t        args[_key3] = arguments[_key3];\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var arg = _step2.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.listCollections: index required');\n\t        }\n\t\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.listCollections', cb);\n\t\n\t      var query = { type: options && options.type || 'all' };\n\t\n\t      this.query({ index: index, controller: 'collection', action: 'list' }, query, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.collections);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Returns the list of existing indexes in Kuzzle\n\t     *\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'listIndexes',\n\t    value: function listIndexes(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.listIndexes', cb);\n\t\n\t      this.query({ controller: 'index', action: 'list' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.indexes);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Disconnects from Kuzzle and invalidate this instance.\n\t     */\n\t\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      this.network.close();\n\t\n\t      var _iteratorNormalCompletion3 = true;\n\t      var _didIteratorError3 = false;\n\t      var _iteratorError3 = undefined;\n\t\n\t      try {\n\t        for (var _iterator3 = Object.keys(this.collections)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t          var collection = _step3.value;\n\t\n\t          delete this.collections[collection];\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t            _iterator3.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError3) {\n\t            throw _iteratorError3;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Returns the server informations\n\t     *\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getServerInfo',\n\t    value: function getServerInfo(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getServerInfo', cb);\n\t\n\t      this.query({ controller: 'server', action: 'info' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.serverInfo);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Forces an index refresh\n\t     *\n\t     * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n\t     * @param {object} options - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'refreshIndex',\n\t    value: function refreshIndex() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n\t        args[_key4] = arguments[_key4];\n\t      }\n\t\n\t      var _iteratorNormalCompletion4 = true;\n\t      var _didIteratorError4 = false;\n\t      var _iteratorError4 = undefined;\n\t\n\t      try {\n\t        for (var _iterator4 = args[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t          var arg = _step4.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t            _iterator4.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError4) {\n\t            throw _iteratorError4;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.refreshIndex: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.query({ index: index, controller: 'index', action: 'refresh' }, {}, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Returns de current autoRefresh status for the given index\n\t     *\n\t     * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n\t     * @param {object} options - Optinal arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getAutoRefresh',\n\t    value: function getAutoRefresh() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n\t        args[_key5] = arguments[_key5];\n\t      }\n\t\n\t      var _iteratorNormalCompletion5 = true;\n\t      var _didIteratorError5 = false;\n\t      var _iteratorError5 = undefined;\n\t\n\t      try {\n\t        for (var _iterator5 = args[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t          var arg = _step5.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError5 = true;\n\t        _iteratorError5 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t            _iterator5.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError5) {\n\t            throw _iteratorError5;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.getAutoRefresh: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n\t      this.query({ index: index, controller: 'index', action: 'getAutoRefresh' }, {}, options, cb);\n\t    }\n\t\n\t    /**\n\t     * (Un)Sets the autoRefresh flag on the given index\n\t     *\n\t     * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n\t     * @param {boolean} autoRefresh - The autoRefresh value to set\n\t     * @param {object} options - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query result\n\t     * @returns {object} this\n\t     */\n\t\n\t  }, {\n\t    key: 'setAutoRefresh',\n\t    value: function setAutoRefresh() {\n\t      var index, autoRefresh, options, cb;\n\t\n\t      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n\t        args[_key6] = arguments[_key6];\n\t      }\n\t\n\t      var _iteratorNormalCompletion6 = true;\n\t      var _didIteratorError6 = false;\n\t      var _iteratorError6 = undefined;\n\t\n\t      try {\n\t        for (var _iterator6 = args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t          var arg = _step6.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'boolean':\n\t              autoRefresh = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError6 = true;\n\t        _iteratorError6 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t            _iterator6.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError6) {\n\t            throw _iteratorError6;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.setAutoRefresh: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (autoRefresh === undefined) {\n\t        throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n\t      }\n\t\n\t      this.query({ index: index, controller: 'index', action: 'setAutoRefresh' }, { body: { autoRefresh: autoRefresh } }, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Return the current Kuzzle's UTC Epoch time, in milliseconds\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'now',\n\t    value: function now(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.now', cb);\n\t\n\t      this.query({ controller: 'server', action: 'now' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.now);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n\t     * Base method used to send read queries to Kuzzle\n\t     *\n\t     * Takes an optional argument object with the following properties:\n\t     *    - volatile (object, default: null):\n\t     *        Additional information passed to notifications to other users\n\t     *\n\t     * @param {object} queryArgs - Query configuration\n\t     * @param {object} query - The query data\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} [cb] - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'query',\n\t    value: function query(queryArgs, _query, options, cb) {\n\t      var object = {\n\t        action: queryArgs.action,\n\t        controller: queryArgs.controller,\n\t        volatile: this.volatile\n\t      };\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      } else if (!cb && !options && typeof _query === 'function') {\n\t        cb = _query;\n\t        _query = {};\n\t        options = null;\n\t      }\n\t\n\t      if (options) {\n\t        var _arr = ['refresh', 'from', 'size', 'scroll', 'scrollId'];\n\t\n\t        for (var _i = 0; _i < _arr.length; _i++) {\n\t          var prop = _arr[_i];\n\t          if (options[prop] !== undefined) {\n\t            object[prop] = options[prop];\n\t          }\n\t        }\n\t\n\t        if (options.volatile && _typeof(options.volatile) === 'object') {\n\t          Object.assign(object.volatile, options.volatile);\n\t        }\n\t      }\n\t\n\t      if (!_query || (typeof _query === 'undefined' ? 'undefined' : _typeof(_query)) !== 'object' || Array.isArray(_query)) {\n\t        throw new Error('Invalid query parameter: ' + _query);\n\t      }\n\t\n\t      Object.assign(object.volatile, _query.volatile, { sdkInstanceId: this.network.id, sdkVersion: this.sdkVersion });\n\t\n\t      var _iteratorNormalCompletion7 = true;\n\t      var _didIteratorError7 = false;\n\t      var _iteratorError7 = undefined;\n\t\n\t      try {\n\t        for (var _iterator7 = Object.keys(_query)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t          var attr = _step7.value;\n\t\n\t          if (attr !== 'volatile') {\n\t            object[attr] = _query[attr];\n\t          }\n\t        }\n\t\n\t        /*\n\t         * Do not add the token for the checkToken route, to avoid getting a token error when\n\t         * a developer simply wish to verify his token\n\t         */\n\t      } catch (err) {\n\t        _didIteratorError7 = true;\n\t        _iteratorError7 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t            _iterator7.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError7) {\n\t            throw _iteratorError7;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (this.jwt !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n\t        object.jwt = this.jwt;\n\t      }\n\t\n\t      if (queryArgs.collection) {\n\t        object.collection = queryArgs.collection;\n\t      }\n\t\n\t      if (queryArgs.index) {\n\t        object.index = queryArgs.index;\n\t      }\n\t\n\t      if (!object.requestId) {\n\t        object.requestId = uuidv4();\n\t      }\n\t\n\t      this.network.query(object, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Starts the requests queuing.\n\t     */\n\t\n\t  }, {\n\t    key: 'startQueuing',\n\t    value: function startQueuing() {\n\t      this.network.startQueuing();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Stops the requests queuing.\n\t     */\n\t\n\t  }, {\n\t    key: 'stopQueuing',\n\t    value: function stopQueuing() {\n\t      this.network.stopQueuing();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * @DEPRECATED\n\t     * See Kuzzle.prototype.playQueue();\n\t     */\n\t\n\t  }, {\n\t    key: 'replayQueue',\n\t    value: function replayQueue() {\n\t      return this.playQueue();\n\t    }\n\t\n\t    /**\n\t     * Plays the requests queued during offline mode.\n\t     */\n\t\n\t  }, {\n\t    key: 'playQueue',\n\t    value: function playQueue() {\n\t      this.network.playQueue();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Sets the default Kuzzle index\n\t     *\n\t     * @param index\n\t     * @returns this\n\t     */\n\t\n\t  }, {\n\t    key: 'setDefaultIndex',\n\t    value: function setDefaultIndex(index) {\n\t      if (typeof index !== 'string') {\n\t        throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n\t      }\n\t\n\t      if (index.length === 0) {\n\t        throw new Error('Cannot set an empty index as the default index');\n\t      }\n\t\n\t      this.defaultIndex = index;\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return Kuzzle;\n\t}(KuzzleEventEmitter);\n\t\n\tfunction checkPropertyType(prop, typestr, value) {\n\t  var wrongType = typestr === 'array' ? !Array.isArray(value) : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== typestr;\n\t\n\t  if (wrongType) {\n\t    throw new Error('Can only assign a ' + typestr + ' value to property \"' + prop + '\"');\n\t  }\n\t}\n\t\n\tmodule.exports = Kuzzle;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Listener = function Listener(fn) {\n\t  var once = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t  _classCallCheck(this, Listener);\n\t\n\t  this.fn = fn;\n\t  this.once = once;\n\t};\n\t\n\tvar KuzzleEventEmitter = function () {\n\t  function KuzzleEventEmitter() {\n\t    _classCallCheck(this, KuzzleEventEmitter);\n\t\n\t    this._events = {};\n\t  }\n\t\n\t  _createClass(KuzzleEventEmitter, [{\n\t    key: '_exists',\n\t    value: function _exists(listeners, fn) {\n\t      return Boolean(listeners.find(function (listener) {\n\t        return listener.fn === fn;\n\t      }));\n\t    }\n\t  }, {\n\t    key: 'listeners',\n\t    value: function listeners(eventName) {\n\t      if (this._events[eventName] === undefined) {\n\t        return [];\n\t      }\n\t\n\t      return this._events[eventName].map(function (listener) {\n\t        return listener.fn;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(eventName, listener) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!eventName || !listener) {\n\t        return this;\n\t      }\n\t\n\t      var listenerType = typeof listener === 'undefined' ? 'undefined' : _typeof(listener);\n\t\n\t      if (listenerType !== 'function') {\n\t        throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n\t      }\n\t\n\t      if (this._events[eventName] === undefined) {\n\t        this._events[eventName] = [];\n\t      }\n\t\n\t      if (!this._exists(this._events[eventName], listener)) {\n\t        this._events[eventName].push(new Listener(listener, once));\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'on',\n\t    value: function on(eventName, listener) {\n\t      return this.addListener(eventName, listener);\n\t    }\n\t  }, {\n\t    key: 'prependListener',\n\t    value: function prependListener(eventName, listener) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!eventName || !listener) {\n\t        return this;\n\t      }\n\t\n\t      if (this._events[eventName] === undefined) {\n\t        this._events[eventName] = [];\n\t      }\n\t\n\t      if (!this._exists(this._events[eventName], listener)) {\n\t        this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'addOnceListener',\n\t    value: function addOnceListener(eventName, listener) {\n\t      return this.addListener(eventName, listener, true);\n\t    }\n\t  }, {\n\t    key: 'once',\n\t    value: function once(eventName, listener) {\n\t      return this.addOnceListener(eventName, listener);\n\t    }\n\t  }, {\n\t    key: 'prependOnceListener',\n\t    value: function prependOnceListener(eventName, listener) {\n\t      return this.prependListener(eventName, listener, true);\n\t    }\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(eventName, listener) {\n\t      var listeners = this._events[eventName];\n\t\n\t      if (!listeners || !listeners.length) {\n\t        return this;\n\t      }\n\t\n\t      var index = listeners.findIndex(function (l) {\n\t        return l.fn === listener;\n\t      });\n\t\n\t      if (index !== -1) {\n\t        listeners.splice(index, 1);\n\t      }\n\t\n\t      if (listeners.length === 0) {\n\t        delete this._events[eventName];\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'removeAllListeners',\n\t    value: function removeAllListeners(eventName) {\n\t      if (eventName) {\n\t        delete this._events[eventName];\n\t      } else {\n\t        this._events = {};\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'emit',\n\t    value: function emit(eventName) {\n\t      var listeners = this._events[eventName];\n\t\n\t      if (listeners === undefined) {\n\t        return false;\n\t      }\n\t\n\t      var onceListeners = [];\n\t\n\t      for (var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        payload[_key - 1] = arguments[_key];\n\t      }\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var listener = _step.value;\n\t\n\t          listener.fn.apply(listener, payload);\n\t\n\t          if (listener.once) {\n\t            onceListeners.push(listener.fn);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = onceListeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var toDelete = _step2.value;\n\t\n\t          this.removeListener(eventName, toDelete);\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'eventNames',\n\t    value: function eventNames() {\n\t      return Object.keys(this._events);\n\t    }\n\t  }, {\n\t    key: 'listenerCount',\n\t    value: function listenerCount(eventName) {\n\t      return this._events[eventName] && this._events[eventName].length || 0;\n\t    }\n\t  }]);\n\t\n\t  return KuzzleEventEmitter;\n\t}();\n\t\n\tmodule.exports = KuzzleEventEmitter;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle handles documents either as realtime messages or as stored documents.\n\t * Document is the object representation of one of these documents.\n\t *\n\t * Notes:\n\t *   - this constructor may be called either with a documentId, a content, neither or both.\n\t *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n\t *\n\t *\n\t * @param {Collection} collection - an instanciated Collection object\n\t * @param {string} [documentId] - ID of an existing document\n\t * @param {object} [content] - Initializes this document with the provided content\n\t * @param {object} [meta] - Initializes this document with the provided meta\n\t * @constructor\n\t */\n\tfunction Document(collection, documentId, content, meta) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection.collection,\n\t      enumerable: true\n\t    },\n\t    dataCollection: {\n\t      value: collection,\n\t      enumerable: false\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: false\n\t    },\n\t    // writable properties\n\t    id: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    version: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    meta: {\n\t      value: meta || {},\n\t      enumerable: true,\n\t      writable: false\n\t    }\n\t  });\n\t\n\t  // handling provided arguments\n\t  if (!content && documentId && typeof documentId === 'object') {\n\t    content = documentId;\n\t    documentId = null;\n\t  }\n\t\n\t  if (content) {\n\t    if (content._version) {\n\t      this.version = content._version;\n\t      delete content._version;\n\t    }\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  if (documentId) {\n\t    Object.defineProperty(this, 'id', {\n\t      value: documentId,\n\t      enumerable: true\n\t    });\n\t  }\n\t\n\t  // promisifying\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'refresh', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this document\n\t */\n\tDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  if (this.version) {\n\t    data._version = this.version;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Overrides the toString() method in order to return a serialized version of the document\n\t *\n\t * @return {string} serialized version of this object\n\t */\n\tDocument.prototype.toString = function () {\n\t  return JSON.stringify(this.serialize());\n\t};\n\t\n\t/**\n\t * Deletes this document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.delete = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.delete: cannot delete a document without a document ID');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n\t    cb(err, err ? undefined : self.id);\n\t  });\n\t};\n\t\n\t/**\n\t * Checks if this document exists in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.exists = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Replaces the current content with the last version of this document stored in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.refresh = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Document.refresh', cb);\n\t\n\t  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n\t    var newDocument;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n\t    newDocument.version = res.result._version;\n\t\n\t    cb(null, newDocument);\n\t  });\n\t};\n\t\n\t/**\n\t * Saves this document into Kuzzle.\n\t *\n\t * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n\t * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n\t    if (error) {\n\t      return cb && cb(error);\n\t    }\n\t\n\t    self.id = res.result._id;\n\t    self.version = res.result._version;\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Sends the content of this document as a realtime message.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @returns {*} this\n\t */\n\tDocument.prototype.publish = function (options) {\n\t  var data = this.serialize();\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function won’t be applied until the save method is called.\n\t *\n\t * @param {object} data - New content\n\t * @param {boolean} replace - if true: replace this document content with the provided data\n\t */\n\tDocument.prototype.setContent = function (data, replace) {\n\t  var self = this;\n\t\n\t  if (replace) {\n\t    this.content = data;\n\t  }\n\t  else {\n\t    Object.keys(data).forEach(function (key) {\n\t      self.content[key] = data[key];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Listens to events concerning this document. Has no effect if the document does not have an ID\n\t * (i.e. if the document has not yet been created as a persisted document).\n\t *\n\t * @param {object} [options] - subscription options\n\t * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n\t */\n\tDocument.prototype.subscribe = function (options, cb) {\n\t  var filters;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\t\n\t  if (!this.id) {\n\t    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n\t  }\n\t\n\t  filters = { ids: { values: [this.id] } };\n\t\n\t  return this.dataCollection.subscribe(filters, options, cb);\n\t};\n\t\n\tmodule.exports = Document;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\tfunction SecurityDocument(Security, id, content, meta) {\n\t\n\t  if (!id) {\n\t    throw new Error('A security document must have an id');\n\t  }\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    kuzzle: {\n\t      value: Security.kuzzle\n\t    },\n\t    Security: {\n\t      value: Security\n\t    },\n\t    // read-only properties\n\t    // writable properties\n\t    id: {\n\t      value: id,\n\t      enumerable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    meta: {\n\t      value: meta || {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (content) {\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'update'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function won’t be applied until the save method is called.\n\t *\n\t * @param {Object} data - New securityDocument content\n\t * @return {SecurityDocument} this\n\t */\n\tSecurityDocument.prototype.setContent = function (data) {\n\t  this.content = data;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a pojo\n\t *\n\t * @return {object} pojo representing this securityDocument\n\t */\n\tSecurityDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Delete the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tSecurityDocument.prototype.delete = function (options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, res.result._id);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Update the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} content - Content to add to KuzzleSecurityDocument\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {SecurityDocument} this\n\t */\n\tSecurityDocument.prototype.update = function (content, options, cb) {\n\t  var\n\t    data = {},\n\t    self = this;\n\t\n\t  if (typeof content !== 'object') {\n\t    throw new Error('Parameter \"content\" must be a object');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = self.id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    self.setContent(response.result._source);\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = SecurityDocument;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar uuidv4 = __webpack_require__(6),\n\t    KuzzleEventEmitter = __webpack_require__(1);\n\t\n\tvar RTWrapper = function (_KuzzleEventEmitter) {\n\t  _inherits(RTWrapper, _KuzzleEventEmitter);\n\t\n\t  function RTWrapper(host, options) {\n\t    _classCallCheck(this, RTWrapper);\n\t\n\t    var _this = _possibleConstructorReturn(this, (RTWrapper.__proto__ || Object.getPrototypeOf(RTWrapper)).call(this));\n\t\n\t    Object.defineProperties(_this, {\n\t      id: {\n\t        value: uuidv4()\n\t      },\n\t      host: {\n\t        value: host,\n\t        enumerable: true\n\t      },\n\t      port: {\n\t        value: options && typeof options.port === 'number' ? options.port : 7512,\n\t        enumerable: true\n\t      },\n\t      ssl: {\n\t        value: options && typeof options.sslConnection === 'boolean' ? options.sslConnection : false,\n\t        enumerable: true\n\t      },\n\t      queuing: {\n\t        value: false,\n\t        writable: true\n\t      },\n\t      reconnectionDelay: {\n\t        value: options && typeof options.reconnectionDelay === 'number' ? options.reconnectionDelay : 1000,\n\t        enumerable: true\n\t      },\n\t      // configuration properties\n\t      autoReconnect: {\n\t        value: options && typeof options.autoReconnect === 'boolean' ? options.autoReconnect : true,\n\t        enumerable: true\n\t      },\n\t      autoQueue: {\n\t        value: false,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      autoReplay: {\n\t        value: false,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      state: {\n\t        value: 'offline',\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      /*\n\t        Offline queue use the following format:\n\t              [\n\t                {\n\t                  ts: <query timestamp>,\n\t                  query: 'query',\n\t                  cb: callbackFunction\n\t                }\n\t              ]\n\t       */\n\t      offlineQueue: {\n\t        value: [],\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueFilter: {\n\t        value: null,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueMaxSize: {\n\t        value: 500,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueTTL: {\n\t        value: 120000,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      replayInterval: {\n\t        value: 10,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      offlineQueueLoader: {\n\t        value: null,\n\t        enumerable: true,\n\t        writable: true\n\t      }\n\t    });\n\t\n\t    if (options) {\n\t      Object.keys(options).forEach(function (opt) {\n\t        if (_this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(_this, opt).writable) {\n\t          _this[opt] = options[opt];\n\t        }\n\t      });\n\t\n\t      if (options.offlineMode === 'auto' && _this.autoReconnect) {\n\t        _this.autoQueue = _this.autoReplay = true;\n\t      }\n\t    }\n\t\n\t    _this.wasConnected = false;\n\t    _this.stopRetryingToConnect = false;\n\t    _this.retrying = false;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(RTWrapper, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      this.state = 'connecting';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is established\n\t     */\n\t\n\t  }, {\n\t    key: 'clientConnected',\n\t    value: function clientConnected() {\n\t      this.state = 'connected';\n\t      this.emit(this.wasConnected && 'reconnect' || 'connect');\n\t      this.wasConnected = true;\n\t      this.stopRetryingToConnect = false;\n\t\n\t      if (this.autoQueue) {\n\t        this.stopQueuing();\n\t      }\n\t\n\t      if (this.autoReplay) {\n\t        this.playQueue();\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is closed\n\t     */\n\t\n\t  }, {\n\t    key: 'clientDisconnected',\n\t    value: function clientDisconnected() {\n\t      this.state = 'offline';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t\n\t      this.emit('disconnect');\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is closed with an error state\n\t     *\n\t     * @param {Error} error\n\t     */\n\t\n\t  }, {\n\t    key: 'clientNetworkError',\n\t    value: function clientNetworkError(error) {\n\t      var _this2 = this;\n\t\n\t      this.state = 'offline';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t\n\t      this.emit('networkError', error);\n\t      if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n\t        this.retrying = true;\n\t        setTimeout(function () {\n\t          _this2.retrying = false;\n\t          _this2.connect(_this2.host);\n\t        }, this.reconnectionDelay);\n\t      } else {\n\t        this.emit('disconnect');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Empties the offline queue without replaying it.\n\t     */\n\t\n\t  }, {\n\t    key: 'flushQueue',\n\t    value: function flushQueue() {\n\t      this.offlineQueue = [];\n\t    }\n\t\n\t    /**\n\t     * Replays the requests queued during offline mode.\n\t     */\n\t\n\t  }, {\n\t    key: 'playQueue',\n\t    value: function playQueue() {\n\t      if (this.state === 'connected') {\n\t        cleanQueue(this);\n\t        dequeue(this);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t     */\n\t\n\t  }, {\n\t    key: 'startQueuing',\n\t    value: function startQueuing() {\n\t      this.queuing = true;\n\t    }\n\t\n\t    /**\n\t     * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t     */\n\t\n\t  }, {\n\t    key: 'stopQueuing',\n\t    value: function stopQueuing() {\n\t      this.queuing = false;\n\t    }\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(object, options, notificationCB, cb) {\n\t      var _this3 = this;\n\t\n\t      if (this.state !== 'connected') {\n\t        return cb(new Error('Not Connected'));\n\t      }\n\t      this.query(object, options, function (error, response) {\n\t        if (error) {\n\t          return cb(error);\n\t        }\n\t        _this3.on(response.result.channel, function (data) {\n\t          data.fromSelf = data.volatile !== undefined && data.volatile.sdkInstanceId === _this3.id;\n\t          notificationCB(data);\n\t        });\n\t        cb(null, response.result);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(object, channel, cb) {\n\t      this.removeAllListeners(channel);\n\t      this.query(object, null, function (err, res) {\n\t        if (cb) {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'query',\n\t    value: function query(object, options, cb) {\n\t      var queuable = options && options.queuable !== false || true;\n\t\n\t      if (this.queueFilter) {\n\t        queuable = queuable && this.queueFilter(object);\n\t      }\n\t\n\t      if (this.queuing && queuable) {\n\t        cleanQueue(this, object, cb);\n\t        this.emit('offlineQueuePush', { query: object, cb: cb });\n\t        return this.offlineQueue.push({ ts: Date.now(), query: object, cb: cb });\n\t      }\n\t\n\t      if (this.state === 'connected') {\n\t        return emitRequest(this, object, cb);\n\t      }\n\t\n\t      return discardRequest(object, cb);\n\t    }\n\t  }]);\n\t\n\t  return RTWrapper;\n\t}(KuzzleEventEmitter);\n\t/**\n\t * Emit a request to Kuzzle\n\t *\n\t * @param {RTWrapper} network\n\t * @param {object} request\n\t * @param {responseCallback} [cb]\n\t */\n\t\n\t\n\tfunction emitRequest(network, request, cb) {\n\t  if (request.jwt !== undefined || cb) {\n\t    network.once(request.requestId, function (response) {\n\t      var error = null;\n\t\n\t      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n\t        network.emit('tokenExpired', request, cb);\n\t      }\n\t\n\t      if (response.error) {\n\t        error = new Error(response.error.message);\n\t        Object.assign(error, response.error);\n\t        error.status = response.status;\n\t        network.emit('queryError', error, request, cb);\n\t      }\n\t\n\t      if (cb) {\n\t        cb(error, response);\n\t      }\n\t    });\n\t  }\n\t  // Track requests made to allow Room.subscribeToSelf to work\n\t  network.send(request);\n\t}\n\t\n\tfunction discardRequest(object, cb) {\n\t  if (cb) {\n\t    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n\t  }\n\t}\n\t\n\t/**\n\t * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n\t * @param {RTWrapper} network\n\t */\n\tfunction cleanQueue(network) {\n\t  var now = Date.now();\n\t  var lastDocumentIndex = -1;\n\t\n\t  if (network.queueTTL > 0) {\n\t    network.offlineQueue.forEach(function (query, index) {\n\t      if (query.ts < now - network.queueTTL) {\n\t        lastDocumentIndex = index;\n\t      }\n\t    });\n\t\n\t    if (lastDocumentIndex !== -1) {\n\t      network.offlineQueue.splice(0, lastDocumentIndex + 1).forEach(function (droppedRequest) {\n\t        network.emit('offlineQueuePop', droppedRequest.query);\n\t      });\n\t    }\n\t  }\n\t\n\t  if (network.queueMaxSize > 0 && network.offlineQueue.length > network.queueMaxSize) {\n\t    network.offlineQueue.splice(0, network.offlineQueue.length - network.queueMaxSize).forEach(function (droppedRequest) {\n\t      network.emit('offlineQueuePop', droppedRequest.query);\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Play all queued requests, in order.\n\t */\n\tfunction dequeue(network) {\n\t  var uniqueQueue = {},\n\t      dequeuingProcess = function dequeuingProcess() {\n\t    if (network.offlineQueue.length > 0) {\n\t      emitRequest(network, network.offlineQueue[0].query, network.offlineQueue[0].cb);\n\t      network.emit('offlineQueuePop', network.offlineQueue.shift());\n\t\n\t      setTimeout(function () {\n\t        dequeuingProcess();\n\t      }, Math.max(0, network.replayInterval));\n\t    }\n\t  };\n\t\n\t  if (network.offlineQueueLoader) {\n\t    if (typeof network.offlineQueueLoader !== 'function') {\n\t      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + _typeof(network.offlineQueueLoader));\n\t    }\n\t\n\t    var additionalQueue = network.offlineQueueLoader();\n\t    if (Array.isArray(additionalQueue)) {\n\t      network.offlineQueue = additionalQueue.concat(network.offlineQueue).filter(function (request) {\n\t        // throws if the query object does not contain required attributes\n\t        if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n\t          throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n\t        }\n\t\n\t        return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : uniqueQueue[request.query.requestId] = true;\n\t      });\n\t    } else {\n\t      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + (typeof additionalQueue === 'undefined' ? 'undefined' : _typeof(additionalQueue)));\n\t    }\n\t  }\n\t\n\t  dequeuingProcess();\n\t}\n\t\n\tmodule.exports = RTWrapper;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(3);\n\t\n\t/**\n\t * @param {Security} Security\n\t * @param {string} id\n\t * @param {Object} content\n\t * @constructor\n\t */\n\tfunction User(Security, id, content, meta) {\n\t  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteUser'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateUser'\n\t    },\n\t    credentials: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: User\n\t  }\n\t});\n\t\n\t/**\n\t * Set profiles in content\n\t * @param {array} profileIds - an array of profiles ids string\n\t *\n\t * @returns {User} this\n\t */\n\tUser.prototype.setProfiles = function (profileIds) {\n\t  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n\t    throw new Error('Parameter \"profileIds\" must be an array of strings');\n\t  }\n\t\n\t  this.content.profileIds = profileIds;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {object} credentials\n\t */\n\tUser.prototype.setCredentials = function (credentials) {\n\t  if (typeof credentials !== 'object') {\n\t    throw new Error('Parameter \"credentials\" must be a object');\n\t  }\n\t\n\t  this.credentials = credentials;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a profile\n\t * @param {string} profileId - a profile ids string\n\t *\n\t * @returns {User} this\n\t */\n\tUser.prototype.addProfile = function (profileId) {\n\t  if (typeof profileId !== 'string') {\n\t    throw new Error('Parameter \"profileId\" must be a string');\n\t  }\n\t\n\t  if (!this.content.profileIds) {\n\t    this.content.profileIds = [];\n\t  }\n\t\n\t  if (this.content.profileIds.indexOf(profileId) === -1) {\n\t    this.content.profileIds.push(profileId);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Creates this user into Kuzzle\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.create = function (options, cb) {\n\t  var\n\t    data = this.creationSerialize(),\n\t    self = this;\n\t\n\t  if (!this.content.profileIds) {\n\t    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Replaces the latest version of this user in Kuzzle by the current content of this object.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.replace = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (!this.content.profileIds) {\n\t    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t\n\t  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Saves this user as restricted into Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.saveRestricted = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tUser.prototype.serialize = function () {\n\t  return {_id: this.id, body: this.content, meta: this.meta};\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tUser.prototype.creationSerialize = function () {\n\t  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n\t};\n\t\n\t/**\n\t * Return the associated profiles IDs\n\t *\n\t * @return {array.<string>} the associated profiles IDs\n\t */\n\tUser.prototype.getProfileIds = function () {\n\t  return this.content.profileIds || [];\n\t};\n\t\n\t/**\n\t * Return the associated Profile objects\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tUser.prototype.getProfiles = function (options, cb) {\n\t  var \n\t    self = this,\n\t    fetchedProfiles = [],\n\t    errored = false;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\t\n\t  if (!self.content.profileIds) {\n\t    return cb(null, fetchedProfiles);\n\t  }\n\t\n\t  self.content.profileIds.forEach(function (profileId) {\n\t    self.Security.fetchProfile(profileId, options, function (error, profile) {\n\t      if (error) {\n\t        if (errored) {\n\t          return;\n\t        }\n\t\n\t        errored = true; // prevents multiple callback resolutions\n\t        return cb(error);\n\t      }\n\t\n\t      fetchedProfiles.push(profile);\n\t\n\t      if (fetchedProfiles.length === self.content.profileIds.length) {\n\t        cb(null, fetchedProfiles);\n\t      }\n\t    });\n\t  });\n\t};\n\t\n\tmodule.exports = User;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(19);\n\tvar bytesToUuid = __webpack_require__(18);\n\t\n\tfunction v4(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || bytesToUuid(rnds);\n\t}\n\t\n\tmodule.exports = v4;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar KuzzleEventEmitter = __webpack_require__(1);\n\t\n\t/**\n\t * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n\t *\n\t * In Kuzzle, you don’t exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n\t *\n\t * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n\t * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n\t * document change (because it is created, updated or deleted), then you’ll receive a notification about it.\n\t *\n\t */\n\t\n\tvar Room = function (_KuzzleEventEmitter) {\n\t  _inherits(Room, _KuzzleEventEmitter);\n\t\n\t  /*\n\t   * @constructor\n\t   * @param {object} collection - an instantiated and valid kuzzle object\n\t   * @param {object} [filters] - Filters in Kuzzle DSL format\n\t   * @param {object} [options] - subscription optional configuration\n\t   */\n\t  function Room(collection, filters, options) {\n\t    _classCallCheck(this, Room);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Room.__proto__ || Object.getPrototypeOf(Room)).call(this));\n\t\n\t    var _roomId = null;\n\t\n\t    // Define properties\n\t    Object.defineProperties(_this, {\n\t      // private properties\n\t      roomstate: {\n\t        // Values can be: inactive, subscribing, active\n\t        value: 'inactive',\n\t        writable: true\n\t      },\n\t      kuzzle: {\n\t        value: collection.kuzzle\n\t      },\n\t      isListening: {\n\t        value: false,\n\t        writable: true\n\t      },\n\t      //listeners\n\t      resubscribe: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t          _this.error = null;\n\t          _this.subscribe();\n\t        }\n\t      },\n\t      deactivate: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t        }\n\t      },\n\t      resubscribeConditional: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t\n\t          if (_this.autoResubscribe) {\n\t            _this.subscribe();\n\t          }\n\t        }\n\t      },\n\t      //enumerables\n\t      channel: {\n\t        value: null,\n\t        writable: true,\n\t        enumerable: true\n\t      },\n\t      scope: {\n\t        value: options && options.scope ? options.scope : 'all',\n\t        enumerable: true\n\t      },\n\t      state: {\n\t        value: options && options.state ? options.state : 'done',\n\t        enumerable: true\n\t      },\n\t      users: {\n\t        value: options && options.users ? options.users : 'none',\n\t        enumerable: true\n\t      },\n\t      // read-only properties\n\t      collection: {\n\t        value: collection,\n\t        enumerable: true\n\t      },\n\t      filters: {\n\t        value: filters ? filters : {},\n\t        enumerable: true\n\t      },\n\t      roomId: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _roomId;\n\t        },\n\t        set: function set(value) {\n\t          if (!_roomId) {\n\t            _roomId = value;\n\t          }\n\t        }\n\t      },\n\t      // writable properties\n\t      volatile: {\n\t        value: options && options.volatile ? options.volatile : {},\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      subscribeToSelf: {\n\t        value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      autoResubscribe: {\n\t        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : collection.kuzzle.autoResubscribe,\n\t        enumerable: true\n\t      }\n\t    });\n\t\n\t    if (_this.kuzzle.bluebird) {\n\t      var _ret;\n\t\n\t      return _ret = _this.kuzzle.bluebird.promisifyAll(_this, {\n\t        suffix: 'Promise',\n\t        filter: function filter(name, func, target, passes) {\n\t          var whitelist = ['count', 'subscribe', 'unsubscribe', 'onDone'];\n\t\n\t          return passes && whitelist.indexOf(name) !== -1;\n\t        }\n\t      }), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Returns the number of other subscriptions on that room.\n\t   *\n\t   * @param {responseCallback} cb - Handles the query response\n\t   */\n\t\n\t\n\t  _createClass(Room, [{\n\t    key: 'count',\n\t    value: function count(cb) {\n\t      this.kuzzle.callbackRequired('Room.count', cb);\n\t\n\t      var data = { body: { roomId: this.roomId } };\n\t\n\t      if (this.roomstate !== 'active') {\n\t        return cb(new Error('Cannot count subscriptions on an non-active room'));\n\t      }\n\t\n\t      this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n\t        cb(err, res && res.result.count);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Subscribes to Kuzzle \n\t     * (do nothing if a subscription is active or underway)\n\t     * \n\t     * @param options\n\t     * @param {responseCallback} cb - called when the subscription is ready.\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(options, cb) {\n\t      var _this2 = this;\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      if (cb) {\n\t        this.onDone(cb);\n\t      }\n\t\n\t      // If the room subscription is active, just call the callback.\n\t      if (this.roomstate === 'active') {\n\t        this.emit('done', null, this);\n\t        return this;\n\t      }\n\t\n\t      // If the room is already subscribing, wait for its activation.\n\t      if (this.roomstate === 'subscribing') {\n\t        return this;\n\t      }\n\t\n\t      // If the room is still inactive, start the subscription.\n\t      this.error = null;\n\t      this.roomstate = 'subscribing';\n\t\n\t      this.kuzzle.subscribe(this, options, function (error, result) {\n\t        if (error) {\n\t          if (error.message === 'Not Connected') {\n\t            return _this2.kuzzle.once('connected', _this2.resubscribe);\n\t          }\n\t\n\t          _this2.roomstate = 'inactive';\n\t          _this2.error = new Error('Error during Kuzzle subscription: ' + error.message);\n\t          _this2.emit('done', _this2.error);\n\t          return null;\n\t        }\n\t\n\t        _this2.roomId = result.roomId;\n\t        _this2.channel = result.channel;\n\t        _this2.roomstate = 'active';\n\t\n\t        if (!_this2.isListening) {\n\t          _this2.kuzzle.addListener('disconnected', _this2.deactivate);\n\t          _this2.kuzzle.addListener('tokenExpired', _this2.deactivate);\n\t          _this2.kuzzle.addListener('reconnected', _this2.resubscribeConditional);\n\t          _this2.isListening = true;\n\t        }\n\t\n\t        _this2.emit('done', null, _this2);\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unsubscribes from Kuzzle.\n\t     *\n\t     * Stop listening immediately.\n\t     * @param {responseCallback} cb - Handles the query response\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(cb) {\n\t      if (this.roomstate === 'subscribing') {\n\t        if (cb) {\n\t          cb(new Error('Cannot unsubscribe a room while a subscription attempt is underway'));\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (this.isListening) {\n\t        this.kuzzle.removeListener('disconnected', this.deactivate);\n\t        this.kuzzle.removeListener('tokenExpired', this.deactivate);\n\t        this.kuzzle.removeListener('reconnected', this.resubscribeConditional);\n\t        this.isListening = false;\n\t      }\n\t\n\t      if (this.roomstate === 'active') {\n\t        this.kuzzle.unsubscribe(this, cb);\n\t      } else if (cb) {\n\t        cb(null, this.roomId);\n\t      }\n\t\n\t      this.roomstate = 'inactive';\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Notify listeners\n\t     *\n\t     * @param {Object} data - data to send. Must contain `data.type` as eventName.\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'notify',\n\t    value: function notify(data) {\n\t      if (data.type === undefined) {\n\t        throw new Error('Room.notify: argument must match {type: <document|user>}');\n\t      }\n\t      if (!data.fromSelf || this.subscribeToSelf) {\n\t        this.emit(data.type, data);\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Registers a callback to be called with a subscription result\n\t     * @param {Function} cb\n\t     */\n\t\n\t  }, {\n\t    key: 'onDone',\n\t    value: function onDone(cb) {\n\t      if (!cb || typeof cb !== 'function') {\n\t        throw new Error('Room.onDone: a callback argument is required.');\n\t      }\n\t\n\t      if (this.error) {\n\t        cb(this.error);\n\t      } else if (this.roomstate === 'active') {\n\t        cb(null, this);\n\t      } else {\n\t        this.once('done', cb);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return Room;\n\t}(KuzzleEventEmitter);\n\t\n\tmodule.exports = Room;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Document = __webpack_require__(2);\n\t\n\t/**\n\t * @param {Collection} collection\n\t * @param {object} filters\n\t * @param {object} options\n\t * @param {object} raw \n\t * @property {Collection} collection\n\t * @property {number} total\n\t * @property {Document[]} documents\n\t * @property {object} aggregations\n\t * @property {object} options\n\t * @property {object} filters\n\t * @property {number} fetched\n\t * @constructor\n\t */\n\t\n\tvar SearchResult = function () {\n\t  function SearchResult(collection, filters, options, raw) {\n\t    _classCallCheck(this, SearchResult);\n\t\n\t    Object.defineProperties(this, {\n\t      // read-only properties\n\t      collection: {\n\t        value: collection,\n\t        enumerable: true\n\t      },\n\t      total: {\n\t        value: raw.result.total,\n\t        enumerable: true\n\t      },\n\t      documents: {\n\t        value: raw.result.hits.map(function (doc) {\n\t          var d = new Document(collection, doc._id, doc._source, doc._meta);\n\t          d.version = doc._version;\n\t          return d;\n\t        }),\n\t        enumerable: true\n\t      },\n\t      aggregations: {\n\t        value: raw.result.aggregations || {},\n\t        enumerable: true\n\t      },\n\t      options: {\n\t        value: {\n\t          from: options.from,\n\t          size: options.size,\n\t          scrollId: raw.result._scroll_id\n\t        },\n\t        enumerable: true\n\t      },\n\t      filters: {\n\t        value: filters || {},\n\t        enumerable: true\n\t      },\n\t      // writable properties\n\t      fetched: {\n\t        value: raw.result.hits.length,\n\t        enumerable: true,\n\t        writable: true\n\t      }\n\t    });\n\t\n\t    Object.freeze(this.filters);\n\t    Object.freeze(this.options);\n\t    Object.freeze(this.aggregations);\n\t\n\t    // promisifying\n\t    if (this.collection.kuzzle.bluebird) {\n\t      var whitelist = ['fetchNext'];\n\t\n\t      return this.collection.kuzzle.bluebird.promisifyAll(this, {\n\t        suffix: 'Promise',\n\t        filter: function filter(name, func, target, passes) {\n\t          return passes && whitelist.includes(name);\n\t        }\n\t      });\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @param {function} cb\n\t   */\n\t\n\t\n\t  _createClass(SearchResult, [{\n\t    key: 'fetchNext',\n\t    value: function fetchNext(cb) {\n\t      var _this = this;\n\t\n\t      var updateAfterSearch = function updateAfterSearch(error, result) {\n\t        if (error) {\n\t          return cb(error);\n\t        }\n\t\n\t        result.fetched += _this.fetched;\n\t        cb(null, result);\n\t      };\n\t\n\t      this.collection.kuzzle.callbackRequired('SearchResult.fetchNext', cb);\n\t\n\t      if (this.fetched >= this.total) {\n\t        return cb(null, null);\n\t      }\n\t\n\t      // retrieve next results with scroll if original search use it\n\t      if (this.options.scrollId) {\n\t        this.collection.scroll(this.options.scrollId, null, this.filters || {}, updateAfterSearch);\n\t        return;\n\t      }\n\t\n\t      // retrieve next results using ES's search_after\n\t      if (this.options.size !== undefined && this.filters.sort) {\n\t        var filters = Object.assign({}, this.filters, { search_after: [] }),\n\t            lastDocumentContent = this.documents[this.documents.length - 1].content;\n\t\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t          for (var _iterator = filters.sort[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var sortRule = _step.value;\n\t\n\t            if (typeof sortRule === 'string') {\n\t              filters.search_after.push(lastDocumentContent[sortRule]);\n\t            } else {\n\t              filters.search_after.push(lastDocumentContent[Object.keys(sortRule)[0]]);\n\t            }\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError = true;\n\t          _iteratorError = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t              _iterator.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError) {\n\t              throw _iteratorError;\n\t            }\n\t          }\n\t        }\n\t\n\t        this.collection.search(filters, { size: this.options.size }, updateAfterSearch);\n\t        return;\n\t      }\n\t\n\t      // retrieve next results with from/size if original search use it\n\t      if (this.options.from !== undefined && this.options.size !== undefined) {\n\t        // check if we need to do next request to fetch all matching documents\n\t        var opts = {\n\t          from: this.options.from + this.options.size,\n\t          size: this.options.size\n\t        };\n\t\n\t        if (opts.from >= this.total) {\n\t          return cb(null, null);\n\t        }\n\t\n\t        this.collection.search(this.filters, opts, updateAfterSearch);\n\t        return;\n\t      }\n\t\n\t      cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n\t    }\n\t  }]);\n\t\n\t  return SearchResult;\n\t}();\n\t\n\tmodule.exports = SearchResult;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar RTWrapper = __webpack_require__(4);\n\t\n\tvar SocketIO = function (_RTWrapper) {\n\t  _inherits(SocketIO, _RTWrapper);\n\t\n\t  function SocketIO(host, options) {\n\t    _classCallCheck(this, SocketIO);\n\t\n\t    var _this = _possibleConstructorReturn(this, (SocketIO.__proto__ || Object.getPrototypeOf(SocketIO)).call(this, host, options));\n\t\n\t    _this.socket = null;\n\t    _this.forceDisconnect = false;\n\t    _this.eventsWrapper = {};\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Connect to the SocketIO server\n\t   */\n\t\n\t\n\t  _createClass(SocketIO, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\t\n\t      _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'connect', this).call(this);\n\t\n\t      this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n\t        reconnection: this.autoReconnect,\n\t        reconnectionDelay: this.reconnectionDelay,\n\t        forceNew: true\n\t      });\n\t\n\t      this.socket.on('connect', function () {\n\t        return _this2.clientConnected();\n\t      });\n\t      this.socket.on('connect_error', function (error) {\n\t        return _this2.clientNetworkError(error);\n\t      });\n\t\n\t      this.socket.on('disconnect', function () {\n\t        if (_this2.forceDisconnect) {\n\t          _this2.clientDisconnected();\n\t        } else {\n\t          var error = new Error('An error occurred, kuzzle may not be ready yet');\n\t          error.status = 500;\n\t\n\t          _this2.clientNetworkError(error);\n\t        }\n\t\n\t        _this2.forceDisconnect = false;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Registers a callback on an event.\n\t     *\n\t     * @param {string} event\n\t     * @param {function} callback\n\t     */\n\t\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(event, callback) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      this._addEventWrapper(event, callback, once);\n\t      _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'addListener', this).call(this, event, callback, once);\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'prependListener',\n\t    value: function prependListener(event, callback) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      this._addEventWrapper(event, callback, once);\n\t      return _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'prependListener', this).call(this, event, callback, once);\n\t    }\n\t\n\t    /**\n\t     * Unregisters a callback from an event.\n\t     *\n\t     * @param {string} event\n\t     * @param {function} callback\n\t     */\n\t\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(event, callback) {\n\t      if (this.eventsWrapper[event]) {\n\t        this.eventsWrapper[event].listeners.delete(callback);\n\t\n\t        if (this.eventsWrapper[event].listeners.size === 0) {\n\t          this.socket.off(event, this.eventsWrapper[event].wrapper);\n\t          delete this.eventsWrapper[event];\n\t        }\n\t\n\t        _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'removeListener', this).call(this, event, callback);\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unregisters all listeners either from an event, or from all events\n\t     *\n\t     * @param {string} [event]\n\t     */\n\t\n\t  }, {\n\t    key: 'removeAllListeners',\n\t    value: function removeAllListeners(event) {\n\t      if (event !== undefined) {\n\t        if (this.eventsWrapper[event] !== undefined) {\n\t          var _iteratorNormalCompletion = true;\n\t          var _didIteratorError = false;\n\t          var _iteratorError = undefined;\n\t\n\t          try {\n\t            for (var _iterator = this.eventsWrapper[event].listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t              var listener = _step.value;\n\t\n\t              this.removeListener(event, listener);\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError) {\n\t                throw _iteratorError;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        var _iteratorNormalCompletion2 = true;\n\t        var _didIteratorError2 = false;\n\t        var _iteratorError2 = undefined;\n\t\n\t        try {\n\t          for (var _iterator2 = Object.keys(this.eventsWrapper)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t            var _event = _step2.value;\n\t\n\t            this.removeAllListeners(_event);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError2 = true;\n\t          _iteratorError2 = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t              _iterator2.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError2) {\n\t              throw _iteratorError2;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Sends a payload to the connected server\n\t     *\n\t     * @param {Object} payload\n\t     */\n\t\n\t  }, {\n\t    key: 'send',\n\t    value: function send(payload) {\n\t      this.socket.emit('kuzzle', payload);\n\t    }\n\t\n\t    /**\n\t     * Closes the connection\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      this.forceDisconnect = true;\n\t      this.state = 'offline';\n\t      this.socket.close();\n\t      this.socket = null;\n\t    }\n\t  }, {\n\t    key: '_addEventWrapper',\n\t    value: function _addEventWrapper(event, callback) {\n\t      var _this3 = this;\n\t\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!this.eventsWrapper[event]) {\n\t        var wrapper = function wrapper() {\n\t          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t            args[_key] = arguments[_key];\n\t          }\n\t\n\t          return _this3.emit.apply(_this3, [event].concat(args));\n\t        };\n\t\n\t        this.eventsWrapper[event] = {\n\t          wrapper: wrapper,\n\t          listeners: new Set()\n\t        };\n\t\n\t        if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n\t          if (once) {\n\t            this.socket.once(event, wrapper);\n\t          } else {\n\t            this.socket.on(event, wrapper);\n\t          }\n\t        }\n\t      }\n\t\n\t      this.eventsWrapper[event].listeners.add(callback);\n\t    }\n\t  }]);\n\t\n\t  return SocketIO;\n\t}(RTWrapper);\n\t\n\tmodule.exports = SocketIO;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar RTWrapper = __webpack_require__(4);\n\t\n\tvar WebSocketClient = void 0;\n\t\n\tvar WSNode = function (_RTWrapper) {\n\t  _inherits(WSNode, _RTWrapper);\n\t\n\t  function WSNode(host, options) {\n\t    _classCallCheck(this, WSNode);\n\t\n\t    var _this = _possibleConstructorReturn(this, (WSNode.__proto__ || Object.getPrototypeOf(WSNode)).call(this, host, options));\n\t\n\t    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"ws\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t    _this.client = null;\n\t    _this.lasturl = null;\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Connect to the websocket server\n\t   */\n\t\n\t\n\t  _createClass(WSNode, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\t\n\t      var url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n\t          opts = typeof window !== 'undefined' ? undefined : { perMessageDeflate: false };\n\t\n\t      _get(WSNode.prototype.__proto__ || Object.getPrototypeOf(WSNode.prototype), 'connect', this).call(this);\n\t\n\t      if (url !== this.lasturl) {\n\t        this.wasConnected = false;\n\t        this.lasturl = url;\n\t      }\n\t\n\t      this.client = new WebSocketClient(url, opts);\n\t\n\t      this.client.onopen = function () {\n\t        _this2.clientConnected();\n\t      };\n\t\n\t      this.client.onclose = function (closeEvent, message) {\n\t        var status = void 0,\n\t            reason = message;\n\t\n\t        if (typeof closeEvent === 'number') {\n\t          status = closeEvent;\n\t        } else {\n\t          status = closeEvent.code;\n\t\n\t          if (closeEvent.reason) {\n\t            reason = closeEvent.reason;\n\t          }\n\t        }\n\t\n\t        if (status === 1000) {\n\t          _this2.clientDisconnected();\n\t        }\n\t        // do not forward a connection close error if no \n\t        // connection has been previously established\n\t        else if (_this2.wasConnected) {\n\t            var error = new Error(reason);\n\t            error.status = status;\n\t\n\t            _this2.clientNetworkError(error);\n\t          }\n\t      };\n\t\n\t      this.client.onerror = function (error) {\n\t        var err = error instanceof Error && error || new Error(error);\n\t\n\t        _this2.clientNetworkError(err);\n\t      };\n\t\n\t      this.client.onmessage = function (payload) {\n\t        var data = JSON.parse(payload.data || payload);\n\t\n\t        if (data.room) {\n\t          _this2.emit(data.room, data);\n\t        } else {\n\t          _this2.emit('discarded', data);\n\t        }\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Sends a payload to the connected server\n\t     *\n\t     * @param {Object} payload\n\t     */\n\t\n\t  }, {\n\t    key: 'send',\n\t    value: function send(payload) {\n\t      if (this.client && this.client.readyState === this.client.OPEN) {\n\t        this.client.send(JSON.stringify(payload));\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Closes the connection\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      this.state = 'offline';\n\t      this.removeAllListeners();\n\t      this.wasConnected = false;\n\t      if (this.client) {\n\t        this.client.close();\n\t      }\n\t      this.client = null;\n\t      this.stopRetryingToConnect = true;\n\t    }\n\t  }]);\n\t\n\t  return WSNode;\n\t}(RTWrapper);\n\t\n\tmodule.exports = WSNode;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSearchResult = __webpack_require__(8),\n\t  Document = __webpack_require__(2),\n\t  CollectionMapping = __webpack_require__(12),\n\t  Room = __webpack_require__(7);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n\t * or like a room for pub/sub messages.\n\t *\n\t * @property {string} collection\n\t * @property {string} index\n\t * @property {Kuzzle} kuzzle\n\t * @property {Array.<string>} collection\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @param {string} collection - name of the data collection to handle\n\t * @param {string} index - Index containing the data collection\n\t * @constructor\n\t */\n\tfunction Collection(kuzzle, collection, index) {\n\t  if (!index || !collection) {\n\t    throw new Error('The Collection object constructor needs an index and a collection arguments');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    index: {\n\t      value: index,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (controller, action) {\n\t      return {\n\t        controller: controller,\n\t        action: action,\n\t        collection: this.collection,\n\t        index: this.index\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['subscribe'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of documents matching the provided set of filters.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created won’t be returned by this function\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.count = function (filters, options, cb) {\n\t  var query = {body: filters};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.count', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new empty data collection, with no associated mapping.\n\t * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n\t * want to create and prepare data collections before storing documents in it.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.create = function (options, cb) {\n\t  var data = {},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n\t *        If the same document already exists:\n\t *          - resolves with an error if set to \"error\".\n\t *          - replaces the existing document if set to \"replace\"\n\t *\n\t * @param {string} [id] - (optional) document identifier\n\t * @param {object} document - either an instance of a Document object, or a document\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tCollection.prototype.createDocument = function (id, document, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'create';\n\t\n\t  if (id && typeof id !== 'string') {\n\t    cb = options;\n\t    options = document;\n\t    document = id;\n\t    id = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (document instanceof Document) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  if (options && options.ifExist) {\n\t    if (options.ifExist === 'replace') {\n\t      action = 'createOrReplace';\n\t    }\n\t    else if (options.ifExist !== 'error') {\n\t      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n\t    }\n\t  }\n\t\n\t  if (id) {\n\t    data._id = id;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    var doc;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    doc.version = res.result._version;\n\t    cb(null, doc);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete persistent documents.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created won’t be returned by this function\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Collection} this\n\t */\n\tCollection.prototype.deleteDocument = function (arg, options, cb) {\n\t  var\n\t    action,\n\t    data = {};\n\t\n\t  if (typeof arg === 'string') {\n\t    data._id = arg;\n\t    action = 'delete';\n\t  } else {\n\t    data.body = {query: arg};\n\t    action = 'deleteByQuery';\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      cb(err);\n\t    }\n\t    else {\n\t      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Deletes the current specifications of this collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @return {object} this\n\t */\n\tCollection.prototype.deleteSpecifications = function (options, cb) {\n\t  var\n\t    data = { index: this.index, collection: this.collection },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Returns a boolean indicating whether or not a document with provided ID exists.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} options [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.documentExists = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve a single stored document using its unique document ID.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.fetchDocument = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.fetch', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiates a CollectionMapping object containing the current mapping of this collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t */\n\tCollection.prototype.getMapping = function (options, cb) {\n\t  var kuzzleMapping;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\t\n\t  kuzzleMapping = new CollectionMapping(this);\n\t  kuzzleMapping.refresh(options, cb);\n\t};\n\t\n\t/**\n\t * Create the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to create\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mCreateDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {},\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n\t    cb(err, res && res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Create or replace the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to create or replace\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {},\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n\t    cb(err, res && res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Delete specific documents according to given IDs\n\t *\n\t * @param {Array.<string>} documentIds - IDs of the documents to delete\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n\t  var data = {\n\t      body: {\n\t        ids: documentIds\n\t      }\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documentIds)) {\n\t    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n\t    cb(err, res && res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Get specific documents according to given IDs\n\t *\n\t * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t */\n\tCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n\t  var data = {\n\t      body: {\n\t        ids: documentIds\n\t      }\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documentIds)) {\n\t    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Replace the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to replace\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {}\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Update the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to update\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {}\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n\t    cb(err, res && res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Retrieves the current specifications of this collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.getSpecifications = function (options, cb) {\n\t  var\n\t    data = { index: this.index, collection: this.collection },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Publish a realtime message\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} document - either a Document instance or a JSON object\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.publishMessage = function (document, options, cb) {\n\t  var data = {};\n\t\n\t  if (document instanceof Document) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replace an existing document with a new one.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to replace\n\t * @param {object} content - JSON object representing the new document version\n\t * @param {object} [options] - additional arguments\n\t * @param {responseCallback} [cb] - Returns an instantiated Document object\n\t * @return {object} this\n\t */\n\tCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Executes an advanced search on the data collection.\n\t *\n\t * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created won’t be returned by this function.\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\t\n\tCollection.prototype.search = function (filters, options, cb) {\n\t  var\n\t    query = {body: filters},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.search', cb);\n\t\n\t  self.kuzzle.query(self.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(self, filters, options, result));\n\t  });\n\t};\n\t\n\t/**\n\t * A \"scroll\" option can be passed to search queries, creating persistent\n\t * paginated results.\n\t * This method can be used to manually get the next page of a search result,\n\t * instead of using KuzzleSearchResult.next()\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {object} [filters]\n\t * @param {responseCallback} cb\n\t */\n\tCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Collection.scroll: scrollId is required');\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(self, filters, options, result));\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieves next result of a search with scroll query.\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n\t  var\n\t    data = { scrollId: scrollId };\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Collection.scrollSpecifications: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\t\n\t  this.kuzzle.query(\n\t    { controller: 'collection', action: 'scrollSpecifications'},\n\t    data,\n\t    options,\n\t    function (err, res) {\n\t      cb (err, err ? undefined : res.result);\n\t    }\n\t  );\n\t};\n\t\n\t/**\n\t * Searches specifications across indexes/collections according to the provided filters\n\t *\n\t * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.searchSpecifications = function (filters, options, cb) {\n\t  var\n\t    data = { body: { query: filters } },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\t\n\t  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a subscription room to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @returns {*} KuzzleRoom object\n\t */\n\tCollection.prototype.room = function (filters, options) {\n\t  return new Room(this, filters, options);\n\t};\n\t\n\t/**\n\t * Subscribes to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @param {responseCallback} notificationCB - called for each new notification\n\t * @returns {*} KuzzleRoom object\n\t */\n\tCollection.prototype.subscribe = function (filters, options, notificationCB) {\n\t  var\n\t    evtName,\n\t    room;\n\t\n\t  if (!notificationCB && typeof options === 'function') {\n\t    notificationCB = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.subscribe', notificationCB);\n\t\n\t  evtName = (options && options.users && options.users !== 'none') ? 'user' : 'document';\n\t  room = new Room(this, filters, options);\n\t\n\t  room.subscribe().on(evtName, notificationCB);\n\t  return room;\n\t};\n\t\n\t/**\n\t * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n\t * This method is a lot faster than removing all documents using a query.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.truncate = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Update parts of a document\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to update\n\t * @param {object} content - JSON object containing changes to perform on the document\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Returns an instantiated Document object\n\t * @return {object} this\n\t */\n\tCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n\t  var data = {\n\t      _id: documentId,\n\t      body: content\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options && options.retryOnConflict) {\n\t    data.retryOnConflict = options.retryOnConflict;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    (new Document(self, res.result._id)).refresh(cb);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Updates the current specifications of this collection\n\t *\n\t * @param {object} specifications - Specifications content\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @return {object} this\n\t */\n\tCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n\t  var\n\t    collection = {},\n\t    data = { body: {} },\n\t    self = this;\n\t\n\t  collection[this.collection] = specifications;\n\t  data.body[this.index] = collection;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Validates the provided specifications\n\t *\n\t * @param {object} specifications - Specifications content\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n\t  var\n\t    collection = {},\n\t    data = { body: {} },\n\t    self = this;\n\t\n\t  collection[this.collection] = specifications;\n\t  data.body[this.index] = collection;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.valid);\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - document id\n\t * @param {object} content - document content\n\t * @constructor\n\t */\n\tCollection.prototype.document = function (id, content) {\n\t  return new Document(this, id, content);\n\t};\n\t\n\t/**\n\t * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n\t * @constructor\n\t */\n\tCollection.prototype.collectionMapping = function (mapping) {\n\t  return new CollectionMapping(this, mapping);\n\t};\n\t\n\tmodule.exports = Collection;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n\t *  It means that, by default, you won’t be able to exploit the full capabilities of our persistent data storage layer\n\t *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n\t *  the amount of data you stored in a collection and the complexity of your database.\n\t *\n\t *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n\t *\n\t * @param {object} collection - Instance of the inherited Collection object\n\t * @param {object} [mapping] - mappings\n\t * @constructor\n\t */\n\tfunction CollectionMapping(collection, mapping) {\n\t  Object.defineProperties(this, {\n\t    //read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    mapping: {\n\t      value: mapping || {},\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['set'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Applies the new mapping to the data collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tCollectionMapping.prototype.apply = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      body: {\n\t        properties: this.mapping\n\t      }\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n\t    if (err) {\n\t      return cb && cb(err);\n\t    }\n\t\n\t    self.refresh(options, cb);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with the mapping stored in Kuzzle\n\t *\n\t * Calling this function will discard any uncommited changes. You can commit changes by calling the “apply” function\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tCollectionMapping.prototype.refresh = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n\t    if (err) {\n\t      return cb ? cb(err) : false;\n\t    }\n\t\n\t    if (res.result[self.collection.index]) {\n\t      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n\t        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\t\n\t        // Mappings can be empty. The mapping property should never be \"undefined\"\n\t        if (self.mapping === undefined) {\n\t          self.mapping = {};\n\t        }\n\t      } else {\n\t        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n\t      }\n\t    } else {\n\t      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Adds or updates a field mapping.\n\t *\n\t * Changes made by this function won’t be applied until you call the apply method\n\t *\n\t * @param {string} field - Name of the field from which the mapping is to be added or updated\n\t * @param {object} mapping - corresponding field mapping\n\t * @returns {CollectionMapping}\n\t */\n\tCollectionMapping.prototype.set = function (field, mapping) {\n\t  this.mapping[field] = mapping;\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = CollectionMapping;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t// Parameter mutualization\n\tvar\n\t  getId = {getter: true, required: ['_id']},\n\t  getIdField = {getter: true, required: ['_id', 'field']},\n\t  getKeys = {getter: true, required: ['keys']},\n\t  getMember = {getter: true, required: ['_id', 'member']},\n\t  getxScan = {\n\t    getter: true, \n\t    required: ['_id', 'cursor'], \n\t    opts: ['match', 'count'],\n\t    mapResults: mapScanResults\n\t  },\n\t  getZrange = {\n\t    getter: true,\n\t    required: ['_id', 'start', 'stop'],\n\t    opts: assignZrangeOptions,\n\t    mapResults: mapZrangeResults\n\t  },\n\t  getZrangeBy = {\n\t    getter: true,\n\t    required: ['_id', 'min', 'max'],\n\t    opts: assignZrangeOptions,\n\t    mapResults: mapZrangeResults\n\t  },\n\t  setId = {required: ['_id']},\n\t  setIdValue = {required: ['_id', 'value']};\n\t\n\t// Redis commands\n\tvar\n\t  commands = {\n\t    append: setIdValue,\n\t    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n\t    bitop: {required: ['_id', 'operation', 'keys']},\n\t    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n\t    dbsize: {getter: true},\n\t    decr: setId,\n\t    decrby: setIdValue,\n\t    del: {required: ['keys']},\n\t    exists: getKeys,\n\t    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n\t    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n\t    flushdb: {mapResults: mapNoResult},\n\t    geoadd: {required: ['_id', 'points']},\n\t    geodist: {\n\t      getter: true,\n\t      required: ['_id', 'member1', 'member2'],\n\t      opts: ['unit'],\n\t      mapResults: parseFloat\n\t    },\n\t    geohash: {getter: true, required: ['_id', 'members']},\n\t    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n\t    georadius: {\n\t      getter: true,\n\t      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n\t      opts: assignGeoRadiusOptions,\n\t      mapResults: mapGeoRadiusResults\n\t    },\n\t    georadiusbymember: {\n\t      getter: true,\n\t      required: ['_id', 'member', 'distance', 'unit'],\n\t      opts: assignGeoRadiusOptions,\n\t      mapResults: mapGeoRadiusResults\n\t    },\n\t    get: getId,\n\t    getbit: {getter: true, required: ['_id', 'offset']},\n\t    getrange: {getter: true, required: ['_id', 'start', 'end']},\n\t    getset: setIdValue,\n\t    hdel: {required: ['_id', 'fields']},\n\t    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n\t    hget: getIdField,\n\t    hgetall: {getter: true, required: ['_id']},\n\t    hincrby: {required: ['_id', 'field', 'value']},\n\t    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n\t    hkeys: getId,\n\t    hlen: getId,\n\t    hmget: {getter: true, required: ['_id', 'fields']},\n\t    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n\t    hscan: getxScan,\n\t    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n\t    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n\t    hstrlen: getIdField,\n\t    hvals: getId,\n\t    incr: setId,\n\t    incrby: setIdValue,\n\t    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n\t    keys: {getter: true, required: ['pattern']},\n\t    lindex: {getter: true, required: ['_id', 'idx']},\n\t    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n\t    llen: getId,\n\t    lpop: setId,\n\t    lpush: {required: ['_id', 'values']},\n\t    lpushx: setIdValue,\n\t    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n\t    lrem: {required: ['_id', 'count', 'value']},\n\t    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n\t    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n\t    mget: getKeys,\n\t    mset: {required: ['entries'], mapResults: mapNoResult},\n\t    msetnx: {required: ['entries'], mapResults: Boolean},\n\t    object: {getter: true, required: ['_id', 'subcommand']},\n\t    persist: {required: ['_id'], mapResults: Boolean},\n\t    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n\t    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n\t    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n\t    pfcount: getKeys,\n\t    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n\t    ping: {getter: true},\n\t    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n\t    pttl: getId,\n\t    randomkey: {getter: true},\n\t    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n\t    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n\t    rpop: setId,\n\t    rpoplpush: {required: ['source', 'destination']},\n\t    rpush: {required: ['_id', 'values']},\n\t    rpushx: setIdValue,\n\t    sadd: {required: ['_id', 'members']},\n\t    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n\t    scard: getId,\n\t    sdiff: {getter: true, required: ['_id', 'keys']},\n\t    sdiffstore: {required: ['_id', 'keys', 'destination']},\n\t    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n\t    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n\t    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n\t    sinter: getKeys,\n\t    sinterstore: {required: ['destination', 'keys']},\n\t    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n\t    smembers: getId,\n\t    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n\t    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n\t    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n\t    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n\t    srem: {required: ['_id', 'members']},\n\t    sscan: getxScan,\n\t    strlen: getId,\n\t    sunion: getKeys,\n\t    sunionstore: {required: ['destination', 'keys']},\n\t    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n\t    touch: {required: ['keys']},\n\t    ttl: getId,\n\t    type: getId,\n\t    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n\t    zcard: getId,\n\t    zcount: {getter: true, required: ['_id', 'min', 'max']},\n\t    zincrby: {required: ['_id', 'member', 'value']},\n\t    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n\t    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n\t    zrange: getZrange,\n\t    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n\t    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n\t    zrangebyscore: getZrangeBy,\n\t    zrank: getMember,\n\t    zrem: {required: ['_id', 'members']},\n\t    zremrangebylex: {required: ['_id', 'min', 'max']},\n\t    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n\t    zremrangebyscore: {required: ['_id', 'min', 'max']},\n\t    zrevrange: getZrange,\n\t    zrevrangebyscore: getZrangeBy,\n\t    zrevrank: getMember,\n\t    zscan: getxScan,\n\t    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n\t    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n\t  };\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t * Kuzzle's memory storage is a separate data store from the database layer.\n\t * It is internaly based on Redis. You can access most of Redis functions (all\n\t * lowercased), except functions falling in the following categories:\n\t *\n\t *  - blocking functions\n\t *  - cluster commands\n\t *  - configuration commands\n\t *  - cursor functions\n\t *  - database administration commands\n\t *  - debugging functions\n\t *  - script based functions\n\t *  - transaction functions\n\t *\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @constructor\n\t */\n\tfunction MemoryStorage(kuzzle) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = [];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t// Dynamically builds this class' prototypes using the \"commands\" global variable\n\t(function () {\n\t  Object.keys(commands).forEach(function (command) {\n\t    MemoryStorage.prototype[command] = function () {\n\t      var\n\t        args = Array.prototype.slice.call(arguments),\n\t        options = null,\n\t        cb,\n\t        query = {\n\t          controller: 'ms',\n\t          action: command\n\t        },\n\t        data = {};\n\t\n\t      if (args.length && typeof args[args.length - 1] === 'function') {\n\t        cb = args.pop();\n\t      }\n\t\n\t      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\t\n\t      if (!commands[command].getter) {\n\t        data.body = {};\n\t      }\n\t\n\t      if (commands[command].required) {\n\t        commands[command].required.forEach(function (param) {\n\t          var value = args.shift();\n\t\n\t          if (value === undefined) {\n\t            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n\t          }\n\t\n\t          assignParameter(data, commands[command].getter, param, value);\n\t        });\n\t      }\n\t\n\t      if (args.length > 1) {\n\t        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n\t      }\n\t\n\t      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n\t        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n\t      }\n\t\n\t      if (args.length) {\n\t        options = Object.assign({}, args[0]);\n\t\n\t        if (Array.isArray(commands[command].opts)) {\n\t          commands[command].opts.forEach(function (opt) {\n\t            if (options[opt] !== null && options[opt] !== undefined) {\n\t              assignParameter(data, commands[command].getter, opt, options[opt]);\n\t              delete options[opt];\n\t            }\n\t          });\n\t        }\n\t      }\n\t\n\t      /*\n\t       Options function mapper does not necessarily need\n\t       options to be passed by clients.\n\t       */\n\t      if (typeof commands[command].opts === 'function') {\n\t        commands[command].opts(data, options || {});\n\t      }\n\t\n\t      this.kuzzle.query(query, data, options, cb && function (err, res) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t\n\t        if (commands[command].mapResults) {\n\t          return cb(null, commands[command].mapResults(res.result));\n\t        }\n\t\n\t        cb(null, res.result);\n\t      });\n\t\n\t      if (!commands[command].getter) {\n\t        return this;\n\t      }\n\t    };\n\t  });\n\t})();\n\t\n\t/**\n\t *\n\t * @param {object} data - target data object\n\t * @param {boolean} getter - tells if the command is a getter one\n\t * @param {string} name - parameter name\n\t * @param {*} value - parameter value\n\t */\n\tfunction assignParameter(data, getter, name, value) {\n\t  if (getter || name === '_id') {\n\t    data[name] = value;\n\t  }\n\t  else {\n\t    data.body[name] = value;\n\t  }\n\t}\n\t\n\t/**\n\t * Assign the provided options for the georadius* redis functions\n\t * to the request object, as expected by Kuzzle API\n\t *\n\t * Mutates the provided data and options objects\n\t *\n\t * @param {object} data\n\t * @param {object} options\n\t */\n\tfunction assignGeoRadiusOptions(data, options) {\n\t  var parsed = [];\n\t\n\t  Object.keys(options)\n\t    .filter(function (opt) {\n\t      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n\t    })\n\t    .forEach(function (opt) {\n\t      if (opt === 'withcoord' || opt === 'withdist') {\n\t        parsed.push(opt);\n\t        delete options[opt];\n\t      }\n\t      else if (opt === 'count' || opt === 'sort') {\n\t        if (opt === 'count') {\n\t          parsed.push('count');\n\t        }\n\t\n\t        parsed.push(options[opt]);\n\t      }\n\t\n\t      delete options[opt];\n\t    });\n\t\n\t  if (parsed.length > 0) {\n\t    data.options = parsed;\n\t  }\n\t}\n\t\n\t/**\n\t * Force the WITHSCORES option on z*range* routes\n\t *\n\t * Mutates the provided data and options objects\n\t *\n\t * @param {object} data\n\t * @param {object} options\n\t */\n\tfunction assignZrangeOptions(data, options) {\n\t  data.options = ['withscores'];\n\t\n\t  if (options.limit) {\n\t    data.limit = options.limit;\n\t    delete options.limit;\n\t  }\n\t}\n\t\n\t/**\n\t * Maps geopos results, from array<array<string>> to array<array<number>>\n\t *\n\t * @param {Array.<Array.<string>>} results\n\t * @return {Array.<Array.<Number>>}\n\t */\n\tfunction mapGeoposResults(results) {\n\t  return results.map(function (coords) {\n\t    return coords.map(function (latlon) {\n\t      return parseFloat(latlon);\n\t    });\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Maps georadius results to the format specified in the SDK documentation,\n\t * preventing different formats depending on the passed options\n\t *\n\t * Results can be either an array of point names, or an array\n\t * of arrays, each one of them containing the point name,\n\t * and additional informations depending on the passed options\n\t * (coordinates, distances)\n\t *\n\t * @param {Array} results\n\t * @return {Array.<Object>}\n\t */\n\tfunction mapGeoRadiusResults(results) {\n\t  // Simple array of point names (no options provided)\n\t  if (!Array.isArray(results[0])) {\n\t    return results.map(function (point) {\n\t      return {name: point};\n\t    });\n\t  }\n\t\n\t  return results.map(function (point) {\n\t    // The point id is always the first item\n\t    var p = {\n\t        name: point[0]\n\t      },\n\t      i;\n\t\n\t    for (i = 1; i < point.length; i++) {\n\t      // withcoord result are in an array...\n\t      if (Array.isArray(point[i])) {\n\t        p.coordinates = point[i].map(function (coord) {\n\t          return parseFloat(coord);\n\t        });\n\t      }\n\t      else {\n\t        // ... and withdist are not\n\t        p.distance = parseFloat(point[i]);\n\t      }\n\t    }\n\t\n\t    return p;\n\t  });\n\t}\n\t\n\t/**\n\t * Map a string result to an array of strings.\n\t * Used to uniformize polymorphic results from redis\n\t *\n\t * @param {Array|string} results\n\t * @return {Array.<string>}\n\t */\n\tfunction mapStringToArray(results) {\n\t  return Array.isArray(results) ? results : [results];\n\t}\n\t\n\t/**\n\t * Map an array of strings to an array of integers\n\t *\n\t * @param {Array.<string>} results\n\t * @return {Array.<Number>}\n\t */\n\tfunction mapArrayStringToArrayInt(results) {\n\t  return results.map(function (value) {\n\t    return parseInt(value);\n\t  });\n\t}\n\t\n\t/**\n\t * Disable results for routes like flushdb\n\t * @return {undefined}\n\t */\n\tfunction mapNoResult() {\n\t  return undefined;\n\t}\n\t\n\t/**\n\t * Map zrange results with WITHSCORES:\n\t * [\n\t *  \"member1\",\n\t *  \"score of member1\",\n\t *  \"member2\",\n\t *  \"score of member2\"\n\t * ]\n\t *\n\t * into the following format:\n\t * [\n\t *  {\"member\": \"member1\", \"score\": <score of member1>},\n\t *  {\"member\": \"member2\", \"score\": <score of member2>},\n\t * ]\n\t *\n\t *\n\t * @param {Array.<string>} results\n\t * @return {Array.<Object>}\n\t */\n\tfunction mapZrangeResults(results) {\n\t  var\n\t    buffer = null,\n\t    mapped = [];\n\t\n\t  results.forEach(function (value) {\n\t    if (buffer === null) {\n\t      buffer = value;\n\t    }\n\t    else {\n\t      mapped.push({member: buffer, score: parseFloat(value)});\n\t      buffer = null;\n\t    }\n\t  });\n\t\n\t  return mapped;\n\t}\n\t\n\t/**\n\t * Map *scan calls results, from:\n\t * [\n\t *   \"<cursor>\",\n\t *   [\n\t *     \"value1\",\n\t *     \"value2\", \n\t *     \"...\"\n\t *   ]\n\t * ]\n\t *\n\t * To:\n\t * {\n\t *   cursor: <cursor>,\n\t *   values: [\n\t *     \"value1\",\n\t *     \"value2\",\n\t *     \"...\"\n\t *   ]\n\t * }\n\t * \n\t * @param  {array.<string|array>} results \n\t * @return {object}\n\t */\n\tfunction mapScanResults(results) {\n\t  return {\n\t    cursor: results[0],\n\t    values: results[1]\n\t  };\n\t}\n\t\n\tmodule.exports = MemoryStorage;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t *\n\t * @param protocol\n\t * @param host\n\t * @param options\n\t * @returns {Object} Instantiated WebSocket/Socket.IO object\n\t */\n\t\n\tfunction network(protocol, host, options) {\n\t  switch (protocol) {\n\t    case 'websocket':\n\t      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n\t        throw new Error('Aborting: no websocket support detected.');\n\t      }\n\t      return new (__webpack_require__(10))(host, options);\n\t    case 'socketio':\n\t      if (!window.io) {\n\t        throw new Error('Aborting: no socket.io library loaded.');\n\t      }\n\t      return new (__webpack_require__(9))(host, options);\n\t    default:\n\t      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n\t  }\n\t}\n\t\n\tmodule.exports = network;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SecurityDocument = __webpack_require__(3);\n\t\n\tfunction Profile(Security, id, content, meta) {\n\t\n\t  SecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteProfile'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateProfile'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['hydrate', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tProfile.prototype = Object.create(SecurityDocument.prototype, {\n\t  constructor: {\n\t    value: Profile\n\t  }\n\t});\n\t\n\t/**\n\t * Persist to the persistent layer the current profile\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.save = function (options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!this.content.policies) {\n\t    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.serialize();\n\t\n\t  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Add a policy in the policies list\n\t * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n\t *\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.addPolicy = function (policy) {\n\t\n\t  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n\t  }\n\t\n\t  if (!this.content.policies) {\n\t    this.content.policies = [];\n\t  }\n\t\n\t  this.content.policies.push(policy);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set policies list\n\t * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.setPolicies = function (policies) {\n\t\n\t  if (!Array.isArray(policies)) {\n\t    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t  }\n\t\n\t  policies.map(function (policy) {\n\t    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t    }\n\t  });\n\t\n\t  this.content.policies = policies;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this securityDocument\n\t */\n\tProfile.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Returns the list of policies associated to this profile.\n\t * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @return {object} an array of policies\n\t */\n\tProfile.prototype.getPolicies = function () {\n\t  return this.content.policies;\n\t};\n\t\n\tmodule.exports = Profile;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SecurityDocument = __webpack_require__(3);\n\t\n\tfunction Role(Security, id, content, meta) {\n\t\n\t  SecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteRole'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateRole'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tRole.prototype = Object.create(SecurityDocument.prototype, {\n\t  constructor: {\n\t    value: Role\n\t  }\n\t});\n\t\n\t/**\n\t * Saves this role into Kuzzle.\n\t *\n\t * If this is a new role, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Role} this object\n\t */\n\tRole.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = Role;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  Role = __webpack_require__(16),\n\t  Profile = __webpack_require__(15),\n\t  User = __webpack_require__(5);\n\t\n\t/**\n\t * Kuzzle security constructor\n\t *\n\t * @param kuzzle\n\t * @returns {Security}\n\t * @constructor\n\t */\n\tfunction Security(kuzzle) {\n\t\n\t  Object.defineProperty(this, 'kuzzle', {\n\t    value: kuzzle\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (action) {\n\t      return {\n\t        controller: 'security',\n\t        action: action\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * Retrieve a single Role using its unique role ID.\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchRole = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!id) {\n\t    throw new Error('Id parameter is mandatory for fetchRole function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on roles according to a filter\n\t *\n\t * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been created won’t be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t *\n\t */\n\tSecurity.prototype.searchRoles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = result.result.hits.map(function (doc) {\n\t      return new Role(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    cb(null, { total: result.result.total, roles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new role in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same role already exists: throw an error if sets to false.\n\t *        Replace the existing role otherwise\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.createRole: cannot create a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a role in Kuzzle.\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content},\n\t    action = 'updateRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateRole: cannot update a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete role.\n\t *\n\t * There is a small delay between role deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Role id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteRole = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - role id\n\t * @param {object} content - role content\n\t * @param {object} meta - role metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.role = function(id, content, meta) {\n\t  return new Role(this, id, content, meta);\n\t};\n\t\n\t\n\t/**\n\t * Get a specific profile from kuzzle\n\t *\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchProfile = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for fetchProfile function');\n\t  }\n\t\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n\t    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on profiles according to a filter\n\t *\n\t *\n\t * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been created won’t be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.searchProfiles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n\t    var\n\t      documents,\n\t      scrollId;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new Profile(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    if (response.result.scrollId) {\n\t      scrollId = response.result.scrollId;\n\t    }\n\t\n\t    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new profile in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same profile already exists: throw an error if sets to false.\n\t *        Replace the existing profile otherwise\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {array} policies - list of policies to attach to the new profile\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createProfile = function (id, policies, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t\n\t  if (policies) {\n\t    data.body = { policies: policies };\n\t  }\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a profile in Kuzzle.\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {array} policies - the list of policies to apply to this profile\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t\n\t  if (policies) {\n\t    data.body = {policies: policies};\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    var updatedContent = {};\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    Object.keys(res.result._source).forEach(function (property) {\n\t      updatedContent[property] = res.result._source[property];\n\t    });\n\t\n\t    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete profile.\n\t *\n\t * There is a small delay between profile deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteProfile = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t */\n\tSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Security.scrollProfiles: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n\t    var profiles = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (profile) {\n\t      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\t\n\t      newProfile.version = profile._version;\n\t\n\t      profiles.push(newProfile);\n\t    });\n\t\n\t    cb(null, {\n\t      total: result.result.total,\n\t      profiles: profiles,\n\t      scrollId: scrollId\n\t    });\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - profile id\n\t * @param {object} content - profile content\n\t * @param {object} meta - profile metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.profile = function(id, content, meta) {\n\t  return new Profile(this, id, content, meta);\n\t};\n\t\n\t/**\n\t * Get a specific user from kuzzle using its unique ID\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchUser = function (id, options, cb) {\n\t  var\n\t    data = {_id: id},\n\t    self = this;\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for fetchUser function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on user according to a filter\n\t *\n\t * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been created won’t be returned by this function.\n\t *\n\t * @param {Object} filters - same filters as documents filters\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.searchUsers = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n\t    var\n\t      documents,\n\t      scrollId = null;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new User(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    if (response.result.scrollId) {\n\t      scrollId = response.result.scrollId;\n\t    }\n\t\n\t    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Replace an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.replaceUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new restricted user in Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profile` in `content` must only contains the profile id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (content.profileIds) {\n\t    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateUser: cannot update an user without an user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete user.\n\t *\n\t * There is a small delay between user deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteUser = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t */\n\tSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Security.scrollUsers: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n\t    var users = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (user) {\n\t      var newUser = new User(self, user._id, user._source, user._meta);\n\t\n\t      newUser.version = user._version;\n\t\n\t      users.push(newUser);\n\t    });\n\t\n\t    cb(null, {\n\t      total: result.result.total,\n\t      users: users,\n\t      scrollId: scrollId\n\t    });\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - user id\n\t * @param {object} content - user content\n\t * @param {object} meta - user metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.user = function(id, content, meta) {\n\t  return new User(this, id, content, meta);\n\t};\n\t\n\t/**\n\t * Tells whether an action is allowed, denied or conditional based on the rights\n\t * rights provided as the first argument. An action is defined as a couple of\n\t * action and controller (mandatory), plus an index and a collection(optional).\n\t *\n\t * @param {object} rights - The rights rights associated to a user\n\t *                            (see getMyrights and getUserrights).\n\t * @param {string} controller - The controller to check the action onto.\n\t * @param {string} action - The action to perform.\n\t * @param {string} index - (optional) The name of index to perform the action onto.\n\t * @param {string} collection - (optional) The name of the collection to perform the action onto.\n\t *\n\t * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n\t *                   correspond to rights containing closures.\n\t *                   See also http://kuzzle.io/guide/#roles-definition\n\t */\n\tSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n\t  var filteredRights;\n\t\n\t  if (!rights || typeof rights !== 'object') {\n\t    throw new Error('rights parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!controller || typeof controller !== 'string') {\n\t    throw new Error('controller parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!action || typeof action !== 'string') {\n\t    throw new Error('action parameter is mandatory for isActionAllowed function');\n\t  }\n\t\n\t  // We filter in all the rights that match the request (including wildcards).\n\t  filteredRights = rights\n\t    .filter(function (right) {\n\t      return right.controller === controller || right.controller === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.action === action || right.action === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.index === index || right.index === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.collection === collection || right.collection === '*';\n\t    });\n\t\n\t  // Then, if at least one right allows the action, we return 'allowed'\n\t  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n\t    return 'allowed';\n\t  }\n\t  // If no right allows the action, we check for conditionals.\n\t  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n\t    return 'conditional';\n\t  }\n\t  // Otherwise we return 'denied'.\n\t  return 'denied';\n\t};\n\t\n\t\n\t/**\n\t * Gets the rights array of a given user.\n\t *\n\t * @param {string} userId The id of the user.\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {function} cb The callback containing the normalized array of rights.\n\t */\n\tSecurity.prototype.getUserRights = function (userId, options, cb) {\n\t  var\n\t    data = {_id: userId},\n\t    self = this;\n\t\n\t  if (!userId || typeof userId !== 'string') {\n\t    throw new Error('userId parameter is mandatory for getUserRights function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Create credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result._source);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete credentials of the specified <strategy> for the user <kuid> .\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieve a list of accepted fields per authentication strategy.\n\t *\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getAllCredentialFields = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve the list of accepted field names by the specified <strategy>.\n\t *\n\t * @param strategy\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Get credential information of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Check the existence of the specified <strategy>’s credentials for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Updates credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Validate credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\tmodule.exports = Security;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t}\n\t\n\tfunction bytesToUuid(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = byteToHex;\n\t  return bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\tmodule.exports = bytesToUuid;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Unique ID creation requires a high quality random # generator.  In the\n\t// browser this is a little complicated due to unknown quality of Math.random()\n\t// and inconsistent support for the `crypto` API.  We do the best we can via\n\t// feature-detection\n\tvar rng;\n\t\n\tvar crypto = (window).crypto || (window).msCrypto; // for IE 11\n\tif (crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(rnds8);\n\t    return rnds8;\n\t  };\n\t}\n\t\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return rnds;\n\t  };\n\t}\n\t\n\tmodule.exports = rng;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// kuzzle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 46aa11891e581c379c84","const\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('./eventEmitter'),\n  Collection = require('./Collection.js'),\n  Document = require('./Document.js'),\n  Security = require('./security/Security'),\n  MemoryStorage = require('./MemoryStorage'),\n  User = require('./security/User'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n */\nclass Kuzzle extends KuzzleEventEmitter {\n  constructor(host, options) {\n    super();\n\n    if (!host || host === '') {\n      throw new Error('host argument missing');\n    }\n\n    Object.defineProperties(this, {\n      // 'private' properties\n      eventActions: {\n        value: [\n          'connected',\n          'discarded',\n          'disconnected',\n          'loginAttempt',\n          'networkError',\n          'offlineQueuePush',\n          'offlineQueuePop',\n          'queryError',\n          'reconnected',\n          'tokenExpired'\n        ]\n      },\n      // configuration properties\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true,\n        enumerable: true\n      },\n      defaultIndex: {\n        value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n        writable: true,\n        enumerable: true\n      },\n      jwt: {\n        value: undefined,\n        enumerable: true,\n        writable: true\n      },\n      protocol: {\n        value: (options && typeof options.protocol === 'string') ? options.protocol : 'websocket',\n        enumerable: true\n      },\n      sdkVersion: {\n        value: (typeof SDKVERSION === 'undefined') ? require('../package.json').version : SDKVERSION\n      },\n      volatile: {\n        value: {},\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      for (const opt of Object.keys(options)) {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      }\n    }\n\n    // Forward the subscribe query to the network wrapper\n    Object.defineProperty(this, 'subscribe', {\n      value: function(room, opts, subscribeCB) {\n        const\n          object = {\n            requestId: uuidv4(),\n            controller: 'realtime',\n            action: 'subscribe',\n            index: room.collection.index,\n            collection: room.collection.collection,\n            volatile: this.volatile,\n            body: room.filters,\n            scope: room.scope,\n            state: room.state,\n            users: room.users\n          },\n          notificationCB = data => {\n            if (data.type === 'TokenExpired') {\n              this.unsetJwt();\n              return this.emit('tokenExpired');\n            }\n\n            if (data.type === 'document') {\n              const copy = Object.assign({}, data);\n              copy.document = new Document(room.collection, data.result._id, data.result._source, data.result._meta);\n              delete copy.result;\n              return room.notify(copy);\n            }\n\n            room.notify(data);\n          };\n\n        if (this.jwt !== undefined) {\n          object.jwt = this.jwt;\n        }\n\n        Object.assign(object.volatile, room.volatile, {sdkInstanceId: this.network.id, sdkVersion: this.sdkVersion});\n\n        this.network.subscribe(object, opts, notificationCB, subscribeCB);\n      }\n    });\n\n    // Forward the unsubscribe query to the network wrapper\n    Object.defineProperty(this, 'unsubscribe', {\n      value: (room, unsubscribeCB) => {\n        const\n          object = {\n            requestId: uuidv4(),\n            controller: 'realtime',\n            action: 'unsubscribe',\n            volatile: this.volatile,\n            body: {roomId: room.roomId}\n          };\n\n        if (this.jwt !== undefined) {\n          object.jwt = this.jwt;\n        }\n\n        Object.assign(object.volatile, room.volatile, {sdkInstanceId: this.network.id, sdkVersion: this.sdkVersion});\n\n        this.network.unsubscribe(object, room.channel, unsubscribeCB);\n      }\n    });\n\n    /**\n     * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n     * and is called by these methods\n     */\n    Object.defineProperty(this, 'callbackRequired', {\n      value: (errorMessagePrefix, callback) => {\n        if (!callback || typeof callback !== 'function') {\n          throw new Error(`${errorMessagePrefix}: a callback argument is required for read queries`);\n        }\n      }\n    });\n\n    /**\n     * Create an attribute security that embed all methods to manage Role, Profile and User\n     */\n    Object.defineProperty(this, 'security', {\n      value: new Security(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'memoryStorage', {\n      value: new MemoryStorage(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'collections',{\n      value: {},\n      writable: true\n    });\n\n    Object.defineProperty(this, 'eventTimeout',{\n      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200\n    });\n\n    Object.defineProperty(this, 'protectedEvents', {\n      value: {\n        connected: {timeout: this.eventTimeout},\n        error: {timeout: this.eventTimeout},\n        disconnected: {timeout: this.eventTimeout},\n        reconnected: {timeout: this.eventTimeout},\n        tokenExpired: {timeout: this.eventTimeout},\n        loginAttempt: {timeout: this.eventTimeout}\n      }\n    });\n\n    this.network = networkWrapper(this.protocol, host, options);\n\n    // Properties related to the network layer\n    // Accessing a property irrelevant for a given protocol\n    // (e.g. \"autoReconnect\" for the HTTP layer) should\n    // throw an exception\n    Object.defineProperties(this, {\n      autoQueue: {\n        enumerable: true,\n        get: () => this.network.autoQueue,\n        set: value => {\n          checkPropertyType('autoQueue', 'boolean', value);\n          this.network.autoQueue = value;\n        }\n      },\n      autoReconnect: {\n        enumerable: true,\n        get: () => this.network.autoReconnect\n      },\n      autoReplay: {\n        enumerable: true,\n        get: () => this.network.autoReplay,\n        set: value => {\n          checkPropertyType('autoReplay', 'boolean', value);\n          this.network.autoReplay = value;\n        }\n      },\n      host: {\n        enumerable: true,\n        get: () => this.network.host\n      },\n      offlineQueue: {\n        enumerable: true,\n        get: () => this.network.offlineQueue\n      },\n      offlineQueueLoader: {\n        enumerable: true,\n        get: () => this.network.offlineQueueLoader,\n        set: value => {\n          if (value !== null) {\n            checkPropertyType('offlineQueueLoader', 'function', value);\n          }\n          this.network.offlineQueueLoader = value;\n        }\n      },\n      port: {\n        enumerable: true,\n        get: () => this.network.port\n      },\n      queueFilter: {\n        enumerable: true,\n        get: () => this.network.queueFilter,\n        set: value => {\n          checkPropertyType('queueFilter', 'function', value);\n          this.network.queueFilter = value;\n        }\n      },\n      queueMaxSize: {\n        enumerable: true,\n        get: () => this.network.queueMaxSize,\n        set: value => {\n          checkPropertyType('queueMaxSize', 'number', value);\n          this.network.queueMaxSize = value;\n        }\n      },\n      queueTTL: {\n        enumerable: true,\n        get: () => this.network.queueTTL,\n        set: value => {\n          checkPropertyType('queueTTL', 'number', value);\n          this.network.queueTTL = value;\n        }\n      },\n      replayInterval: {\n        enumerable: true,\n        get: () => this.network.replayInterval,\n        set: value => {\n          checkPropertyType('replayInterval', 'number', value);\n          this.network.replayInterval = value;\n        }\n      },\n      reconnectionDelay: {\n        enumerable: true,\n        get: () => this.network.reconnectionDelay\n      },\n      sslConnection: {\n        eumerable: true,\n        get: () => this.network.ssl\n      }\n    });\n\n    this.network.addListener('offlineQueuePush', data => this.emit('offlineQueuePush', data));\n    this.network.addListener('offlineQueuePop', data => this.emit('offlineQueuePop', data));\n    this.network.addListener('queryError', (err, query) => this.emit('queryError', err, query));\n\n    this.network.addListener('tokenExpired', () => {\n      this.unsetJwt();\n      this.emit('tokenExpired');\n    });\n\n    if (this.bluebird) {\n      return this.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: function (name, func, target, passes) {\n          const whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n            'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n            'checkToken', 'whoAmI', 'updateSelf', 'getMyRights', 'getMyCredentials',\n            'createMyCredentials', 'deleteMyCredentials', 'updateMyCredentials', 'validateMyCredentials',\n            'createIndex', 'refreshIndex', 'getAutoRefresh', 'setAutoRefresh', 'connect'\n          ];\n\n          return passes && whitelist.indexOf(name) !== -1;\n        }\n      });\n    }\n  }\n\n  /**\n  * Emit an event to all registered listeners\n  * An event cannot be emitted multiple times before a timeout has been reached.\n  */\n  emit (eventName, ...payload) {\n    const\n      now = Date.now(),\n      protectedEvent = this.protectedEvents[eventName];\n\n    if (protectedEvent) {\n      if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n        return false;\n      }\n      protectedEvent.lastEmitted = now;\n    }\n\n    super.emit(eventName, ...payload);\n  }\n\n\n  /**\n   * Connects to a Kuzzle instance using the provided host name\n   * @param {function} [cb] Connection callback\n   */\n  connect (cb) {\n    if (this.network.state !== 'offline') {\n      if (cb) {\n        cb(null, this);\n      }\n      return;\n    }\n\n    this.network.connect();\n\n    this.network.addListener('connect', () => {\n      this.emit('connected');\n\n      if (cb) {\n        cb(null, this);\n      }\n    });\n\n    this.network.addListener('networkError', error => {\n      const connectionError = new Error(`Unable to connect to kuzzle proxy server at ${this.network.host}:${this.network.port}`);\n\n      connectionError.internal = error;\n      this.emit('networkError', connectionError);\n\n      if (cb) {\n        cb(connectionError);\n      }\n    });\n\n    this.network.addListener('disconnect', () => {\n      this.disconnect();\n      this.emit('disconnected');\n    });\n\n    this.network.addListener('reconnect', () => {\n      if (this.jwt) {\n        this.checkToken(this.jwt, (err, res) => {\n          // shouldn't obtain an error but let's invalidate the token anyway\n          if (err || !res.valid) {\n            this.unsetJwt();\n          }\n\n          this.emit('reconnected');\n        });\n      } else {\n        this.emit('reconnected');\n      }\n    });\n\n    this.network.on('discarded', data => this.emit('discarded', data));\n  }\n\n  /**\n   * Set the jwt used to query kuzzle\n   * @param token\n   * @returns {Kuzzle}\n   */\n  setJwt (token) {\n    if (typeof token === 'string') {\n      this.jwt = token;\n    } else if (typeof token === 'object') {\n      if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n        this.jwt = token.result.jwt;\n      } else {\n        this.emit('loginAttempt', {\n          success: false,\n          error: 'Cannot find a valid JWT in the following object: ' + JSON.stringify(token)\n        });\n\n        return this;\n      }\n    } else {\n      this.emit('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n      return this;\n    }\n\n    this.emit('loginAttempt', {success: true});\n    return this;\n  }\n\n  /**\n   * Unset the jwt used to query kuzzle\n   * @returns {Kuzzle}\n   */\n  unsetJwt () {\n    this.jwt = undefined;\n    return this;\n  }\n\n  /**\n   * Get the jwt used by kuzzle\n   * @returns {Kuzzle}\n   */\n  getJwt () {\n    return this.jwt;\n  }\n\n  /**\n   * Send login request to kuzzle with credentials\n   * If login success, store the jwt into kuzzle object\n   *\n   * @param strategy\n   * @param credentials\n   * @param expiresIn\n   * @param cb\n   */\n  login (strategy, ...args) {\n    if (!strategy || typeof strategy !== 'string') {\n      throw new Error('Kuzzle.login: strategy required');\n    }\n\n    const \n      request = {\n        strategy,\n        body: {}\n      };\n\n    let cb = null;\n\n    // Handle arguments (credentials, expiresIn, cb)\n    if (args[0]) {\n      if (typeof args[0] === 'object') {\n        request.body = args[0];\n      } else if (typeof args[0] === 'number' || typeof args[0] === 'string') {\n        request.expiresIn = args[0];\n      } else if (typeof args[0] === 'function') {\n        cb = args[0];\n      }\n    }\n    if (args[1]) {\n      if (typeof args[1] === 'number' || typeof args[1] === 'string') {\n        request.expiresIn = args[1];\n      } else if (typeof args[1] === 'function') {\n        cb = args[1];\n      }\n    }\n    if (args[2] && typeof args[2] === 'function') {\n      cb = args[2];\n    }\n\n    this.query({controller: 'auth', action: 'login'}, request, {queuable: false}, (error, response) => {\n      if (!error) {\n        if (response.result.jwt) {\n          this.setJwt(response.result.jwt);\n        }\n\n        cb && cb(null, response.result);\n      }\n      else {\n        cb && cb(error);\n        this.emit('loginAttempt', {success: false, error: error.message});\n      }\n    });\n  }\n\n  /**\n   * Create credentials of the specified <strategy> for the current user.\n   *\n   * @param credentials\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  createMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'createMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result._source);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Delete credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  deleteMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'deleteMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Get credential information of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   */\n  getMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'getMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Update credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentals\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  updateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Validate credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentials\n   * @param options\n   * @param cb\n   */\n  validateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'validateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Create a kuzzle index\n   *\n   * @param {string} index\n   * @param {object} [options]\n   * @param {responseCallback} cb\n   * @returns {Kuzzle}\n   */\n  createIndex (index, options, cb) {\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.createIndex: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'index', action: 'create', index}, {}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Send logout request to kuzzle with jwt.\n   *\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  logout (cb) {\n    const\n      request = {\n        action: 'logout',\n        controller: 'auth',\n        requestId: uuidv4(),\n        body: {}\n      };\n\n    this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, error => {\n      if (typeof cb === 'function') {\n        cb(error, this);\n      }\n    });\n\n    return this.unsetJwt();\n  }\n\n  /**\n   * Checks whether a given jwt token still represents a valid session in Kuzzle.\n   *\n   * @param  {string}   token     The jwt token to check\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  checkToken (token, cb) {\n    const\n      request = {\n        body: {\n          token\n        }\n      };\n\n    this.callbackRequired('Kuzzle.checkToken', cb);\n\n    this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, (err, res) => {\n      cb(err, err ? undefined : res.result);\n    });\n  }\n\n  /**\n   * Fetches the current user.\n   *\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  whoAmI (cb) {\n    this.callbackRequired('Kuzzle.whoAmI', cb);\n\n    this.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, (err, res) => {\n      cb(err, err ? undefined : new User(this.security, res.result._id, res.result._source, res.result._meta));\n    });\n  }\n\n  /**\n   * Gets the rights array of the currently logged user.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param  {function} cb The callback containing the normalized array of rights.\n   */\n  getMyRights (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getMyRights', cb);\n\n    this.query({controller: 'auth', action:'getMyRights'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Update current user in Kuzzle.\n   *\n   * @param {object} content - a plain javascript object representing the user's modification\n   * @param {object} [options] - (optional) arguments\n   * @param {responseCallback} [cb] - (optional) Handles the query response\n   * @returns {Kuzzle} this object\n   */\n  updateSelf (content, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateSelf'}, {body: content}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n   * insertion.\n   *\n   * @param {string} event - name of the global event to subscribe to\n   * @param {function} listener - callback to invoke each time an event is fired\n   */\n  addListener (event, listener) {\n    if (this.eventActions.indexOf(event) === -1) {\n      throw new Error(`[${event}] is not a known event. Known events: ${this.eventActions.toString()}`);\n    }\n\n    return super.addListener(event, listener);\n  }\n\n  /**\n   * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n   * This method returns all available statistics from Kuzzle.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getAllStatistics (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n    this.query({controller:'server', action: 'getAllStats'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n   * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n   *\n   * @param {number} startTime -  Epoch time. Starting time from which the frames are to be retrieved\n   * @param {number} stopTime -  Epoch time. End time from which the frames are to be retrieved\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getStatistics (...args) {\n    let\n      startTime,\n      stopTime,\n      options,\n      cb;\n\n    switch (args.length) {\n      case 1:\n        cb = args[0];\n        startTime = null;\n        stopTime = null;\n        options = null;\n        break;\n      case 2:\n        if (typeof args[0] === 'object') {\n          [options, cb] = args;\n        } else {\n          [startTime, cb] = args;\n        }\n        break;\n      case 3:\n        if (typeof args[1] === 'object') {\n          [startTime, options, cb] = args;\n        } else {\n          [startTime, stopTime, cb] = args;\n        }\n        break;\n      case 4:\n        [startTime, stopTime, options, cb] = args;\n        break;\n      default:\n        throw new Error('Bad arguments list. Usage: kuzzle.getStatistics([startTime,] [stopTime,] [options,] callback)');\n    }\n\n    this.callbackRequired('Kuzzle.getStatistics', cb);\n\n    const queryCB = (err, res) => {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, startTime ? res.result.hits : [res.result]);\n    };\n\n    let query = {};\n    if (startTime) {\n      query = stopTime ? {startTime, stopTime} : {startTime};\n    }\n\n    this.query({controller: 'server', action: startTime ? 'getStats' : 'getLastStats'}, query, options, queryCB);\n  }\n\n  /**\n   * Create a new instance of a Collection object.\n   * If no index is specified, takes the default index.\n   *\n   * @param {string} collection - The name of the data collection you want to manipulate\n   * @param {string} [index] - The name of the data index containing the data collection\n   * @returns {Collection} A Collection instance\n   */\n  collection (collection, index) {\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Unable to create a new data collection object: no index specified');\n      }\n\n      index = this.defaultIndex;\n    }\n\n    if (typeof index !== 'string' || typeof collection !== 'string') {\n      throw new Error('Invalid index or collection argument: string expected');\n    }\n\n    if (!this.collections[index]) {\n      this.collections[index] = {};\n    }\n\n    if (!this.collections[index][collection]) {\n      this.collections[index][collection] = new Collection(this, collection, index);\n    }\n\n    return this.collections[index][collection];\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   *\n   * @returns {Kuzzle}\n   */\n  flushQueue () {\n    this.network.flushQueue();\n    return this;\n  }\n\n  /**\n   * Returns the list of known persisted data collections.\n   *\n   * @param {string} [index] - Index containing collections to be listed\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  listCollections (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.listCollections: index required');\n      }\n\n      index = this.defaultIndex;\n    }\n\n    this.callbackRequired('Kuzzle.listCollections', cb);\n\n    const query = {type: options && options.type || 'all'};\n\n    this.query({index, controller: 'collection', action: 'list'}, query, options, (err, res) => {\n      cb(err, err ? undefined : res.result.collections);\n    });\n  }\n\n  /**\n   * Returns the list of existing indexes in Kuzzle\n   *\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  listIndexes (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.listIndexes', cb);\n\n    this.query({controller: 'index', action: 'list'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.indexes);\n    });\n  }\n\n  /**\n   * Disconnects from Kuzzle and invalidate this instance.\n   */\n  disconnect () {\n    this.network.close();\n\n    for (const collection of Object.keys(this.collections)) {\n      delete this.collections[collection];\n    }\n  }\n\n  /**\n   * Returns the server informations\n   *\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getServerInfo (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n    this.query({controller: 'server', action: 'info'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.serverInfo);\n    });\n  }\n\n  /**\n   * Forces an index refresh\n   *\n   * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n   * @param {object} options - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   * @returns {Kuzzle}\n   */\n  refreshIndex (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.refreshIndex: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    this.query({index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Returns de current autoRefresh status for the given index\n   *\n   * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n   * @param {object} options - Optinal arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getAutoRefresh (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.getAutoRefresh: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n    this.query({index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n  }\n\n  /**\n   * (Un)Sets the autoRefresh flag on the given index\n   *\n   * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n   * @param {boolean} autoRefresh - The autoRefresh value to set\n   * @param {object} options - Optional arguments\n   * @param {responseCallback} cb - Handles the query result\n   * @returns {object} this\n   */\n  setAutoRefresh (...args) {\n    var\n      index,\n      autoRefresh,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'boolean':\n          autoRefresh = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.setAutoRefresh: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    if (autoRefresh === undefined) {\n      throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n    }\n\n    this.query({index, controller: 'index', action: 'setAutoRefresh'}, {body: {autoRefresh}}, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Return the current Kuzzle's UTC Epoch time, in milliseconds\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  now (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.now', cb);\n\n    this.query({controller: 'server', action: 'now'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.now);\n    });\n  }\n\n  /**\n   * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n   * Base method used to send read queries to Kuzzle\n   *\n   * Takes an optional argument object with the following properties:\n   *    - volatile (object, default: null):\n   *        Additional information passed to notifications to other users\n   *\n   * @param {object} queryArgs - Query configuration\n   * @param {object} query - The query data\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} [cb] - Handles the query response\n   */\n  query (queryArgs, query, options, cb) {\n    const\n      object = {\n        action: queryArgs.action,\n        controller: queryArgs.controller,\n        volatile: this.volatile\n      };\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    } else if (!cb && !options && typeof query === 'function') {\n      cb = query;\n      query = {};\n      options = null;\n    }\n\n    if (options) {\n      for (const prop of ['refresh', 'from', 'size', 'scroll', 'scrollId']) {\n        if (options[prop] !== undefined) {\n          object[prop] = options[prop];\n        }\n      }\n\n      if (options.volatile && typeof options.volatile === 'object') {\n        Object.assign(object.volatile, options.volatile);\n      }\n    }\n\n    if (!query || typeof query !== 'object' || Array.isArray(query)) {\n      throw new Error('Invalid query parameter: ' + query);\n    }\n\n    Object.assign(object.volatile, query.volatile, {sdkInstanceId: this.network.id, sdkVersion: this.sdkVersion});\n\n    for (const attr of Object.keys(query)) {\n      if (attr !== 'volatile') {\n        object[attr] = query[attr];\n      }\n    }\n\n    /*\n     * Do not add the token for the checkToken route, to avoid getting a token error when\n     * a developer simply wish to verify his token\n     */\n    if (this.jwt !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n      object.jwt = this.jwt;\n    }\n\n    if (queryArgs.collection) {\n      object.collection = queryArgs.collection;\n    }\n\n    if (queryArgs.index) {\n      object.index = queryArgs.index;\n    }\n\n    if (!object.requestId) {\n      object.requestId = uuidv4();\n    }\n\n    this.network.query(object, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Starts the requests queuing.\n   */\n  startQueuing () {\n    this.network.startQueuing();\n    return this;\n  }\n\n  /**\n   * Stops the requests queuing.\n   */\n  stopQueuing () {\n    this.network.stopQueuing();\n    return this;\n  }\n\n  /**\n   * @DEPRECATED\n   * See Kuzzle.prototype.playQueue();\n   */\n  replayQueue () {\n    return this.playQueue();\n  }\n\n  /**\n   * Plays the requests queued during offline mode.\n   */\n  playQueue () {\n    this.network.playQueue();\n    return this;\n  }\n\n  /**\n   * Sets the default Kuzzle index\n   *\n   * @param index\n   * @returns this\n   */\n  setDefaultIndex (index) {\n    if (typeof index !== 'string') {\n      throw new Error(`Invalid default index: [${index}] (an index name is expected)`);\n    }\n\n    if (index.length === 0) {\n      throw new Error('Cannot set an empty index as the default index');\n    }\n\n    this.defaultIndex = index;\n\n    return this;\n  }\n}\n\nfunction checkPropertyType(prop, typestr, value) {\n  const wrongType = typestr === 'array' ? !Array.isArray(value) : typeof value !== typestr;\n\n  if (wrongType) {\n    throw new Error(`Can only assign a ${typestr} value to property \"${prop}\"`);\n  }\n}\n\nmodule.exports = Kuzzle;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kuzzle.js","class Listener {\n  constructor(fn, once = false) {\n    this.fn = fn;\n    this.once = once;\n  }\n}\n\nclass KuzzleEventEmitter {\n  constructor() {\n    this._events = {};\n  }\n\n  _exists (listeners, fn) {\n    return Boolean(listeners.find(listener => listener.fn === fn));\n  }\n\n  listeners (eventName) {\n    if (this._events[eventName] === undefined) {\n      return [];\n    }\n\n    return this._events[eventName].map(listener => listener.fn);\n  }\n\n  addListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    const listenerType = typeof listener;\n\n    if (listenerType !== 'function') {\n      throw new Error(`Invalid listener type: expected a function, got a ${listenerType}`);\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName].push(new Listener(listener, once));\n    }\n\n    return this;\n  }\n\n  on (eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  prependListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n    }\n\n    return this;\n  }\n\n  addOnceListener (eventName, listener) {\n    return this.addListener(eventName, listener, true);\n  }\n\n  once (eventName, listener) {\n    return this.addOnceListener(eventName, listener);\n  }\n\n  prependOnceListener (eventName, listener) {\n    return this.prependListener(eventName, listener, true);\n  }\n\n  removeListener (eventName, listener) {\n    const listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n\n    const index = listeners.findIndex(l => l.fn === listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    return this;\n  }\n\n  removeAllListeners (eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  }\n\n  emit (eventName, ...payload) {\n    const listeners = this._events[eventName];\n\n    if (listeners === undefined) {\n      return false;\n    }\n\n    const onceListeners = [];\n\n    for (const listener of listeners) {\n      listener.fn(...payload);\n\n      if (listener.once) {\n        onceListeners.push(listener.fn);\n      }\n    }\n\n    for (const toDelete of onceListeners) {\n      this.removeListener(eventName, toDelete);\n    }\n\n    return true;\n  }\n\n  eventNames () {\n    return Object.keys(this._events);\n  }\n\n  listenerCount (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  }\n}\n\nmodule.exports = KuzzleEventEmitter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/eventEmitter/index.js","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * Document is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {Collection} collection - an instanciated Collection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @param {object} [meta] - Initializes this document with the provided meta\n * @constructor\n */\nfunction Document(collection, documentId, content, meta) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: collection,\n      enumerable: false\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: false\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    meta: {\n      value: meta || {},\n      enumerable: true,\n      writable: false\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  if (this.version) {\n    data._version = this.version;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.delete: cannot delete a document without a document ID');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n    cb(err, err ? undefined : self.id);\n  });\n};\n\n/**\n * Checks if this document exists in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.exists = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('Document.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n    if (error) {\n      return cb && cb(error);\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function won’t be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\nmodule.exports = Document;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Document.js\n// module id = 2\n// module chunks = 0","function SecurityDocument(Security, id, content, meta) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: Security.kuzzle\n    },\n    Security: {\n      value: Security\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    meta: {\n      value: meta || {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function won’t be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {SecurityDocument} this\n */\nSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {SecurityDocument} this\n */\nSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = SecurityDocument;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/SecurityDocument.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nconst\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('../../../eventEmitter');\n\nclass RTWrapper extends KuzzleEventEmitter {\n\n  constructor (host, options) {\n    super();\n\n    Object.defineProperties(this, {\n      id: {\n        value: uuidv4()\n      },\n      host: {\n        value: host,\n        enumerable: true\n      },\n      port: {\n        value: (options && typeof options.port === 'number') ? options.port : 7512,\n        enumerable: true\n      },\n      ssl: {\n        value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n        enumerable: true\n      },\n      queuing: {\n        value: false,\n        writable: true\n      },\n      reconnectionDelay: {\n        value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n        enumerable: true\n      },\n      // configuration properties\n      autoReconnect: {\n        value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n        enumerable: true\n      },\n      autoQueue: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      autoReplay: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      state: {\n        value: 'offline',\n        enumerable: true,\n        writable: true\n      },\n      /*\n        Offline queue use the following format:\n              [\n                {\n                  ts: <query timestamp>,\n                  query: 'query',\n                  cb: callbackFunction\n                }\n              ]\n       */\n      offlineQueue: {\n        value: [],\n        enumerable: true,\n        writable: true\n      },\n      queueFilter: {\n        value: null,\n        enumerable: true,\n        writable: true\n      },\n      queueMaxSize: {\n        value: 500,\n        enumerable: true,\n        writable: true\n      },\n      queueTTL: {\n        value: 120000,\n        enumerable: true,\n        writable: true\n      },\n      replayInterval: {\n        value: 10,\n        enumerable: true,\n        writable: true\n      },\n      offlineQueueLoader: {\n        value: null,\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      Object.keys(options).forEach(opt => {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      });\n\n      if (options.offlineMode === 'auto' && this.autoReconnect) {\n        this.autoQueue = this.autoReplay = true;\n      }\n    }\n\n    this.wasConnected = false;\n    this.stopRetryingToConnect = false;\n    this.retrying = false;\n  }\n\n  connect() {\n    this.state = 'connecting';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected() {\n    this.state = 'connected';\n    this.emit(this.wasConnected && 'reconnect' || 'connect');\n    this.wasConnected = true;\n    this.stopRetryingToConnect = false;\n\n    if (this.autoQueue) {\n      this.stopQueuing();\n    }\n\n    if (this.autoReplay) {\n      this.playQueue();\n    }\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  clientDisconnected() {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.emit('disconnect');\n  }\n\n  /**\n   * Called when the client's connection is closed with an error state\n   *\n   * @param {Error} error\n   */\n  clientNetworkError(error) {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.emit('networkError', error);\n    if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n      this.retrying = true;\n      setTimeout(() => {\n        this.retrying = false;\n        this.connect(this.host);\n      }, this.reconnectionDelay);\n    } else {\n      this.emit('disconnect');\n    }\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   */\n  flushQueue() {\n    this.offlineQueue = [];\n  }\n\n  /**\n   * Replays the requests queued during offline mode.\n   */\n  playQueue() {\n    if (this.state === 'connected') {\n      cleanQueue(this);\n      dequeue(this);\n    }\n  }\n\n  /**\n   * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  startQueuing() {\n    this.queuing = true;\n  }\n\n  /**\n   * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  stopQueuing() {\n    this.queuing = false;\n  }\n\n  subscribe(object, options, notificationCB, cb) {\n    if (this.state !== 'connected') {\n      return cb(new Error('Not Connected'));\n    }\n    this.query(object, options, (error, response) => {\n      if (error) {\n        return cb(error);\n      }\n      this.on(response.result.channel, data => {\n        data.fromSelf = data.volatile !== undefined && data.volatile.sdkInstanceId === this.id;\n        notificationCB(data);\n      });\n      cb(null, response.result);\n    });\n  }\n\n  unsubscribe(object, channel, cb) {\n    this.removeAllListeners(channel);\n    this.query(object, null, (err, res) => {\n      if (cb) {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  query(object, options, cb) {\n    let queuable = options && (options.queuable !== false) || true;\n\n    if (this.queueFilter) {\n      queuable = queuable && this.queueFilter(object);\n    }\n\n    if (this.queuing && queuable) {\n      cleanQueue(this, object, cb);\n      this.emit('offlineQueuePush', {query: object, cb: cb});\n      return this.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n    }\n\n    if (this.state === 'connected') {\n      return emitRequest(this, object, cb);\n    }\n\n    return discardRequest(object, cb);\n  }\n}\n/**\n * Emit a request to Kuzzle\n *\n * @param {RTWrapper} network\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (network, request, cb) {\n  if (request.jwt !== undefined || cb) {\n    network.once(request.requestId, response => {\n      let error = null;\n\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        network.emit('tokenExpired', request, cb);\n      }\n\n      if (response.error) {\n        error = new Error(response.error.message);\n        Object.assign(error, response.error);\n        error.status = response.status;\n        network.emit('queryError', error, request, cb);\n      }\n\n      if (cb) {\n        cb(error, response);\n      }\n    });\n  }\n  // Track requests made to allow Room.subscribeToSelf to work\n  network.send(request);\n}\n\nfunction discardRequest(object, cb) {\n  if (cb) {\n    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n  }\n}\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n * @param {RTWrapper} network\n */\nfunction cleanQueue (network) {\n  const now = Date.now();\n  let lastDocumentIndex = -1;\n\n  if (network.queueTTL > 0) {\n    network.offlineQueue.forEach((query, index) => {\n      if (query.ts < now - network.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      network.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(droppedRequest => {\n          network.emit('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (network.queueMaxSize > 0 && network.offlineQueue.length > network.queueMaxSize) {\n    network.offlineQueue\n      .splice(0, network.offlineQueue.length - network.queueMaxSize)\n      .forEach(droppedRequest => {\n        network.emit('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue (network) {\n  const\n    uniqueQueue = {},\n    dequeuingProcess = () => {\n      if (network.offlineQueue.length > 0) {\n        emitRequest(network, network.offlineQueue[0].query, network.offlineQueue[0].cb);\n        network.emit('offlineQueuePop', network.offlineQueue.shift());\n\n        setTimeout(() => {\n          dequeuingProcess();\n        }, Math.max(0, network.replayInterval));\n      }\n    };\n\n  if (network.offlineQueueLoader) {\n    if (typeof network.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof network.offlineQueueLoader);\n    }\n\n    const additionalQueue = network.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      network.offlineQueue = additionalQueue\n        .concat(network.offlineQueue)\n        .filter(request => {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\nmodule.exports = RTWrapper;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/abstract/realtime.js","var\n  KuzzleSecurityDocument = require('./SecurityDocument');\n\n/**\n * @param {Security} Security\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction User(Security, id, content, meta) {\n  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    },\n    credentials: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: User\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {User} this\n */\nUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * @param {object} credentials\n */\nUser.prototype.setCredentials = function (credentials) {\n  if (typeof credentials !== 'object') {\n    throw new Error('Parameter \"credentials\" must be a object');\n  }\n\n  this.credentials = credentials;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {User} this\n */\nUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Creates this user into Kuzzle\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.create = function (options, cb) {\n  var\n    data = this.creationSerialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n\n/**\n * Replaces the latest version of this user in Kuzzle by the current content of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.replace = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n\n  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content, meta: this.meta};\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.creationSerialize = function () {\n  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array.<string>} the associated profiles IDs\n */\nUser.prototype.getProfileIds = function () {\n  return this.content.profileIds || [];\n};\n\n/**\n * Return the associated Profile objects\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nUser.prototype.getProfiles = function (options, cb) {\n  var \n    self = this,\n    fetchedProfiles = [],\n    errored = false;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\n  if (!self.content.profileIds) {\n    return cb(null, fetchedProfiles);\n  }\n\n  self.content.profileIds.forEach(function (profileId) {\n    self.Security.fetchProfile(profileId, options, function (error, profile) {\n      if (error) {\n        if (errored) {\n          return;\n        }\n\n        errored = true; // prevents multiple callback resolutions\n        return cb(error);\n      }\n\n      fetchedProfiles.push(profile);\n\n      if (fetchedProfiles.length === self.content.profileIds.length) {\n        cb(null, fetchedProfiles);\n      }\n    });\n  });\n};\n\nmodule.exports = User;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/User.js\n// module id = 5\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v4.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nconst\n  KuzzleEventEmitter = require('./eventEmitter');\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you don’t exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then you’ll receive a notification about it.\n *\n */\nclass Room extends KuzzleEventEmitter {\n  /*\n   * @constructor\n   * @param {object} collection - an instantiated and valid kuzzle object\n   * @param {object} [filters] - Filters in Kuzzle DSL format\n   * @param {object} [options] - subscription optional configuration\n   */\n  constructor(collection, filters, options) {\n    super();\n\n    let _roomId = null;\n\n    // Define properties\n    Object.defineProperties(this, {\n      // private properties\n      roomstate: {\n        // Values can be: inactive, subscribing, active\n        value: 'inactive',\n        writable: true\n      },\n      kuzzle: {\n        value: collection.kuzzle\n      },\n      isListening: {\n        value: false,\n        writable: true\n      },\n      //listeners\n      resubscribe: {\n        value: () => {\n          this.roomstate = 'inactive';\n          this.error = null;\n          this.subscribe();\n        }\n      },\n      deactivate: {\n        value: () => {\n          this.roomstate = 'inactive';\n        }\n      },\n      resubscribeConditional: {\n        value: () => {\n          this.roomstate = 'inactive';\n          \n          if (this.autoResubscribe) {\n            this.subscribe();\n          }\n        }\n      },\n      //enumerables\n      channel: {\n        value: null,\n        writable: true,\n        enumerable: true\n      },\n      scope: {\n        value: options && options.scope ? options.scope : 'all',\n        enumerable: true\n      },\n      state: {\n        value: options && options.state ? options.state : 'done',\n        enumerable: true\n      },\n      users: {\n        value: options && options.users ? options.users : 'none',\n        enumerable: true\n      },\n      // read-only properties\n      collection: {\n        value: collection,\n        enumerable: true\n      },\n      filters: {\n        value: filters ? filters : {},\n        enumerable: true,\n      },\n      roomId: {\n        enumerable: true,\n        get: () => _roomId,\n        set: value => {\n          if (!_roomId) {\n            _roomId = value;\n          }\n        }\n      },\n      // writable properties\n      volatile: {\n        value: (options && options.volatile) ? options.volatile : {},\n        enumerable: true,\n        writable: true\n      },\n      subscribeToSelf: {\n        value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n        enumerable: true,\n        writable: true\n      },\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : collection.kuzzle.autoResubscribe,\n        enumerable: true\n      }\n    });\n\n    if (this.kuzzle.bluebird) {\n      return this.kuzzle.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: function (name, func, target, passes) {\n          const whitelist = ['count', 'subscribe', 'unsubscribe', 'onDone'];\n\n          return passes && whitelist.indexOf(name) !== -1;\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the number of other subscriptions on that room.\n   *\n   * @param {responseCallback} cb - Handles the query response\n   */\n  count(cb) {\n    this.kuzzle.callbackRequired('Room.count', cb);\n\n    const data = {body: {roomId: this.roomId}};\n\n    if (this.roomstate !== 'active') {\n      return cb(new Error('Cannot count subscriptions on an non-active room'));\n    }\n\n    this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n      cb(err, res && res.result.count);\n    });\n  }\n\n  /**\n   * Subscribes to Kuzzle \n   * (do nothing if a subscription is active or underway)\n   * \n   * @param options\n   * @param {responseCallback} cb - called when the subscription is ready.\n   * @return {*} this\n   */\n  subscribe(options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    if (cb) {\n      this.onDone(cb);\n    }\n\n    // If the room subscription is active, just call the callback.\n    if (this.roomstate === 'active') {\n      this.emit('done', null, this);\n      return this;\n    }\n\n    // If the room is already subscribing, wait for its activation.\n    if (this.roomstate === 'subscribing') {\n      return this;\n    }\n\n    // If the room is still inactive, start the subscription.\n    this.error = null;\n    this.roomstate = 'subscribing';\n\n    this.kuzzle.subscribe(this, options, (error, result) => {\n      if (error) {\n        if (error.message === 'Not Connected') {\n          return this.kuzzle.once('connected', this.resubscribe);\n        }\n\n        this.roomstate = 'inactive';\n        this.error = new Error('Error during Kuzzle subscription: ' + error.message);\n        this.emit('done', this.error);\n        return null;\n      }\n\n      this.roomId = result.roomId;\n      this.channel = result.channel;\n      this.roomstate = 'active';\n\n      if (!this.isListening) {\n        this.kuzzle.addListener('disconnected', this.deactivate);\n        this.kuzzle.addListener('tokenExpired', this.deactivate);\n        this.kuzzle.addListener('reconnected', this.resubscribeConditional);\n        this.isListening = true;\n      }\n\n      this.emit('done', null, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Unsubscribes from Kuzzle.\n   *\n   * Stop listening immediately.\n   * @param {responseCallback} cb - Handles the query response\n   * @return {*} this\n   */\n  unsubscribe(cb) {\n    if (this.roomstate === 'subscribing') {\n      if (cb) {\n        cb(new Error('Cannot unsubscribe a room while a subscription attempt is underway'));\n      }\n\n      return this;\n    }\n\n    if (this.isListening) {\n      this.kuzzle.removeListener('disconnected', this.deactivate);\n      this.kuzzle.removeListener('tokenExpired', this.deactivate);\n      this.kuzzle.removeListener('reconnected', this.resubscribeConditional);\n      this.isListening = false;\n    }\n\n    if (this.roomstate === 'active') {\n      this.kuzzle.unsubscribe(this, cb);\n    }\n    else if (cb) {\n      cb(null, this.roomId);\n    }\n\n    this.roomstate = 'inactive';\n\n    return this;\n  }\n\n  /**\n   * Notify listeners\n   *\n   * @param {Object} data - data to send. Must contain `data.type` as eventName.\n   * @return {*} this\n   */\n  notify(data) {\n    if (data.type === undefined) {\n      throw new Error('Room.notify: argument must match {type: <document|user>}');\n    }\n    if (!data.fromSelf || this.subscribeToSelf) {\n      this.emit(data.type, data);\n    }\n    return this;\n  }\n\n  /**\n   * Registers a callback to be called with a subscription result\n   * @param {Function} cb\n   */\n  onDone(cb) {\n    if (!cb || typeof cb !== 'function') {\n      throw new Error('Room.onDone: a callback argument is required.');\n    }\n\n    if (this.error) {\n      cb(this.error);\n    }\n    else if (this.roomstate === 'active') {\n      cb(null, this);\n    }\n    else {\n      this.once('done', cb);\n    }\n\n    return this;\n  }\n}\n\nmodule.exports = Room;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Room.js","const Document = require('./Document');\n\n/**\n * @param {Collection} collection\n * @param {object} filters\n * @param {object} options\n * @param {object} raw \n * @property {Collection} collection\n * @property {number} total\n * @property {Document[]} documents\n * @property {object} aggregations\n * @property {object} options\n * @property {object} filters\n * @property {number} fetched\n * @constructor\n */\nclass SearchResult {\n  constructor (collection, filters, options, raw) {\n    Object.defineProperties(this, {\n      // read-only properties\n      collection: {\n        value: collection,\n        enumerable: true\n      },\n      total: {\n        value: raw.result.total,\n        enumerable: true\n      },\n      documents: {\n        value: raw.result.hits.map(doc => {\n          const d = new Document(collection, doc._id, doc._source, doc._meta);\n          d.version = doc._version;\n          return d;\n        }),\n        enumerable: true\n      },\n      aggregations: {\n        value: raw.result.aggregations || {},\n        enumerable: true\n      },\n      options: {\n        value: {\n          from: options.from,\n          size: options.size,\n          scrollId: raw.result._scroll_id\n        },\n        enumerable: true\n      },\n      filters: {\n        value: filters || {},\n        enumerable: true\n      },\n      // writable properties\n      fetched: {\n        value: raw.result.hits.length,\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    Object.freeze(this.filters);\n    Object.freeze(this.options);\n    Object.freeze(this.aggregations);\n\n    // promisifying\n    if (this.collection.kuzzle.bluebird) {\n      const whitelist = ['fetchNext'];\n\n      return this.collection.kuzzle.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: (name, func, target, passes) => passes && whitelist.includes(name)\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {function} cb\n   */\n  fetchNext (cb) {\n    const updateAfterSearch = (error, result) => {\n      if (error) {\n        return cb(error);\n      }\n\n      result.fetched += this.fetched;\n      cb(null, result);\n    };\n    \n    this.collection.kuzzle.callbackRequired('SearchResult.fetchNext', cb);\n\n    if (this.fetched >= this.total) {\n      return cb(null, null);\n    }\n\n    // retrieve next results with scroll if original search use it\n    if (this.options.scrollId) {\n      this.collection.scroll(this.options.scrollId, null, this.filters || {}, updateAfterSearch);\n      return;\n    }\n\n    // retrieve next results using ES's search_after\n    if (this.options.size !== undefined && this.filters.sort) {\n      const \n        filters = Object.assign({}, this.filters, {search_after: []}),\n        lastDocumentContent = this.documents[this.documents.length - 1].content;\n\n      for (const sortRule of filters.sort) {\n        if (typeof sortRule === 'string') {\n          filters.search_after.push(lastDocumentContent[sortRule]);\n        } else {\n          filters.search_after.push(lastDocumentContent[Object.keys(sortRule)[0]]);\n        }\n      }\n\n      this.collection.search(filters, {size: this.options.size}, updateAfterSearch);\n      return;\n    }\n\n    // retrieve next results with from/size if original search use it\n    if (this.options.from !== undefined && this.options.size !== undefined) {\n      // check if we need to do next request to fetch all matching documents\n      const opts = {\n        from: this.options.from + this.options.size,\n        size: this.options.size\n      };\n\n      if (opts.from >= this.total) {\n        return cb(null, null);\n      }\n\n      this.collection.search(this.filters, opts, updateAfterSearch);\n      return;\n    }\n\n    cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n  }\n}\n\nmodule.exports = SearchResult;\n\n\n\n// WEBPACK FOOTER //\n// ./src/SearchResult.js","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nclass SocketIO extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    this.socket = null;\n    this.forceDisconnect = false;\n    this.eventsWrapper = {};\n  }\n\n  /**\n   * Connect to the SocketIO server\n   */\n  connect() {\n    super.connect();\n\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: this.autoReconnect,\n      reconnectionDelay: this.reconnectionDelay,\n      forceNew: true\n    });\n\n    this.socket.on('connect', () => this.clientConnected());\n    this.socket.on('connect_error', error => this.clientNetworkError(error));\n\n    this.socket.on('disconnect', () => {\n      if (this.forceDisconnect) {\n        this.clientDisconnected();\n      } else {\n        const error = new Error('An error occurred, kuzzle may not be ready yet');\n        error.status = 500;\n\n        this.clientNetworkError(error);\n      }\n\n      this.forceDisconnect = false;\n    });\n  }\n\n  /**\n   * Registers a callback on an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  addListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    super.addListener(event, callback, once);\n\n    return this;\n  }\n\n  prependListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    return super.prependListener(event, callback, once);\n  }\n\n  /**\n   * Unregisters a callback from an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  removeListener(event, callback) {\n    if (this.eventsWrapper[event]) {\n      this.eventsWrapper[event].listeners.delete(callback);\n\n      if (this.eventsWrapper[event].listeners.size === 0) {\n        this.socket.off(event, this.eventsWrapper[event].wrapper);\n        delete this.eventsWrapper[event];\n      }\n\n      super.removeListener(event, callback);\n    }\n\n    return this;\n  }\n\n  /**\n   * Unregisters all listeners either from an event, or from all events\n   *\n   * @param {string} [event]\n   */\n  removeAllListeners(event) {\n    if (event !== undefined) {\n      if (this.eventsWrapper[event] !== undefined) {\n        for (const listener of this.eventsWrapper[event].listeners) {\n          this.removeListener(event, listener);\n        }\n      }\n    } else {\n      for (const _event of Object.keys(this.eventsWrapper)) {\n        this.removeAllListeners(_event);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send(payload) {\n    this.socket.emit('kuzzle', payload);\n  }\n\n  /**\n   * Closes the connection\n   */\n  close() {\n    this.forceDisconnect = true;\n    this.state = 'offline';\n    this.socket.close();\n    this.socket = null;\n  }\n\n  _addEventWrapper(event, callback, once = false) {\n    if (!this.eventsWrapper[event]) {\n      const wrapper = (...args) => this.emit(event, ...args);\n\n      this.eventsWrapper[event] = {\n        wrapper,\n        listeners: new Set()\n      };\n\n      if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n        if (once) {\n          this.socket.once(event, wrapper);\n        } else {\n          this.socket.on(event, wrapper);\n        }\n      }\n    }\n\n    this.eventsWrapper[event].listeners.add(callback);\n  }\n}\n\nmodule.exports = SocketIO;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/socketio.js","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nlet WebSocketClient;\n\nclass WSNode extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : require('ws');\n    this.client = null;\n    this.lasturl = null;\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    const\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      opts = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    super.connect();\n\n    if (url !== this.lasturl) {\n      this.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new WebSocketClient(url, opts);\n\n    this.client.onopen = () => {\n      this.clientConnected();\n    };\n\n    this.client.onclose = (closeEvent, message) => {\n      let\n        status,\n        reason = message;\n\n      if (typeof closeEvent === 'number') {\n        status = closeEvent;\n      }\n      else {\n        status = closeEvent.code;\n\n        if (closeEvent.reason) {\n          reason = closeEvent.reason;\n        }\n      }\n\n      if (status === 1000) {\n        this.clientDisconnected();\n      }\n      // do not forward a connection close error if no \n      // connection has been previously established\n      else if (this.wasConnected) {\n        const error = new Error(reason);\n        error.status = status;\n\n        this.clientNetworkError(error);\n      }\n    };\n\n    this.client.onerror = error => {\n      const err = (error instanceof Error) && error || new Error(error);\n\n      this.clientNetworkError(err);\n    };\n\n    this.client.onmessage = payload => {\n      const data = JSON.parse(payload.data || payload);\n\n      if (data.room) {\n        this.emit(data.room, data);\n      }\n      else {\n        this.emit('discarded', data);\n      }\n    };\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.state = 'offline';\n    this.removeAllListeners();\n    this.wasConnected = false;\n    if (this.client) {\n      this.client.close();\n    }\n    this.client = null;\n    this.stopRetryingToConnect = true;\n  }\n}\n\nmodule.exports = WSNode;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/websocket.js","var\n  KuzzleSearchResult = require('./SearchResult'),\n  Document = require('./Document'),\n  CollectionMapping = require('./CollectionMapping'),\n  Room = require('./Room');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n *\n * @property {string} collection\n * @property {string} index\n * @property {Kuzzle} kuzzle\n * @property {Array.<string>} collection\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} collection - name of the data collection to handle\n * @param {string} index - Index containing the data collection\n * @constructor\n */\nfunction Collection(kuzzle, collection, index) {\n  if (!index || !collection) {\n    throw new Error('The Collection object constructor needs an index and a collection arguments');\n  }\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.count = function (filters, options, cb) {\n  var query = {body: filters};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.count', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n    cb(err, err ? undefined : res.result.count);\n  });\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.create = function (options, cb) {\n  var data = {},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n *        If the same document already exists:\n *          - resolves with an error if set to \"error\".\n *          - replaces the existing document if set to \"replace\"\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a Document object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options && options.ifExist) {\n    if (options.ifExist === 'replace') {\n      action = 'createOrReplace';\n    }\n    else if (options.ifExist !== 'error') {\n      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n    }\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    var doc;\n\n    if (err) {\n      return cb(err);\n    }\n\n    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n    doc.version = res.result._version;\n    cb(null, doc);\n  });\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Collection} this\n */\nCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = {query: arg};\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    if (err) {\n      cb(err);\n    }\n    else {\n      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n    }\n  });\n\n  return this;\n};\n\n/**\n * Deletes the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.deleteSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Returns a boolean indicating whether or not a document with provided ID exists.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} options [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.documentExists = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.fetch', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n};\n\n/**\n * Instantiates a CollectionMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\n  kuzzleMapping = new CollectionMapping(this);\n  kuzzleMapping.refresh(options, cb);\n};\n\n/**\n * Create the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Create or replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create or replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Delete specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to delete\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Get specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Update the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to update\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Retrieves the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.getSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a Document instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created won’t be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\n\nCollection.prototype.search = function (filters, options, cb) {\n  var\n    query = {body: filters},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.search', cb);\n\n  self.kuzzle.query(self.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n    if (error) {\n      return cb(error);\n    }\n\n    cb(null, new KuzzleSearchResult(self, filters, options, result));\n  });\n};\n\n/**\n * A \"scroll\" option can be passed to search queries, creating persistent\n * paginated results.\n * This method can be used to manually get the next page of a search result,\n * instead of using KuzzleSearchResult.next()\n *\n * @param {string} scrollId\n * @param {object} [options]\n * @param {object} [filters]\n * @param {responseCallback} cb\n */\nCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Collection.scroll: scrollId is required');\n  }\n\n  if (!cb) {\n    cb = filters;\n    filters = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\n  request.scrollId = scrollId;\n\n  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n    if (error) {\n      return cb(error);\n    }\n\n    cb(null, new KuzzleSearchResult(self, filters, options, result));\n  });\n};\n\n/**\n * Retrieves next result of a search with scroll query.\n *\n * @param {string} scrollId\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n  var\n    data = { scrollId: scrollId };\n\n  if (!scrollId) {\n    throw new Error('Collection.scrollSpecifications: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\n  this.kuzzle.query(\n    { controller: 'collection', action: 'scrollSpecifications'},\n    data,\n    options,\n    function (err, res) {\n      cb (err, err ? undefined : res.result);\n    }\n  );\n};\n\n/**\n * Searches specifications across indexes/collections according to the provided filters\n *\n * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.searchSpecifications = function (filters, options, cb) {\n  var\n    data = { body: { query: filters } },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\n  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Create a subscription room to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @returns {*} KuzzleRoom object\n */\nCollection.prototype.room = function (filters, options) {\n  return new Room(this, filters, options);\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} notificationCB - called for each new notification\n * @returns {*} KuzzleRoom object\n */\nCollection.prototype.subscribe = function (filters, options, notificationCB) {\n  var\n    evtName,\n    room;\n\n  if (!notificationCB && typeof options === 'function') {\n    notificationCB = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.subscribe', notificationCB);\n\n  evtName = (options && options.users && options.users !== 'none') ? 'user' : 'document';\n  room = new Room(this, filters, options);\n\n  room.subscribe().on(evtName, notificationCB);\n  return room;\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options && options.retryOnConflict) {\n    data.retryOnConflict = options.retryOnConflict;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    (new Document(self, res.result._id)).refresh(cb);\n  });\n\n  return self;\n};\n\n/**\n * Updates the current specifications of this collection\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Validates the provided specifications\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result.valid);\n  });\n};\n\n/**\n * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nCollection.prototype.document = function (id, content) {\n  return new Document(this, id, content);\n};\n\n/**\n * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n * @constructor\n */\nCollection.prototype.collectionMapping = function (mapping) {\n  return new CollectionMapping(this, mapping);\n};\n\nmodule.exports = Collection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Collection.js\n// module id = 11\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you won’t be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} collection - Instance of the inherited Collection object\n * @param {object} [mapping] - mappings\n * @constructor\n */\nfunction CollectionMapping(collection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nCollectionMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = {\n      body: {\n        properties: this.mapping\n      }\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the “apply” function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nCollectionMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n      }\n    } else {\n      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function won’t be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {CollectionMapping}\n */\nCollectionMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\nmodule.exports = CollectionMapping;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CollectionMapping.js\n// module id = 12\n// module chunks = 0","// Parameter mutualization\nvar\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true, \n    required: ['_id', 'cursor'], \n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']};\n\n// Redis commands\nvar\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    flushdb: {mapResults: mapNoResult},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: {required: ['_id', 'field', 'value']},\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n    hscan: getxScan,\n    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n    mget: getKeys,\n    mset: {required: ['entries'], mapResults: mapNoResult},\n    msetnx: {required: ['entries'], mapResults: Boolean},\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: {required: ['_id'], mapResults: Boolean},\n    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction MemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = [];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\n(function () {\n  Object.keys(commands).forEach(function (command) {\n    MemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (args.length && typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\n      if (!commands[command].getter) {\n        data.body = {};\n      }\n\n      if (commands[command].required) {\n        commands[command].required.forEach(function (param) {\n          var value = args.shift();\n\n          if (value === undefined) {\n            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n          }\n\n          assignParameter(data, commands[command].getter, param, value);\n        });\n      }\n\n      if (args.length > 1) {\n        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n      }\n\n      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n      }\n\n      if (args.length) {\n        options = Object.assign({}, args[0]);\n\n        if (Array.isArray(commands[command].opts)) {\n          commands[command].opts.forEach(function (opt) {\n            if (options[opt] !== null && options[opt] !== undefined) {\n              assignParameter(data, commands[command].getter, opt, options[opt]);\n              delete options[opt];\n            }\n          });\n        }\n      }\n\n      /*\n       Options function mapper does not necessarily need\n       options to be passed by clients.\n       */\n      if (typeof commands[command].opts === 'function') {\n        commands[command].opts(data, options || {});\n      }\n\n      this.kuzzle.query(query, data, options, cb && function (err, res) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (commands[command].mapResults) {\n          return cb(null, commands[command].mapResults(res.result));\n        }\n\n        cb(null, res.result);\n      });\n\n      if (!commands[command].getter) {\n        return this;\n      }\n    };\n  });\n})();\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  var parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions(data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults(results) {\n  return results.map(function (coords) {\n    return coords.map(function (latlon) {\n      return parseFloat(latlon);\n    });\n  });\n}\n\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    var p = {\n        name: point[0]\n      },\n      i;\n\n    for (i = 1; i < point.length; i++) {\n      // withcoord result are in an array...\n      if (Array.isArray(point[i])) {\n        p.coordinates = point[i].map(function (coord) {\n          return parseFloat(coord);\n        });\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(point[i]);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray(results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt(results) {\n  return results.map(function (value) {\n    return parseInt(value);\n  });\n}\n\n/**\n * Disable results for routes like flushdb\n * @return {undefined}\n */\nfunction mapNoResult() {\n  return undefined;\n}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults(results) {\n  var\n    buffer = null,\n    mapped = [];\n\n  results.forEach(function (value) {\n    if (buffer === null) {\n      buffer = value;\n    }\n    else {\n      mapped.push({member: buffer, score: parseFloat(value)});\n      buffer = null;\n    }\n  });\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\", \n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n * \n * @param  {array.<string|array>} results \n * @return {object}\n */\nfunction mapScanResults(results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/MemoryStorage.js\n// module id = 13\n// module chunks = 0","/**\n *\n * @param protocol\n * @param host\n * @param options\n * @returns {Object} Instantiated WebSocket/Socket.IO object\n */\n\nfunction network(protocol, host, options) {\n  switch (protocol) {\n    case 'websocket':\n      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n        throw new Error('Aborting: no websocket support detected.');\n      }\n      return new (require('./protocols/websocket'))(host, options);\n    case 'socketio':\n      if (!window.io) {\n        throw new Error('Aborting: no socket.io library loaded.');\n      }\n      return new (require('./protocols/socketio'))(host, options);\n    default:\n      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n  }\n}\n\nmodule.exports = network;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/index.js\n// module id = 14\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Profile(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nProfile.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Profile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Profile} this\n */\nProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {Profile} this\n */\nProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {Profile} this\n */\nProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = Profile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Profile.js\n// module id = 15\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Role(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nRole.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Role\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Role} this object\n */\nRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = Role;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Role.js\n// module id = 16\n// module chunks = 0","var\n  Role = require('./Role'),\n  Profile = require('./Profile'),\n  User = require('./User');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {Security}\n * @constructor\n */\nfunction Security(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.fetchRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for fetchRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new Role(self, doc._id, doc._source, doc._meta);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @param {object} meta - role metadata\n * @constructor\n */\nSecurity.prototype.role = function(id, content, meta) {\n  return new Role(this, id, content, meta);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new Profile(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {array} policies - list of policies to attach to the new profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = { policies: policies };\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {array} policies - the list of policies to apply to this profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = {policies: policies};\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollProfiles: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n    var profiles = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (profile) {\n      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\n      newProfile.version = profile._version;\n\n      profiles.push(newProfile);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      profiles: profiles,\n      scrollId: scrollId\n    });\n  });\n};\n\n/**\n * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @param {object} meta - profile metadata\n * @constructor\n */\nSecurity.prototype.profile = function(id, content, meta) {\n  return new Profile(this, id, content, meta);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created won’t be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId = null;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new User(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Replace an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.replaceUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (content.profileIds) {\n    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollUsers: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n    var users = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (user) {\n      var newUser = new User(self, user._id, user._source, user._meta);\n\n      newUser.version = user._version;\n\n      users.push(newUser);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      users: users,\n      scrollId: scrollId\n    });\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @param {object} meta - user metadata\n * @constructor\n */\nSecurity.prototype.user = function(id, content, meta) {\n  return new User(this, id, content, meta);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the user <kuid> .\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a list of accepted fields per authentication strategy.\n *\n * @param options\n * @param cb\n */\nSecurity.prototype.getAllCredentialFields = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Retrieve the list of accepted field names by the specified <strategy>.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Get credential information of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Check the existence of the specified <strategy>’s credentials for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Updates credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n */\nSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\nmodule.exports = Security;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Security.js\n// module id = 17\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/bytesToUuid.js\n// module id = 18\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/rng-browser.js\n// module id = 19\n// module chunks = 0"],"sourceRoot":""}